{"files":[{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","dev.rs"],"content":"//! Developer experience commands for KAMI tool authors.\n//!\n//! Provides `kami dev watch <tool-dir>` — rebuilds WASM on file changes.\n\nuse std::path::PathBuf;\nuse std::sync::mpsc;\nuse std::time::{Duration, Instant};\n\nuse clap::{Parser, Subcommand};\nuse notify::{Event, EventKind, RecursiveMode, Watcher};\n\n/// Developer experience commands.\n#[derive(Debug, Parser)]\npub struct DevArgs {\n    #[command(subcommand)]\n    command: DevCommand,\n}\n\n#[derive(Debug, Subcommand)]\nenum DevCommand {\n    /// Watch a tool directory and rebuild WASM on file changes.\n    Watch(WatchArgs),\n}\n\n/// Arguments for the watch subcommand.\n#[derive(Debug, Parser)]\npub struct WatchArgs {\n    /// Path to the tool project directory (contains Cargo.toml).\n    pub tool_dir: PathBuf,\n    /// Build in release mode.\n    #[arg(long)]\n    pub release: bool,\n}\n\n/// Dispatch to the appropriate dev subcommand.\n///\n/// # Errors\n/// Returns an error if the subcommand fails.\npub async fn execute(args: &DevArgs) -> anyhow::Result<()> {\n    match &args.command {\n        DevCommand::Watch(watch) => run_watch(watch).await,\n    }\n}\n\n/// Watches a tool directory for source changes and rebuilds the WASM.\nasync fn run_watch(args: &WatchArgs) -> anyhow::Result<()> {\n    let dir = args.tool_dir.canonicalize().map_err(|e| {\n        anyhow::anyhow!(\"invalid tool directory '{}': {e}\", args.tool_dir.display())\n    })?;\n    println!(\"[WATCH] monitoring {}\", dir.display());\n\n    let (tx, rx) = mpsc::channel::<notify::Result<Event>>();\n    let mut watcher = notify::recommended_watcher(move |ev| {\n        let _ = tx.send(ev);\n    })?;\n    watcher.watch(&dir, RecursiveMode::Recursive)?;\n\n    // Initial build.\n    match build_wasm(&dir, args.release) {\n        Ok(()) => println!(\"[OK] initial build succeeded\"),\n        Err(e) => eprintln!(\"[ERROR] initial build failed: {e}\"),\n    }\n\n    let debounce = Duration::from_millis(400);\n    let mut last_build = Instant::now();\n\n    loop {\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        let mut changed = false;\n        while let Ok(Ok(event)) = rx.try_recv() {\n            if is_source_event(&event) {\n                changed = true;\n            }\n        }\n        if changed && last_build.elapsed() >= debounce {\n            println!(\"[WATCH] change detected, rebuilding…\");\n            match build_wasm(&dir, args.release) {\n                Ok(()) => println!(\"[OK] rebuild succeeded\"),\n                Err(e) => eprintln!(\"[ERROR] rebuild failed: {e}\"),\n            }\n            last_build = Instant::now();\n        }\n    }\n}\n\n/// Returns `true` if the event touched a `.rs` or `.toml` source file.\nfn is_source_event(event: &Event) -> bool {\n    let dominated = matches!(\n        event.kind,\n        EventKind::Create(_) | EventKind::Remove(_) | EventKind::Modify(_)\n    );\n    dominated\n        && event\n            .paths\n            .iter()\n            .any(|p| matches!(p.extension().and_then(|e| e.to_str()), Some(\"rs\" | \"toml\")))\n}\n\n/// Runs `cargo build --target wasm32-wasip2` in the given directory.\nfn build_wasm(dir: &std::path::Path, release: bool) -> anyhow::Result<()> {\n    let mut cmd = std::process::Command::new(\"cargo\");\n    cmd.arg(\"build\")\n        .arg(\"--target\")\n        .arg(\"wasm32-wasip2\")\n        .current_dir(dir);\n    if release {\n        cmd.arg(\"--release\");\n    }\n    let status = cmd\n        .status()\n        .map_err(|e| anyhow::anyhow!(\"failed to spawn cargo: {e}\"))?;\n    if status.success() {\n        Ok(())\n    } else {\n        Err(anyhow::anyhow!(\"cargo exited with {status}\"))\n    }\n}\n\n#[cfg(test)]\n#[path = \"dev_tests.rs\"]\nmod tests;\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":96,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":112,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":17,"coverable":46},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","dev_tests.rs"],"content":"//! Tests for the `kami dev` subcommands.\r\n\r\nuse super::*;\r\n\r\n#[test]\r\nfn rs_file_triggers_rebuild() {\r\n    let event = Event {\r\n        kind: EventKind::Create(notify::event::CreateKind::File),\r\n        paths: vec![PathBuf::from(\"src/lib.rs\")],\r\n        attrs: Default::default(),\r\n    };\r\n    assert!(is_source_event(&event));\r\n}\r\n\r\n#[test]\r\nfn png_file_ignored() {\r\n    let event = Event {\r\n        kind: EventKind::Modify(notify::event::ModifyKind::Data(\r\n            notify::event::DataChange::Content,\r\n        )),\r\n        paths: vec![PathBuf::from(\"assets/logo.png\")],\r\n        attrs: Default::default(),\r\n    };\r\n    assert!(!is_source_event(&event));\r\n}\r\n\r\n#[test]\r\nfn build_wasm_fails_without_cargo_toml() {\r\n    let tmp = std::env::temp_dir().join(\"kami_test_no_cargo\");\r\n    std::fs::create_dir_all(&tmp).ok();\r\n    let result = build_wasm(&tmp, false);\r\n    assert!(result.is_err());\r\n    std::fs::remove_dir_all(&tmp).ok();\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","exec.rs"],"content":"//! `kami exec` command.\n//!\n//! Executes a tool by its registry ID using the full runtime pipeline:\n//! resolution, caching, scheduling, and sandboxed execution.\n\nuse clap::Args;\n\nuse kami_types::{DiagnosticError, ToolId};\n\nuse crate::{input, output, shared};\n\n/// Execute a registered tool by its ID.\n#[derive(Debug, Args)]\npub struct ExecArgs {\n    /// Tool ID (reverse-domain notation, e.g. dev.example.fetch-url).\n    pub tool: String,\n    /// JSON input string to pass to the tool's `run` function.\n    #[arg(short, long, default_value = \"{}\")]\n    pub input: String,\n    /// Read JSON input from a file (use \"-\" for stdin).\n    #[arg(short = 'f', long)]\n    pub input_file: Option<String>,\n    /// Maximum concurrent tool executions.\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size.\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the exec command.\npub async fn execute(args: &ExecArgs) -> anyhow::Result<()> {\n    let resolved_input = input::resolve_input(&args.input, args.input_file.as_deref())?;\n\n    let repo = shared::open_repository(&args.db)?;\n    let tool_id = ToolId::new(&args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let runtime = shared::create_runtime(repo, args.concurrency, args.cache_size)?;\n\n    tracing::info!(\n        tool = %args.tool,\n        input = %resolved_input,\n        \"Executing tool from registry\"\n    );\n\n    let result = runtime\n        .execute(&tool_id, &resolved_input)\n        .await\n        .map_err(|e| {\n            if let Some(hint) = e.hint() {\n                eprintln!(\"\\n  Cause: {hint}\");\n            }\n            if let Some(fix) = e.fix() {\n                eprintln!(\"  Fix:   {fix}\\n\");\n            }\n            anyhow::anyhow!(\"execution failed: {e}\")\n        })?;\n\n    if result.success {\n        println!(\"{}\", result.content);\n    } else {\n        output::print_error(&result.content);\n    }\n\n    tracing::debug!(\n        duration_ms = result.duration_ms,\n        fuel_consumed = result.fuel_consumed,\n        success = result.success,\n        \"Execution complete\"\n    );\n\n    Ok(())\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","init.rs"],"content":"//! `kami init` command.\n//!\n//! Scaffolds a new KAMI tool project with Cargo.toml, tool.toml,\n//! and a minimal src/lib.rs handler.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse crate::commands::templates;\nuse crate::output;\n\n/// Scaffold a new KAMI tool project.\n#[derive(Debug, Args)]\npub struct InitArgs {\n    /// Tool name (e.g. \"my-tool\"). Used for directory and crate name.\n    pub name: String,\n    /// Reverse-domain prefix for the tool ID (e.g. \"dev.example\").\n    #[arg(short, long, default_value = \"dev.example\")]\n    pub prefix: String,\n}\n\n/// Executes the init command in the current working directory.\npub fn execute(args: &InitArgs) -> anyhow::Result<()> {\n    execute_at(args, Path::new(\".\"))\n}\n\n/// Executes the init command with an explicit base directory (testable).\npub(crate) fn execute_at(args: &InitArgs, base_dir: &Path) -> anyhow::Result<()> {\n    let dir = base_dir.join(&args.name);\n    if dir.exists() {\n        anyhow::bail!(\"directory already exists: {}\", dir.display());\n    }\n\n    let tool_id = format!(\"{}.{}\", args.prefix, args.name);\n    let crate_name = args.name.replace('-', \"_\");\n\n    std::fs::create_dir_all(dir.join(\"src\"))?;\n\n    write_cargo_toml(&dir, &args.name)?;\n    write_tool_toml(&dir, &tool_id, &args.name, &crate_name)?;\n    write_lib_rs(&dir, &tool_id)?;\n    std::fs::write(dir.join(\".gitignore\"), templates::GITIGNORE)?;\n\n    print_success(&args.name, &crate_name);\n    Ok(())\n}\n\nfn write_cargo_toml(dir: &Path, name: &str) -> anyhow::Result<()> {\n    let content = templates::apply(templates::CARGO_TOML, &[(\"__TOOL_NAME__\", name)]);\n    std::fs::write(dir.join(\"Cargo.toml\"), content)?;\n    Ok(())\n}\n\nfn write_tool_toml(dir: &Path, tool_id: &str, name: &str, crate_name: &str) -> anyhow::Result<()> {\n    let content = templates::apply(\n        templates::TOOL_TOML,\n        &[\n            (\"__TOOL_ID__\", tool_id),\n            (\"__TOOL_NAME__\", name),\n            (\"__CRATE_NAME__\", crate_name),\n        ],\n    );\n    std::fs::write(dir.join(\"tool.toml\"), content)?;\n    Ok(())\n}\n\nfn write_lib_rs(dir: &Path, tool_id: &str) -> anyhow::Result<()> {\n    let content = templates::apply(templates::LIB_RS, &[(\"__TOOL_ID__\", tool_id)]);\n    std::fs::write(dir.join(\"src\").join(\"lib.rs\"), content)?;\n    Ok(())\n}\n\nfn print_success(name: &str, crate_name: &str) {\n    output::print_success(&format!(\"Created tool project: {name}/\"));\n    println!();\n    println!(\"  {name}/\");\n    println!(\"  ├── Cargo.toml\");\n    println!(\"  ├── tool.toml\");\n    println!(\"  ├── .gitignore\");\n    println!(\"  └── src/\");\n    println!(\"      └── lib.rs\");\n    println!();\n    println!(\"Next steps:\");\n    println!(\"  cd {name}\");\n    println!(\"  cargo build --target wasm32-wasip2 --release\");\n    println!(\"  cp target/wasm32-wasip2/release/{crate_name}.wasm .\");\n    println!(\"  kami validate .\");\n    println!(\"  kami install .\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn init_creates_expected_files() {\n        let tmp = tempfile::tempdir().expect(\"tempdir\");\n        let args = InitArgs {\n            name: \"test-tool\".to_string(),\n            prefix: \"dev.test\".to_string(),\n        };\n        execute_at(&args, tmp.path()).expect(\"init\");\n\n        let base = tmp.path().join(\"test-tool\");\n        assert!(base.join(\"Cargo.toml\").exists());\n        assert!(base.join(\"tool.toml\").exists());\n        assert!(base.join(\"src/lib.rs\").exists());\n        assert!(base.join(\".gitignore\").exists());\n\n        let cargo = std::fs::read_to_string(base.join(\"Cargo.toml\")).expect(\"read Cargo.toml\");\n        assert!(cargo.contains(\"name = \\\"test-tool\\\"\"));\n        assert!(cargo.contains(\"path = \\\"../crates/kami-guest\\\"\"));\n\n        let tool = std::fs::read_to_string(base.join(\"tool.toml\")).expect(\"read tool.toml\");\n        assert!(tool.contains(\"id = \\\"dev.test.test-tool\\\"\"));\n\n        let lib = std::fs::read_to_string(base.join(\"src/lib.rs\")).expect(\"read lib.rs\");\n        assert!(lib.contains(\"name: \\\"dev.test.test-tool\\\"\"));\n    }\n\n    #[test]\n    fn init_fails_if_dir_exists() {\n        let tmp = tempfile::tempdir().expect(\"tempdir\");\n        std::fs::create_dir_all(tmp.path().join(\"existing\")).expect(\"mkdir\");\n        let args = InitArgs {\n            name: \"existing\".to_string(),\n            prefix: \"dev.test\".to_string(),\n        };\n        assert!(execute_at(&args, tmp.path()).is_err());\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":45,"coverable":47},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","inspect.rs"],"content":"//! `kami inspect` command.\n//!\n//! Displays detailed information about an installed tool.\n\nuse clap::Args;\n\nuse kami_types::ToolId;\n\nuse crate::{output, shared};\n\n/// Inspect a tool's manifest and capabilities.\n#[derive(Debug, Args)]\npub struct InspectArgs {\n    /// Tool ID (reverse-domain notation).\n    pub tool: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the inspect command.\npub async fn execute(args: &InspectArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n\n    let id = ToolId::new(&args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let tool = repo\n        .find_by_id(&id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"query error: {e}\"))?;\n\n    let tool = match tool {\n        Some(t) => t,\n        None => {\n            output::print_error(&format!(\"tool not found: {}\", args.tool));\n            return Ok(());\n        }\n    };\n\n    let m = &tool.manifest;\n    let sec = &m.security;\n\n    println!(\"Tool: {} v{}\", m.id, m.version);\n    println!(\"Name: {}\", m.name);\n    println!(\"Description: {}\", m.description);\n    println!(\"WASM: {}\", m.wasm);\n    println!(\"Install path: {}\", tool.install_path);\n    println!(\n        \"Status: {}\",\n        if tool.enabled { \"enabled\" } else { \"disabled\" }\n    );\n\n    println!(\"\\nSecurity:\");\n    println!(\"  Filesystem: {:?}\", sec.fs_access);\n    if sec.net_allow_list.is_empty() {\n        println!(\"  Network: deny-all\");\n    } else {\n        println!(\"  Network: {}\", sec.net_allow_list.join(\", \"));\n    }\n    if sec.env_allow_list.is_empty() {\n        println!(\"  Env vars: deny-all\");\n    } else {\n        println!(\"  Env vars: {}\", sec.env_allow_list.join(\", \"));\n    }\n\n    println!(\"\\nResource limits:\");\n    println!(\"  Memory: {} MB\", sec.limits.max_memory_mb);\n    println!(\"  Timeout: {} ms\", sec.limits.max_execution_ms);\n    println!(\"  Fuel: {}\", sec.limits.max_fuel);\n\n    if !m.arguments.is_empty() {\n        println!(\"\\nArguments:\");\n        for arg in &m.arguments {\n            let req = if arg.required { \"required\" } else { \"optional\" };\n            println!(\n                \"  {} ({}, {}): {}\",\n                arg.name, arg.arg_type, req, arg.description\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","install.rs"],"content":"//! `kami install` command.\n//!\n//! Parses a tool.toml manifest, validates it, and registers the tool\n//! in the SQLite registry.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_runtime::compute_file_hash;\nuse kami_types::Tool;\n\nuse crate::{output, shared};\n\n/// Install a WASM tool into the registry.\n#[derive(Debug, Args)]\npub struct InstallArgs {\n    /// Path to the tool directory containing tool.toml.\n    pub path: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the install command.\npub async fn execute(args: &InstallArgs) -> anyhow::Result<()> {\n    let tool_path = Path::new(&args.path);\n\n    // Resolve tool.toml location\n    let manifest_path = if tool_path.is_dir() {\n        tool_path.join(\"tool.toml\")\n    } else if tool_path.extension().is_some_and(|e| e == \"toml\") {\n        tool_path.to_path_buf()\n    } else {\n        anyhow::bail!(\"expected a directory containing tool.toml or a .toml file\");\n    };\n\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found: {}\", manifest_path.display());\n    }\n\n    tracing::info!(\n        path = %manifest_path.display(),\n        \"Parsing tool manifest\"\n    );\n\n    // 1. Parse manifest\n    let mut manifest = parse_tool_manifest_file(&manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    // 2. Verify WASM file exists and compute integrity hash\n    let tool_dir = manifest_path.parent().unwrap_or_else(|| Path::new(\".\"));\n    let wasm_path = tool_dir.join(&manifest.wasm);\n    if !wasm_path.exists() {\n        anyhow::bail!(\n            \"WASM file not found: {} (referenced in tool.toml)\",\n            wasm_path.display()\n        );\n    }\n\n    let wasm_hash = compute_file_hash(&wasm_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to hash WASM file: {e}\"))?;\n\n    tracing::info!(\n        hash = %wasm_hash,\n        \"SHA-256 computed for WASM file\"\n    );\n\n    manifest.wasm_sha256 = Some(wasm_hash);\n\n    // 3. Open registry\n    let repo = shared::open_repository(&args.db)?;\n\n    // 4. Check for duplicates\n    if let Some(existing) = repo\n        .find_by_id(&manifest.id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?\n    {\n        anyhow::bail!(\n            \"tool {} v{} is already installed\",\n            existing.manifest.id,\n            existing.manifest.version,\n        );\n    }\n\n    // 5. Register the tool\n    let install_path = tool_dir\n        .canonicalize()\n        .unwrap_or_else(|_| tool_dir.to_path_buf())\n        .display()\n        .to_string();\n\n    let tool = Tool {\n        manifest,\n        install_path,\n        enabled: true,\n        pinned_version: None,\n        updated_at: None,\n    };\n\n    repo.insert(&tool)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"insert error: {e}\"))?;\n\n    output::print_success(&format!(\n        \"Installed {} v{}\",\n        tool.manifest.id, tool.manifest.version\n    ));\n\n    Ok(())\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","list.rs"],"content":"//! `kami list` command.\n//!\n//! Lists installed tools from the SQLite registry.\n\nuse clap::Args;\n\nuse kami_registry::ToolQuery;\n\nuse crate::shared;\n\n/// List installed tools.\n#[derive(Debug, Args)]\npub struct ListArgs {\n    /// Filter by name (substring match).\n    #[arg(short, long)]\n    pub filter: Option<String>,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the list command.\npub async fn execute(args: &ListArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n\n    let mut query = ToolQuery::all();\n    if let Some(ref name) = args.filter {\n        query = query.with_name(name);\n    }\n\n    let tools = repo\n        .find_all(query)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"query error: {e}\"))?;\n\n    if tools.is_empty() {\n        println!(\"No tools installed.\");\n        return Ok(());\n    }\n\n    println!(\"{:<35} {:<10} {:<8} DESCRIPTION\", \"ID\", \"VERSION\", \"STATUS\");\n    println!(\"{}\", \"-\".repeat(80));\n\n    for tool in &tools {\n        let status = if tool.enabled { \"enabled\" } else { \"disabled\" };\n        println!(\n            \"{:<35} {:<10} {:<8} {}\",\n            tool.manifest.id, tool.manifest.version, status, tool.manifest.description,\n        );\n    }\n\n    println!(\"\\n{} tool(s) installed.\", tools.len());\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","mod.rs"],"content":"//! CLI command definitions.\n\npub mod dev;\npub mod exec;\npub mod init;\npub mod inspect;\npub mod install;\npub mod list;\npub mod pin;\npub mod run;\npub mod serve;\npub mod status;\npub mod templates;\npub mod uninstall;\npub mod update;\npub mod validate;\npub mod verify;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","pin.rs"],"content":"//! `kami pin` command.\n//!\n//! Pins a tool to its current version (or a specified version),\n//! preventing `kami update` from changing it. Use `--unpin` to remove.\n\nuse clap::Args;\n\nuse crate::{output, shared};\n\n/// Pin or unpin a tool version.\n#[derive(Debug, Args)]\npub struct PinArgs {\n    /// Tool ID to pin/unpin.\n    pub tool_id: String,\n    /// Version to pin to (defaults to the currently installed version).\n    pub version: Option<String>,\n    /// Remove the version pin.\n    #[arg(long)]\n    pub unpin: bool,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the pin command.\npub async fn execute(args: &PinArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n    let id: kami_types::ToolId = args.tool_id.parse().map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n\n    let mut tool = repo\n        .find_by_id(&id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool not found: {id}\"))?;\n\n    if args.unpin {\n        tool.pinned_version = None;\n        repo.update(&tool)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n        output::print_success(&format!(\"Unpinned {id}\"));\n        return Ok(());\n    }\n\n    let pin_ver = args\n        .version\n        .clone()\n        .unwrap_or_else(|| tool.manifest.version.to_string());\n\n    tool.pinned_version = Some(pin_ver.clone());\n    repo.update(&tool)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    output::print_success(&format!(\"Pinned {id} to v{pin_ver}\"));\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pin_args_default_unpin_is_false() {\n        let args = PinArgs {\n            tool_id: \"dev.test.x\".to_string(),\n            version: None,\n            unpin: false,\n            db: None,\n        };\n        assert!(!args.unpin);\n        assert!(args.version.is_none());\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","run.rs"],"content":"//! `kami run` command.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_engine::{create_engine, create_linker, load_component_from_file, InstanceConfig};\nuse kami_runtime::{ToolExecutor, WasmToolExecutor};\nuse kami_types::{ResourceLimits, SecurityConfig};\n\nuse crate::input;\n\n/// Run a WASM component directly from a file.\n#[derive(Debug, Args)]\npub struct RunArgs {\n    /// Path to the .wasm component file.\n    pub wasm_file: String,\n    /// JSON input string to pass to the tool's `run` function.\n    #[arg(short, long, default_value = \"{}\")]\n    pub input: String,\n    /// Read JSON input from a file (use \"-\" for stdin).\n    #[arg(short = 'f', long)]\n    pub input_file: Option<String>,\n    /// Fuel limit for execution.\n    #[arg(short, long, default_value = \"1000000\")]\n    pub fuel: u64,\n    /// Maximum memory in MB.\n    #[arg(short, long, default_value = \"64\")]\n    pub max_memory_mb: u32,\n    /// Execution timeout in milliseconds.\n    #[arg(short, long, default_value = \"5000\")]\n    pub timeout_ms: u64,\n}\n\n/// Executes the run command using the async runtime.\npub async fn execute(args: &RunArgs) -> anyhow::Result<()> {\n    let wasm_path = Path::new(&args.wasm_file);\n    if !wasm_path.exists() {\n        anyhow::bail!(\"WASM file not found: {}\", args.wasm_file);\n    }\n\n    let resolved_input = input::resolve_input(&args.input, args.input_file.as_deref())?;\n\n    tracing::info!(path = %args.wasm_file, \"Loading WASM component\");\n\n    // 1. Create engine and linker (epoch interruption for timeout)\n    let config = InstanceConfig {\n        epoch_interruption: true,\n        ..InstanceConfig::default()\n    };\n    let engine = create_engine(&config)?;\n    let linker = create_linker(&engine)?;\n\n    // 2. Load the component\n    let component = load_component_from_file(&engine, wasm_path)?;\n\n    // 3. Build security config from CLI args\n    let security = SecurityConfig {\n        limits: ResourceLimits {\n            max_fuel: args.fuel,\n            max_memory_mb: args.max_memory_mb,\n            max_execution_ms: args.timeout_ms,\n        },\n        ..SecurityConfig::default()\n    };\n\n    // 4. Execute with full isolation\n    let executor = WasmToolExecutor::new(engine, linker);\n\n    tracing::info!(\n        input = %resolved_input,\n        fuel = args.fuel,\n        max_memory_mb = args.max_memory_mb,\n        timeout_ms = args.timeout_ms,\n        \"Executing tool\"\n    );\n\n    let result = executor\n        .execute(&component, &resolved_input, &security)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"execution failed: {e}\"))?;\n\n    // 5. Output result\n    if result.success {\n        println!(\"{}\", result.content);\n    } else {\n        eprintln!(\"[ERROR] {}\", result.content);\n    }\n    tracing::debug!(\n        duration_ms = result.duration_ms,\n        fuel_consumed = result.fuel_consumed,\n        success = result.success,\n        \"Execution complete\"\n    );\n\n    Ok(())\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","serve.rs"],"content":"//! `kami serve` command.\n//!\n//! Starts the MCP server over stdio or HTTP, exposing registered tools\n//! via JSON-RPC 2.0.\n\nuse std::sync::Arc;\n\nuse clap::Args;\n\nuse kami_transport_http::HttpServer;\nuse kami_transport_stdio::{McpHandler, McpServer, StdioTransport};\n\nuse crate::shared;\n\n/// Start the MCP server (stdio or HTTP).\n#[derive(Debug, Args)]\npub struct ServeArgs {\n    /// Transport mode: stdio (default) or http.\n    #[arg(long, default_value = \"stdio\", value_parser = [\"stdio\", \"http\"])]\n    pub transport: String,\n    /// TCP port for HTTP transport.\n    #[arg(long, default_value = \"3000\")]\n    pub port: u16,\n    /// Bearer token for HTTP transport authentication (optional).\n    #[arg(long)]\n    pub token: Option<String>,\n    /// Maximum concurrent tool executions.\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size.\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the serve command.\npub async fn execute(args: &ServeArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n    let runtime = Arc::new(shared::create_runtime(\n        repo.clone(),\n        args.concurrency,\n        args.cache_size,\n    )?);\n\n    match args.transport.as_str() {\n        \"http\" => {\n            let handler = Arc::new(McpHandler::new(runtime.clone(), repo));\n            let server = HttpServer::new(handler, args.port, args.token.clone());\n            tokio::select! {\n                result = server.run() => {\n                    result.map_err(|e| anyhow::anyhow!(\"server error: {e}\"))?;\n                }\n                _ = tokio::signal::ctrl_c() => {\n                    tracing::info!(\"shutdown signal received\");\n                    runtime.shutdown().await;\n                }\n            }\n        }\n        _ => {\n            let handler = McpHandler::new(runtime.clone(), repo);\n            let transport = StdioTransport::new(tokio::io::stdin(), tokio::io::stdout());\n            let mut server = McpServer::new(transport, handler);\n            tracing::info!(\"KAMI MCP server ready on stdio\");\n            tokio::select! {\n                result = server.run() => {\n                    result.map_err(|e| anyhow::anyhow!(\"server error: {e}\"))?;\n                }\n                _ = tokio::signal::ctrl_c() => {\n                    tracing::info!(\"shutdown signal received\");\n                    runtime.shutdown().await;\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","status.rs"],"content":"//! `kami status` command.\n//!\n//! Displays tool registry statistics and runtime configuration.\n\nuse clap::Args;\n\nuse kami_registry::ToolQuery;\n\nuse crate::output;\nuse crate::shared;\n\n/// Show KAMI runtime status and installed tool statistics.\n#[derive(Debug, Args)]\npub struct StatusArgs {\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n    /// Maximum concurrent tool executions (for display).\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size in slots (for display).\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n}\n\n/// Executes the status command.\npub async fn execute(args: &StatusArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n    let tools = repo\n        .find_all(ToolQuery::all())\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry query: {e}\"))?;\n\n    let enabled = tools.iter().filter(|t| t.enabled).count();\n    let disabled = tools.len() - enabled;\n    let db_path = args.db.clone().unwrap_or_else(output::default_db_path);\n\n    println!(\"KAMI Runtime Status\");\n    println!(\"{}\", \"─\".repeat(40));\n    println!(\"  Version    : {}\", env!(\"CARGO_PKG_VERSION\"));\n    println!(\"  Database   : {db_path}\");\n    println!();\n    println!(\"Tool Registry\");\n    println!(\"  Total    : {}\", tools.len());\n    println!(\"  Enabled  : {enabled}\");\n    println!(\"  Disabled : {disabled}\");\n    println!();\n    println!(\"Runtime Configuration\");\n    println!(\n        \"  Concurrency : {} max parallel executions\",\n        args.concurrency\n    );\n    println!(\"  Cache       : {} component slots\", args.cache_size);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn status_args_defaults() {\n        let args = StatusArgs {\n            db: None,\n            concurrency: 4,\n            cache_size: 32,\n        };\n        assert_eq!(args.concurrency, 4);\n        assert_eq!(args.cache_size, 32);\n        assert!(args.db.is_none());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","templates.rs"],"content":"//! Source code templates for `kami init` scaffolding.\n//! Uses `__PLACEHOLDER__` substitution to avoid brace escaping in generated Rust.\n\n/// Cargo.toml template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_NAME__`\npub const CARGO_TOML: &str = r#\"[package]\nname = \"__TOOL_NAME__\"\nversion = \"1.0.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nkami-guest = { path = \"../crates/kami-guest\" }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\n\"#;\n\n/// tool.toml template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_ID__`, `__TOOL_NAME__`, `__CRATE_NAME__`\npub const TOOL_TOML: &str = r#\"[tool]\nid = \"__TOOL_ID__\"\nname = \"__TOOL_NAME__\"\nversion = \"1.0.0\"\nwasm = \"__CRATE_NAME__.wasm\"\n\n[mcp]\ndescription = \"TODO: Describe what this tool does\"\n\n[[mcp.arguments]]\nname = \"input\"\ntype = \"string\"\ndescription = \"TODO: Describe this argument\"\nrequired = true\n\n[security]\nnet_allow_list = []\nfs_access = \"none\"\nmax_memory_mb = 32\nmax_execution_ms = 5000\nmax_fuel = 1000000\n\"#;\n\n/// src/lib.rs template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_ID__`\n/// Uses `r##\"...\"##` delimiter so the template can contain `\"#` sequences.\npub const LIB_RS: &str = r##\"use kami_guest::kami_tool;\n\nkami_tool! {\n    name: \"__TOOL_ID__\",\n    version: \"1.0.0\",\n    description: \"TODO: Describe what this tool does\",\n    handler: handle,\n}\n\nfn handle(input: &str) -> Result<String, String> {\n    let args: serde_json::Value = serde_json::from_str(input)\n        .map_err(|e| format!(\"invalid JSON: {e}\"))?;\n\n    let response = serde_json::json!({\n        \"result\": args,\n        \"tool\": \"__TOOL_ID__\"\n    });\n\n    Ok(response.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_input() {\n        let result = handle(r#\"{\"input\":\"hello\"}\"#);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn invalid_input() {\n        let result = handle(\"not json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn empty_input() {\n        let result = handle(\"{}\");\n        assert!(result.is_ok());\n    }\n}\n\"##;\n\n/// .gitignore template.\npub const GITIGNORE: &str = \"target/\\n*.wasm\\n\";\n\n/// Applies placeholder substitutions to a template string.\n///\n/// `substitutions` is a slice of `(placeholder, value)` pairs.\npub fn apply(template: &str, substitutions: &[(&str, &str)]) -> String {\n    substitutions\n        .iter()\n        .fold(template.to_string(), |acc, (key, val)| {\n            acc.replace(key, val)\n        })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn apply_single_substitution() {\n        let result = apply(\"Hello __NAME__!\", &[(\"__NAME__\", \"KAMI\")]);\n        assert_eq!(result, \"Hello KAMI!\");\n    }\n\n    #[test]\n    fn apply_multiple_substitutions() {\n        let result = apply(\"__A__ and __B__\", &[(\"__A__\", \"foo\"), (\"__B__\", \"bar\")]);\n        assert_eq!(result, \"foo and bar\");\n    }\n\n    #[test]\n    fn apply_repeated_placeholder() {\n        let result = apply(\"__X__ + __X__\", &[(\"__X__\", \"hello\")]);\n        assert_eq!(result, \"hello + hello\");\n    }\n\n    #[test]\n    fn cargo_toml_substitution() {\n        let result = apply(CARGO_TOML, &[(\"__TOOL_NAME__\", \"my-tool\")]);\n        assert!(result.contains(\"name = \\\"my-tool\\\"\"));\n    }\n\n    #[test]\n    fn lib_rs_substitution() {\n        let result = apply(LIB_RS, &[(\"__TOOL_ID__\", \"dev.test.tool\")]);\n        assert!(result.contains(\"name: \\\"dev.test.tool\\\"\"));\n        assert!(result.contains(\"\\\"tool\\\": \\\"dev.test.tool\\\"\"));\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":105,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":106,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":4,"coverable":4},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","uninstall.rs"],"content":"//! `kami uninstall` command.\n//!\n//! Removes a tool from the registry by its ID.\n\nuse clap::Args;\n\nuse kami_types::ToolId;\n\nuse crate::{output, shared};\n\n/// Uninstall a tool from the registry.\n#[derive(Debug, Args)]\npub struct UninstallArgs {\n    /// Tool ID to remove (e.g. dev.example.fetch-url).\n    pub tool: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the uninstall command.\npub async fn execute(args: &UninstallArgs) -> anyhow::Result<()> {\n    let tool_id = ToolId::new(&args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let repo = shared::open_repository(&args.db)?;\n\n    // Check if tool exists before deleting\n    let existing = repo\n        .find_by_id(&tool_id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?;\n\n    match existing {\n        Some(tool) => {\n            repo.delete(&tool_id)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"delete error: {e}\"))?;\n\n            output::print_success(&format!(\n                \"Uninstalled {} v{}\",\n                tool.manifest.id, tool.manifest.version\n            ));\n        }\n        None => {\n            anyhow::bail!(\"tool not found: {}\", args.tool);\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","update.rs"],"content":"//! `kami update` command.\n//!\n//! Re-reads tool.toml from the install path and updates the registry\n//! entry with new manifest data and a fresh WASM hash.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_registry::ToolRepository;\nuse kami_runtime::compute_file_hash;\nuse kami_types::Tool;\n\nuse crate::{output, shared};\n\n/// Update one or all installed tools from their source directories.\n#[derive(Debug, Args)]\npub struct UpdateArgs {\n    /// Tool ID to update (omit for --all).\n    pub tool_id: Option<String>,\n    /// Update all installed tools.\n    #[arg(long)]\n    pub all: bool,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the update command.\npub async fn execute(args: &UpdateArgs) -> anyhow::Result<()> {\n    let repo = shared::open_repository(&args.db)?;\n\n    if args.all {\n        return update_all(&*repo).await;\n    }\n    let id_str = args\n        .tool_id\n        .as_deref()\n        .ok_or_else(|| anyhow::anyhow!(\"provide a tool ID or use --all\"))?;\n    let id = id_str.parse().map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    update_one(&*repo, &id).await\n}\n\n/// Updates a single tool by re-reading its source manifest.\nasync fn update_one(repo: &dyn ToolRepository, id: &kami_types::ToolId) -> anyhow::Result<()> {\n    let existing = repo\n        .find_by_id(id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool not found: {id}\"))?;\n\n    if existing.pinned_version.is_some() {\n        anyhow::bail!(\n            \"tool {} is pinned to v{}; unpin first with `kami pin --unpin {}`\",\n            id,\n            existing.pinned_version.as_deref().unwrap_or(\"?\"),\n            id,\n        );\n    }\n\n    let updated = rebuild_tool(&existing)?;\n    repo.update(&updated)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    output::print_success(&format!(\n        \"Updated {} → v{}\",\n        updated.manifest.id, updated.manifest.version\n    ));\n    Ok(())\n}\n\n/// Re-reads tool.toml and recomputes the WASM hash.\nfn rebuild_tool(existing: &Tool) -> anyhow::Result<Tool> {\n    let install = Path::new(&existing.install_path);\n    let manifest_path = install.join(\"tool.toml\");\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found at {}\", manifest_path.display());\n    }\n    let mut manifest = parse_tool_manifest_file(&manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    let wasm_path = install.join(&manifest.wasm);\n    if wasm_path.exists() {\n        let hash = compute_file_hash(&wasm_path).map_err(|e| anyhow::anyhow!(\"hash error: {e}\"))?;\n        manifest.wasm_sha256 = Some(hash);\n    }\n\n    let now = chrono_now();\n    Ok(Tool {\n        manifest,\n        install_path: existing.install_path.clone(),\n        enabled: existing.enabled,\n        pinned_version: existing.pinned_version.clone(),\n        updated_at: Some(now),\n    })\n}\n\n/// Returns the current UTC time in ISO 8601 format (no chrono dep).\nfn chrono_now() -> String {\n    let dur = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap_or_default();\n    let secs = dur.as_secs();\n    format!(\"{secs}\")\n}\n\n/// Updates every installed tool that is not pinned.\nasync fn update_all(repo: &dyn ToolRepository) -> anyhow::Result<()> {\n    let tools = repo\n        .find_all(kami_registry::ToolQuery::all())\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    if tools.is_empty() {\n        output::print_info(\"No tools installed.\");\n        return Ok(());\n    }\n    let mut updated = 0u32;\n    let mut skipped = 0u32;\n    for tool in &tools {\n        if tool.pinned_version.is_some() {\n            skipped += 1;\n            continue;\n        }\n        match rebuild_tool(tool) {\n            Ok(new_tool) => {\n                repo.update(&new_tool)\n                    .await\n                    .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n                updated += 1;\n            }\n            Err(e) => {\n                tracing::warn!(tool = %tool.manifest.id, \"skip: {e}\");\n                skipped += 1;\n            }\n        }\n    }\n    output::print_success(&format!(\"Updated {updated} tool(s), skipped {skipped}\"));\n    Ok(())\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":74},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","validate.rs"],"content":"//! `kami validate` command.\n//!\n//! Validates a tool.toml manifest and checks that the referenced\n//! WASM file exists. Useful before `kami install`.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_sandbox::validate_security_config;\n\nuse crate::output;\n\n/// Validate a tool.toml manifest without installing.\n#[derive(Debug, Args)]\npub struct ValidateArgs {\n    /// Path to tool directory or tool.toml file.\n    pub path: String,\n}\n\n/// Executes the validate command.\npub fn execute(args: &ValidateArgs) -> anyhow::Result<()> {\n    let tool_path = Path::new(&args.path);\n\n    // Resolve tool.toml location\n    let manifest_path = if tool_path.is_dir() {\n        tool_path.join(\"tool.toml\")\n    } else if tool_path.extension().is_some_and(|e| e == \"toml\") {\n        tool_path.to_path_buf()\n    } else {\n        anyhow::bail!(\"expected a directory containing tool.toml or a .toml file\");\n    };\n\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found: {}\", manifest_path.display());\n    }\n\n    // 1. Parse manifest\n    println!(\"Checking manifest...\");\n    let manifest = parse_tool_manifest_file(&manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    println!(\"  ID:          {}\", manifest.id);\n    println!(\"  Name:        {}\", manifest.name);\n    println!(\"  Version:     {}\", manifest.version);\n    println!(\"  Description: {}\", manifest.description);\n\n    // 2. Validate security config\n    println!(\"Checking security config...\");\n    validate_security_config(&manifest.security)\n        .map_err(|e| anyhow::anyhow!(\"security config error: {e}\"))?;\n\n    println!(\n        \"  Network:     {} host(s) allowed\",\n        manifest.security.net_allow_list.len()\n    );\n    println!(\"  Filesystem:  {:?}\", manifest.security.fs_access);\n    println!(\"  Fuel:        {}\", manifest.security.limits.max_fuel);\n    println!(\n        \"  Memory:      {} MB\",\n        manifest.security.limits.max_memory_mb\n    );\n    println!(\n        \"  Timeout:     {} ms\",\n        manifest.security.limits.max_execution_ms\n    );\n\n    // 3. Check WASM file\n    println!(\"Checking WASM file...\");\n    let tool_dir = manifest_path.parent().unwrap_or_else(|| Path::new(\".\"));\n    let wasm_path = tool_dir.join(&manifest.wasm);\n\n    if wasm_path.exists() {\n        let metadata = std::fs::metadata(&wasm_path)?;\n        println!(\n            \"  WASM:        {} ({} bytes)\",\n            manifest.wasm,\n            metadata.len()\n        );\n    } else {\n        anyhow::bail!(\n            \"WASM file not found: {} (referenced in tool.toml)\",\n            wasm_path.display()\n        );\n    }\n\n    // 4. Check arguments\n    println!(\n        \"Checking arguments... ({} defined)\",\n        manifest.arguments.len()\n    );\n    for arg in &manifest.arguments {\n        let req = if arg.required { \"required\" } else { \"optional\" };\n        println!(\"  {}: {} ({})\", arg.name, arg.arg_type, req);\n    }\n\n    output::print_success(&format!(\n        \"Tool {} v{} is valid\",\n        manifest.id, manifest.version\n    ));\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","verify.rs"],"content":"//! `kami verify` command.\n//!\n//! Verifies the SHA-256 integrity of an installed tool's WASM file.\n//! Compares the stored hash (recorded at install time) with the\n//! current hash of the file on disk.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_runtime::compute_file_hash;\n\nuse crate::{output, shared};\n\n/// Verify the integrity of an installed tool's WASM file.\n#[derive(Debug, Args)]\npub struct VerifyArgs {\n    /// Tool ID to verify (e.g. dev.example.fetch-url).\n    pub tool_id: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option<String>,\n}\n\n/// Executes the verify command.\n///\n/// # Errors\n///\n/// Returns an error if the tool is not found, the WASM file is missing,\n/// or the hash does not match the stored digest.\npub async fn execute(args: &VerifyArgs) -> anyhow::Result<()> {\n    let tool_id: kami_types::ToolId = args\n        .tool_id\n        .parse()\n        .map_err(|e| anyhow::anyhow!(\"invalid tool id: {e}\"))?;\n\n    let repo = shared::open_repository(&args.db)?;\n\n    let tool = repo\n        .find_by_id(&tool_id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool '{}' not found\", args.tool_id))?;\n\n    let wasm_path = Path::new(&tool.install_path).join(&tool.manifest.wasm);\n\n    if !wasm_path.exists() {\n        anyhow::bail!(\"WASM file missing: {}\", wasm_path.display());\n    }\n\n    let actual_hash = compute_file_hash(&wasm_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to hash WASM file: {e}\"))?;\n\n    match &tool.manifest.wasm_sha256 {\n        None => {\n            output::print_warning(&format!(\n                \"{}: no stored hash (installed before integrity support)\",\n                args.tool_id\n            ));\n        }\n        Some(expected) if expected == &actual_hash => {\n            output::print_success(&format!(\n                \"{}: OK (sha256={})\",\n                args.tool_id,\n                &actual_hash[..16]\n            ));\n        }\n        Some(expected) => {\n            anyhow::bail!(\n                \"{}: INTEGRITY VIOLATION\\n  expected: {}\\n  actual:   {}\",\n                args.tool_id,\n                expected,\n                actual_hash\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","input.rs"],"content":"//! Input resolution for CLI commands.\n//!\n//! Supports three input sources:\n//! - Inline JSON string via `--input` / `-i`\n//! - JSON file via `--input-file` / `-f`\n//! - Stdin via `--input-file -`\n\nuse std::io::Read;\nuse std::path::Path;\n\n/// Resolves the final JSON input string from CLI arguments.\n///\n/// Priority: `--input-file` takes precedence over `--input`.\n/// If `input_file` is `Some(\"-\")`, reads from stdin.\n/// If `input_file` is `Some(path)`, reads from that file.\n/// Otherwise, returns the `input` string as-is.\npub fn resolve_input(input: &str, input_file: Option<&str>) -> anyhow::Result<String> {\n    match input_file {\n        Some(\"-\") => read_from_stdin(),\n        Some(path) => read_from_file(path),\n        None => Ok(input.to_string()),\n    }\n}\n\n/// Reads JSON content from a file path.\nfn read_from_file(path: &str) -> anyhow::Result<String> {\n    let file_path = Path::new(path);\n    if !file_path.exists() {\n        anyhow::bail!(\"input file not found: {path}\");\n    }\n    let content = std::fs::read_to_string(file_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to read input file: {e}\"))?;\n    let trimmed = content.trim().to_string();\n    validate_json(&trimmed)?;\n    Ok(trimmed)\n}\n\n/// Reads JSON content from stdin.\nfn read_from_stdin() -> anyhow::Result<String> {\n    let mut buffer = String::new();\n    std::io::stdin()\n        .read_to_string(&mut buffer)\n        .map_err(|e| anyhow::anyhow!(\"failed to read stdin: {e}\"))?;\n    let trimmed = buffer.trim().to_string();\n    validate_json(&trimmed)?;\n    Ok(trimmed)\n}\n\n/// Validates that the input is valid JSON.\nfn validate_json(input: &str) -> anyhow::Result<()> {\n    serde_json::from_str::<serde_json::Value>(input)\n        .map_err(|e| anyhow::anyhow!(\"invalid JSON input: {e}\"))?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resolve_inline_input() {\n        let result = resolve_input(\"{\\\"key\\\":\\\"value\\\"}\", None);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"key\\\":\\\"value\\\"}\");\n    }\n\n    #[test]\n    fn resolve_from_file() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"input.json\");\n        std::fs::write(&file_path, r#\"{\"hello\": \"world\"}\"#).unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), r#\"{\"hello\": \"world\"}\"#);\n    }\n\n    #[test]\n    fn resolve_file_not_found() {\n        let result = resolve_input(\"{}\", Some(\"/nonexistent/file.json\"));\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"not found\"));\n    }\n\n    #[test]\n    fn resolve_invalid_json_in_file() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"bad.json\");\n        std::fs::write(&file_path, \"not valid json\").unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"invalid JSON\"));\n    }\n\n    #[test]\n    fn resolve_file_with_whitespace() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"spaced.json\");\n        std::fs::write(&file_path, \"  {\\\"a\\\": 1}  \\n\").unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"a\\\": 1}\");\n    }\n\n    #[test]\n    fn resolve_inline_fallback_when_no_file() {\n        let result = resolve_input(\"{\\\"default\\\":true}\", None);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"default\\\":true}\");\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":34,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":18,"coverable":26},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","main.rs"],"content":"//! KAMI CLI - Orchestrateur WASM/MCP.\n\nuse clap::{Parser, Subcommand};\nuse tracing_subscriber::fmt::format::FmtSpan;\n\nmod commands;\nmod input;\nmod output;\npub(crate) mod shared;\n\n/// KAMI - Secure WASM tool orchestrator for AI agents.\n#[derive(Debug, Parser)]\n#[command(name = \"kami\", version, about)]\nstruct Cli {\n    /// Configuration file path.\n    #[arg(short, long, global = true)]\n    config: Option<String>,\n\n    /// Verbosity level (-v, -vv, -vvv).\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    /// Log output format: plain (default) or json (for log aggregation).\n    #[arg(long, global = true, default_value = \"plain\", value_parser = [\"plain\", \"json\"])]\n    log_format: String,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Scaffold a new tool project.\n    Init(commands::init::InitArgs),\n    /// Validate a tool.toml manifest without installing.\n    Validate(commands::validate::ValidateArgs),\n    /// Install a WASM tool into the registry.\n    Install(commands::install::InstallArgs),\n    /// Uninstall a tool from the registry.\n    Uninstall(commands::uninstall::UninstallArgs),\n    /// Update a tool (or all) from their source directories.\n    Update(commands::update::UpdateArgs),\n    /// Pin a tool to a specific version (prevents update).\n    Pin(commands::pin::PinArgs),\n    /// List installed tools.\n    List(commands::list::ListArgs),\n    /// Inspect a tool's manifest.\n    Inspect(commands::inspect::InspectArgs),\n    /// Run a WASM component file directly (dev mode).\n    Run(commands::run::RunArgs),\n    /// Execute a registered tool by ID.\n    Exec(commands::exec::ExecArgs),\n    /// Start MCP server over stdio or HTTP.\n    Serve(commands::serve::ServeArgs),\n    /// Show runtime status and tool registry statistics.\n    Status(commands::status::StatusArgs),\n    /// Verify the integrity of an installed tool's WASM file.\n    Verify(commands::verify::VerifyArgs),\n    /// Developer experience commands (watch, etc.).\n    Dev(commands::dev::DevArgs),\n}\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let cli = Cli::parse();\n\n    // Initialize tracing.\n    let filter = match cli.verbose {\n        0 => \"info\",\n        1 => \"debug\",\n        _ => \"trace\",\n    };\n    match cli.log_format.as_str() {\n        \"json\" => tracing_subscriber::fmt()\n            .with_env_filter(filter)\n            .json()\n            .with_target(true)\n            .with_span_events(FmtSpan::CLOSE)\n            .init(),\n        _ => tracing_subscriber::fmt().with_env_filter(filter).init(),\n    };\n\n    tracing::debug!(\"KAMI starting with config: {:?}\", cli.config);\n\n    match &cli.command {\n        Commands::Init(args) => commands::init::execute(args),\n        Commands::Validate(args) => commands::validate::execute(args),\n        Commands::Install(args) => commands::install::execute(args).await,\n        Commands::Uninstall(args) => commands::uninstall::execute(args).await,\n        Commands::Update(args) => commands::update::execute(args).await,\n        Commands::Pin(args) => commands::pin::execute(args).await,\n        Commands::List(args) => commands::list::execute(args).await,\n        Commands::Inspect(args) => commands::inspect::execute(args).await,\n        Commands::Run(args) => commands::run::execute(args).await,\n        Commands::Exec(args) => commands::exec::execute(args).await,\n        Commands::Serve(args) => commands::serve::execute(args).await,\n        Commands::Status(args) => commands::status::execute(args).await,\n        Commands::Verify(args) => commands::verify::execute(args).await,\n        Commands::Dev(args) => commands::dev::execute(args).await,\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","output.rs"],"content":"//! Output formatting for CLI responses.\n\n/// Prints a success message.\npub fn print_success(message: &str) {\n    println!(\"[OK] {message}\");\n}\n\n/// Prints a warning message.\npub fn print_warning(message: &str) {\n    println!(\"[WARN] {message}\");\n}\n\n/// Prints an error message.\npub fn print_error(message: &str) {\n    eprintln!(\"[ERROR] {message}\");\n}\n\n/// Prints an informational message.\npub fn print_info(message: &str) {\n    println!(\"[INFO] {message}\");\n}\n\n/// Default database path for the tool registry.\npub fn default_db_path() -> String {\n    let home = std::env::var(\"KAMI_DATA_DIR\").unwrap_or_else(|_| \".kami\".to_string());\n    format!(\"{home}/registry.db\")\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":5,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":11},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","shared.rs"],"content":"//! Shared helpers used across CLI commands.\n//!\n//! Centralises the repetitive pattern of opening the SQLite registry\n//! and creating a `KamiRuntime`, ensuring consistent defaults everywhere.\n\nuse std::sync::Arc;\n\nuse kami_registry::ToolRepository;\nuse kami_runtime::{KamiRuntime, RuntimeConfig};\nuse kami_store_sqlite::SqliteToolRepository;\n\nuse crate::output;\n\n/// Opens the SQLite tool registry.\n///\n/// Uses `$KAMI_DATA_DIR/registry.db` or `.kami/registry.db` by default.\n///\n/// # Errors\n///\n/// Returns an error if the database file cannot be created or opened.\npub fn open_repository(db: &Option<String>) -> anyhow::Result<Arc<dyn ToolRepository>> {\n    let path = db.clone().unwrap_or_else(output::default_db_path);\n    if let Some(parent) = std::path::Path::new(&path).parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    let repo =\n        SqliteToolRepository::open(&path).map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?;\n    Ok(Arc::new(repo))\n}\n\n/// Creates a `KamiRuntime` with the given concurrency and cache settings.\n///\n/// # Errors\n///\n/// Returns an error if the runtime cannot be initialised.\npub fn create_runtime(\n    repo: Arc<dyn ToolRepository>,\n    concurrency: usize,\n    cache_size: usize,\n) -> anyhow::Result<KamiRuntime> {\n    let config = RuntimeConfig {\n        cache_size,\n        max_concurrent: concurrency,\n        epoch_interruption: true,\n    };\n    KamiRuntime::new(config, repo).map_err(|e| anyhow::anyhow!(\"runtime init error: {e}\"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn open_repository_in_memory_equivalent() {\n        // We test via SqliteToolRepository directly; shared helper tested\n        // indirectly through CLI command integration.\n        let repo = SqliteToolRepository::open_in_memory();\n        assert!(repo.is_ok());\n    }\n\n    #[test]\n    fn create_runtime_with_defaults() {\n        let repo = Arc::new(SqliteToolRepository::open_in_memory().expect(\"open\"));\n        let runtime = create_runtime(repo, 4, 32);\n        assert!(runtime.is_ok());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":2,"coverable":9},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","lib.rs"],"content":"//! # kami-config\n//!\n//! Configuration management for KAMI.\n//! Supports layered config: defaults -> file -> env vars.\n\npub mod loader;\npub mod manifest_loader;\npub mod schema;\n\npub use loader::{load_config, ConfigError};\npub use manifest_loader::{parse_tool_manifest, parse_tool_manifest_file, ManifestError};\npub use schema::KamiConfig;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","loader.rs"],"content":"//! Configuration loader (file + env + CLI merge).\n\nuse figment::providers::{Env, Format, Serialized, Toml};\nuse figment::Figment;\nuse thiserror::Error;\n\nuse crate::schema::KamiConfig;\n\n/// Errors from configuration loading.\n#[derive(Debug, Error)]\npub enum ConfigError {\n    /// Failed to load or merge configuration.\n    #[error(\"configuration error: {0}\")]\n    Load(String),\n}\n\n/// Loads configuration by merging layers:\n/// 1. Default values\n/// 2. Config file (if exists)\n/// 3. Environment variables (KAMI_ prefix)\npub fn load_config(config_path: Option<&str>) -> Result<KamiConfig, ConfigError> {\n    let mut figment = Figment::from(Serialized::defaults(KamiConfig::default()));\n\n    if let Some(path) = config_path {\n        figment = figment.merge(Toml::file(path));\n    }\n\n    figment = figment.merge(Env::prefixed(\"KAMI_\").split(\"_\"));\n\n    figment\n        .extract()\n        .map_err(|e| ConfigError::Load(e.to_string()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn load_config_no_path_succeeds() {\n        let config = load_config(None);\n        assert!(config.is_ok(), \"default config should load without error\");\n    }\n\n    #[test]\n    fn load_config_default_values() {\n        let config = load_config(None).expect(\"should load\");\n        assert_eq!(config.runtime.max_concurrent, 10);\n        assert_eq!(config.runtime.pool_size, 5);\n        assert_eq!(config.runtime.default_timeout_secs, 30);\n        assert_eq!(config.sandbox.default_max_memory_mb, 64);\n        assert_eq!(config.sandbox.default_max_fuel, 1_000_000);\n        assert_eq!(config.registry.database_path, \"kami.db\");\n        assert_eq!(config.logging.level, \"info\");\n    }\n\n    #[test]\n    fn load_config_nonexistent_file_falls_back_to_defaults() {\n        // figment::Toml::file ignores missing files (optional by default)\n        let config = load_config(Some(\"/nonexistent/path/kami.toml\"));\n        assert!(\n            config.is_ok(),\n            \"missing config file should fall back to defaults\"\n        );\n    }\n\n    #[test]\n    fn runtime_timeout_returns_duration() {\n        let config = load_config(None).expect(\"should load\");\n        assert_eq!(config.runtime.timeout().as_secs(), 30);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":24,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":7,"coverable":7},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","manifest_loader.rs"],"content":"//! Tool manifest loader — reads and parses `tool.toml` files.\n//!\n//! Lives in `kami-config` (Adapter layer) because it performs filesystem I/O.\n//! Pure string-to-manifest conversion is also here to keep `toml` out of the\n//! domain layer (`kami-types`).\n\nuse std::path::Path;\n\nuse kami_types::{SecurityConfig, ToolArgument, ToolId, ToolManifest, ToolVersion};\n\n/// Error type for manifest parsing failures.\n#[derive(Debug, thiserror::Error)]\npub enum ManifestError {\n    /// The file could not be read.\n    #[error(\"cannot read manifest at '{path}': {source}\")]\n    Io {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n    /// The TOML content is invalid or missing required fields.\n    #[error(\"invalid tool.toml: {0}\")]\n    Parse(String),\n}\n\n/// Parses a `tool.toml` string into a `ToolManifest`.\n///\n/// This is a pure transformation — no filesystem access.\n///\n/// # Errors\n///\n/// Returns `ManifestError::Parse` if the TOML is malformed or missing\n/// required sections.\npub fn parse_tool_manifest(content: &str) -> Result<ToolManifest, ManifestError> {\n    let raw: RawToolToml =\n        toml::from_str(content).map_err(|e| ManifestError::Parse(e.to_string()))?;\n\n    let id = ToolId::new(&raw.tool.id).map_err(|e| ManifestError::Parse(e.to_string()))?;\n\n    let version: ToolVersion = raw\n        .tool\n        .version\n        .parse()\n        .map_err(|e: kami_types::KamiError| ManifestError::Parse(e.to_string()))?;\n\n    Ok(ToolManifest {\n        id,\n        name: raw.tool.name,\n        version,\n        wasm: raw.tool.wasm,\n        description: raw.mcp.description,\n        arguments: raw.mcp.arguments,\n        security: raw.security,\n        // Populated at install time by hashing the WASM file on disk;\n        // not present in the tool.toml source file itself.\n        wasm_sha256: None,\n    })\n}\n\n/// Reads a `tool.toml` file from disk and parses it into a `ToolManifest`.\n///\n/// # Errors\n///\n/// Returns `ManifestError::Io` if the file cannot be read.\n/// Returns `ManifestError::Parse` if the content is invalid.\npub fn parse_tool_manifest_file(path: &Path) -> Result<ToolManifest, ManifestError> {\n    let content = std::fs::read_to_string(path).map_err(|e| ManifestError::Io {\n        path: path.display().to_string(),\n        source: e,\n    })?;\n    parse_tool_manifest(&content)\n}\n\n// ---------------------------------------------------------------------------\n// Private TOML deserialization types\n// ---------------------------------------------------------------------------\n\n/// Raw TOML structure mirroring the `tool.toml` file format.\n///\n/// `SecurityConfig` already derives `Deserialize` with `#[serde(flatten)]`\n/// on `ResourceLimits`, so it maps directly to the `[security]` section.\n#[derive(Debug, serde::Deserialize)]\nstruct RawToolToml {\n    tool: RawToolSection,\n    mcp: RawMcpSection,\n    #[serde(default)]\n    security: SecurityConfig,\n}\n\n/// `[tool]` section of tool.toml.\n#[derive(Debug, serde::Deserialize)]\nstruct RawToolSection {\n    id: String,\n    name: String,\n    version: String,\n    wasm: String,\n}\n\n/// `[mcp]` section of tool.toml.\n#[derive(Debug, serde::Deserialize)]\nstruct RawMcpSection {\n    description: String,\n    #[serde(default)]\n    arguments: Vec<ToolArgument>,\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":35,"address":[],"length":0,"stats":{"Line":720575940379279352}},{"line":36,"address":[],"length":0,"stats":{"Line":1513209474796486660}},{"line":38,"address":[],"length":0,"stats":{"Line":1585267068834414576}},{"line":40,"address":[],"length":0,"stats":{"Line":864691128455135211}},{"line":41,"address":[],"length":0,"stats":{"Line":288230376151711737}},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711737}},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711743}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711737}},{"line":47,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":48,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":49,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":50,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":51,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":52,"address":[],"length":0,"stats":{"Line":576460752303423474}},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711737}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711737}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":22},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","schema.rs"],"content":"//! Configuration schema types.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Top-level KAMI configuration.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\npub struct KamiConfig {\n    /// Runtime settings.\n    #[serde(default)]\n    pub runtime: RuntimeConfig,\n    /// Sandbox settings.\n    #[serde(default)]\n    pub sandbox: SandboxConfig,\n    /// Registry settings.\n    #[serde(default)]\n    pub registry: RegistryConfig,\n    /// Logging settings.\n    #[serde(default)]\n    pub logging: LoggingConfig,\n}\n\n/// Runtime configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RuntimeConfig {\n    /// Maximum concurrent tool executions.\n    #[serde(default = \"default_max_concurrent\")]\n    pub max_concurrent: usize,\n    /// Instance pool size.\n    #[serde(default = \"default_pool_size\")]\n    pub pool_size: usize,\n    /// Default execution timeout in seconds.\n    #[serde(default = \"default_timeout_secs\")]\n    pub default_timeout_secs: u64,\n}\n\nimpl RuntimeConfig {\n    /// Returns the timeout as a `Duration`.\n    pub fn timeout(&self) -> Duration {\n        Duration::from_secs(self.default_timeout_secs)\n    }\n}\n\nimpl Default for RuntimeConfig {\n    fn default() -> Self {\n        Self {\n            max_concurrent: default_max_concurrent(),\n            pool_size: default_pool_size(),\n            default_timeout_secs: default_timeout_secs(),\n        }\n    }\n}\n\nfn default_max_concurrent() -> usize {\n    10\n}\nfn default_pool_size() -> usize {\n    5\n}\nfn default_timeout_secs() -> u64 {\n    30\n}\n\n/// Sandbox default settings.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SandboxConfig {\n    /// Default maximum memory per tool (MB).\n    #[serde(default = \"default_max_memory\")]\n    pub default_max_memory_mb: u32,\n    /// Default maximum fuel per tool.\n    #[serde(default = \"default_max_fuel\")]\n    pub default_max_fuel: u64,\n}\n\nimpl Default for SandboxConfig {\n    fn default() -> Self {\n        Self {\n            default_max_memory_mb: default_max_memory(),\n            default_max_fuel: default_max_fuel(),\n        }\n    }\n}\n\nfn default_max_memory() -> u32 {\n    64\n}\nfn default_max_fuel() -> u64 {\n    1_000_000\n}\n\n/// Registry storage settings.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RegistryConfig {\n    /// Path to the SQLite database.\n    #[serde(default = \"default_db_path\")]\n    pub database_path: String,\n}\n\nimpl Default for RegistryConfig {\n    fn default() -> Self {\n        Self {\n            database_path: default_db_path(),\n        }\n    }\n}\n\nfn default_db_path() -> String {\n    \"kami.db\".to_string()\n}\n\n/// Logging configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    /// Log level filter (e.g. \"info\", \"debug\", \"kami=trace\").\n    #[serde(default = \"default_log_level\")]\n    pub level: String,\n}\n\nimpl Default for LoggingConfig {\n    fn default() -> Self {\n        Self {\n            level: default_log_level(),\n        }\n    }\n}\n\nfn default_log_level() -> String {\n    \"info\".to_string()\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":48,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":49,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":50,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":55,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":58,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":59,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":61,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":62,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":79,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":80,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":85,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":88,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":89,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":101,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":108,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":109,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":121,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":123,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":128,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":129,"address":[],"length":0,"stats":{"Line":1297036692682702848}}],"covered":27,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","bindings.rs"],"content":"//! Host-side bindings for the `kami-tool` WIT world.\r\n//!\r\n//! Uses `wasmtime::component::bindgen!` to generate typed accessors\r\n//! for tool exports and host import implementations.\r\n\r\nuse core::pin::Pin;\r\n\r\nuse wasmtime::component::{Component, Linker};\r\nuse wasmtime::{Engine, Store};\r\n\r\nuse crate::error::EngineError;\r\nuse crate::state::HostState;\r\n\r\nwasmtime::component::bindgen!({\r\n    world: \"kami-tool\",\r\n    path: \"../../wit\",\r\n    async: true,\r\n});\r\n\r\n/// Implements the `kami:tool/host` interface for guest→host calls.\r\nimpl kami::tool::host::Host for HostState {\r\n    fn log<'a, 'b>(\r\n        &'a mut self,\r\n        level: kami::tool::host::LogLevel,\r\n        message: String,\r\n    ) -> Pin<Box<dyn core::future::Future<Output = ()> + Send + 'b>>\r\n    where\r\n        Self: 'b,\r\n        'a: 'b,\r\n    {\r\n        Box::pin(async move {\r\n            use kami::tool::host::LogLevel;\r\n            match level {\r\n                LogLevel::Trace => tracing::trace!(target: \"kami_guest\", \"{message}\"),\r\n                LogLevel::Debug => tracing::debug!(target: \"kami_guest\", \"{message}\"),\r\n                LogLevel::Info => tracing::info!(target: \"kami_guest\", \"{message}\"),\r\n                LogLevel::Warn => tracing::warn!(target: \"kami_guest\", \"{message}\"),\r\n                LogLevel::Error => tracing::error!(target: \"kami_guest\", \"{message}\"),\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n/// Creates a linker with WASI + `kami:tool/host` interface bindings.\r\n///\r\n/// Supports both standard WASI calls and the custom host interface.\r\npub fn create_tool_linker(engine: &Engine) -> Result<Linker<HostState>, EngineError> {\r\n    let mut linker = Linker::new(engine);\r\n    wasmtime_wasi::add_to_linker_async(&mut linker)\r\n        .map_err(|e| EngineError::Config(format!(\"WASI linker: {e}\")))?;\r\n    KamiTool::add_to_linker(&mut linker, |state| state)\r\n        .map_err(|e| EngineError::Config(format!(\"host linker: {e}\")))?;\r\n    Ok(linker)\r\n}\r\n\r\n/// Instantiates a kami-tool component with typed bindings.\r\n///\r\n/// # Errors\r\n///\r\n/// Returns `EngineError::Instantiation` if the component doesn't match\r\n/// the `kami-tool` WIT world.\r\npub async fn instantiate_tool(\r\n    linker: &Linker<HostState>,\r\n    store: &mut Store<HostState>,\r\n    component: &Component,\r\n) -> Result<KamiTool, EngineError> {\r\n    KamiTool::instantiate_async(&mut *store, component, linker)\r\n        .await\r\n        .map_err(|e| EngineError::Instantiation {\r\n            reason: \"kami-tool component\".to_string(),\r\n            source: e,\r\n        })\r\n}\r\n\r\n/// Calls the `run` export on a kami-tool component via typed bindings.\r\n///\r\n/// # Errors\r\n///\r\n/// Returns `EngineError::Trap` if execution fails.\r\npub async fn call_run(\r\n    store: &mut Store<HostState>,\r\n    tool: &KamiTool,\r\n    input: &str,\r\n) -> Result<Result<String, String>, EngineError> {\r\n    tool.kami_tool_tool()\r\n        .call_run(&mut *store, input)\r\n        .await\r\n        .map_err(|e: wasmtime::Error| EngineError::Trap {\r\n            message: e.to_string(),\r\n        })\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":67,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":68,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":69,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":70,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":29},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","component.rs"],"content":"//! WebAssembly Component Model loading, linking, and execution.\n\nuse std::path::Path;\n\nuse wasmtime::component::{Component, Instance, Linker};\nuse wasmtime::{Engine, Store};\n\nuse crate::error::EngineError;\nuse crate::state::HostState;\n\n/// Loads a WASM component from raw bytes.\npub fn load_component(engine: &Engine, bytes: &[u8]) -> Result<Component, EngineError> {\n    Component::new(engine, bytes).map_err(|e| EngineError::Compilation {\n        reason: \"failed to load component from bytes\".to_string(),\n        source: e,\n    })\n}\n\n/// Loads a WASM component from a file path.\npub fn load_component_from_file(engine: &Engine, path: &Path) -> Result<Component, EngineError> {\n    Component::from_file(engine, path).map_err(|e| EngineError::Compilation {\n        reason: format!(\"failed to load component from {}\", path.display()),\n        source: e,\n    })\n}\n\n/// Creates a `Linker<HostState>` with WASI async bindings registered.\n///\n/// This linker is reusable across multiple instantiations.\npub fn create_linker(engine: &Engine) -> Result<Linker<HostState>, EngineError> {\n    let mut linker = Linker::new(engine);\n    wasmtime_wasi::add_to_linker_async(&mut linker)\n        .map_err(|e| EngineError::Config(format!(\"WASI linker: {e}\")))?;\n    crate::bindings::KamiTool::add_to_linker(&mut linker, |s| s)\n        .map_err(|e| EngineError::Config(format!(\"host linker: {e}\")))?;\n    Ok(linker)\n}\n\n/// Instantiates a component asynchronously.\npub async fn instantiate_component(\n    linker: &Linker<HostState>,\n    store: &mut Store<HostState>,\n    component: &Component,\n) -> Result<Instance, EngineError> {\n    linker\n        .instantiate_async(store, component)\n        .await\n        .map_err(|e| EngineError::Instantiation {\n            reason: \"failed to instantiate component\".to_string(),\n            source: e,\n        })\n}\n\n/// Calls an exported `run(input: string) -> result<string, string>` function.\n///\n/// This is the standard KAMI tool interface: takes JSON input, returns JSON output.\npub async fn call_tool_run(\n    store: &mut Store<HostState>,\n    instance: &Instance,\n    input: &str,\n) -> Result<Result<String, String>, EngineError> {\n    let run_func = instance\n        .get_typed_func::<(String,), (Result<String, String>,)>(&mut *store, \"run\")\n        .map_err(|_| EngineError::ExportNotFound {\n            name: \"run\".to_string(),\n        })?;\n\n    let (result,) = run_func\n        .call_async(&mut *store, (input.to_string(),))\n        .await\n        .map_err(|e| EngineError::Trap {\n            message: e.to_string(),\n        })?;\n\n    run_func\n        .post_return_async(&mut *store)\n        .await\n        .map_err(|e| EngineError::Trap {\n            message: format!(\"post_return failed: {e}\"),\n        })?;\n\n    Ok(result)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":13,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":31,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":32,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":33,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":34,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":35,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":36,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":40,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":46,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":62,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":63,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":64,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":69,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":70,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":71,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":76,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":78,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":29,"coverable":38},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","error.rs"],"content":"//! Engine-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the WASM engine.\n#[derive(Debug, Error)]\npub enum EngineError {\n    /// Failed to compile a WASM component.\n    #[error(\"failed to compile WASM component: {reason}\")]\n    Compilation {\n        reason: String,\n        #[source]\n        source: wasmtime::Error,\n    },\n    /// Failed to instantiate a component.\n    #[error(\"failed to instantiate component: {reason}\")]\n    Instantiation {\n        reason: String,\n        #[source]\n        source: wasmtime::Error,\n    },\n    /// WASM instance trapped during execution.\n    #[error(\"instance trapped: {message}\")]\n    Trap { message: String },\n    /// Exported function not found.\n    #[error(\"export not found: {name}\")]\n    ExportNotFound { name: String },\n    /// Resource limit exceeded.\n    #[error(\"resource limit exceeded: {limit}\")]\n    ResourceExceeded { limit: String },\n    /// Configuration error.\n    #[error(\"engine configuration error: {0}\")]\n    Config(String),\n}\n\nimpl From<EngineError> for KamiError {\n    fn from(e: EngineError) -> Self {\n        let kind = match &e {\n            EngineError::ResourceExceeded { .. } => ErrorKind::ResourceExhausted,\n            EngineError::ExportNotFound { .. } => ErrorKind::NotFound,\n            _ => ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for EngineError {\n    fn hint(&self) -> Option<String> {\n        match self {\n            Self::Compilation { reason, .. } => {\n                if reason.contains(\"unknown import\") {\n                    Some(\n                        \"The WASM component imports an interface that KAMI does not provide.\"\n                            .into(),\n                    )\n                } else {\n                    Some(\"The WASM binary could not be compiled by the engine.\".into())\n                }\n            }\n            Self::ExportNotFound { name } => Some(format!(\n                \"The component does not export '{name}'. It must export 'run' and 'describe'.\"\n            )),\n            Self::ResourceExceeded { .. } => {\n                Some(\"The component exceeded its allocated resource budget.\".into())\n            }\n            Self::Trap { .. } => Some(\"The WASM instance trapped during execution.\".into()),\n            _ => None,\n        }\n    }\n\n    fn fix(&self) -> Option<String> {\n        match self {\n            Self::Compilation { reason, .. } if reason.contains(\"unknown import\") => Some(\n                \"Check that your tool.toml [security] section grants the required capabilities.\\n\\\n                 Example: net_allow_list = [\\\"api.example.com\\\"]\"\n                    .into(),\n            ),\n            Self::ExportNotFound { .. } => Some(\n                \"Use the kami_tool! macro from kami-guest to generate the required exports.\".into(),\n            ),\n            Self::ResourceExceeded { limit } => Some(format!(\n                \"Increase the limit in tool.toml:\\n  [security]\\n  {limit}\"\n            )),\n            _ => None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resource_exceeded_maps_to_exhausted() {\n        let err: KamiError = EngineError::ResourceExceeded {\n            limit: \"memory\".into(),\n        }\n        .into();\n        assert_eq!(err.kind, ErrorKind::ResourceExhausted);\n    }\n\n    #[test]\n    fn export_not_found_maps_to_not_found() {\n        let err: KamiError = EngineError::ExportNotFound { name: \"run\".into() }.into();\n        assert_eq!(err.kind, ErrorKind::NotFound);\n    }\n\n    #[test]\n    fn compilation_hint_mentions_unknown_import() {\n        let e = EngineError::Compilation {\n            reason: \"unknown import: wasi:http\".into(),\n            source: wasmtime::Error::msg(\"test\"),\n        };\n        let hint = e.hint().expect(\"should have hint\");\n        assert!(hint.contains(\"does not provide\"));\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":49,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":65,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":27,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","instance.rs"],"content":"//! WASM Component instance lifecycle management.\n\nuse wasmtime::{Config, Engine, Store};\n\nuse crate::error::EngineError;\nuse crate::state::HostState;\n\n/// Configuration for creating WASM instances.\n#[derive(Debug, Clone)]\npub struct InstanceConfig {\n    /// Maximum memory in bytes per linear memory.\n    pub max_memory_bytes: u64,\n    /// Fuel limit for execution.\n    pub max_fuel: u64,\n    /// Enable async support (required for tokio).\n    pub async_support: bool,\n    /// Enable epoch-based interruption for timeout enforcement.\n    pub epoch_interruption: bool,\n}\n\nimpl Default for InstanceConfig {\n    fn default() -> Self {\n        Self {\n            max_memory_bytes: 64 * 1024 * 1024, // 64 MB\n            max_fuel: 1_000_000,\n            async_support: true,\n            epoch_interruption: false,\n        }\n    }\n}\n\n/// Creates a Wasmtime `Engine` configured for KAMI.\n///\n/// The engine is reusable across all component compilations and\n/// should be created once at startup. Enables fuel metering,\n/// Component Model, and epoch interruption.\npub fn create_engine(config: &InstanceConfig) -> Result<Engine, EngineError> {\n    let mut wasm_config = Config::new();\n    wasm_config.async_support(config.async_support);\n    wasm_config.consume_fuel(true);\n    wasm_config.wasm_component_model(true);\n    if config.epoch_interruption {\n        wasm_config.epoch_interruption(true);\n    }\n\n    Engine::new(&wasm_config).map_err(|e| EngineError::Config(e.to_string()))\n}\n\n/// Creates a new `Store<HostState>` with fuel metering and resource limits.\n///\n/// Connects `StoreLimits` from `HostState` via `store.limiter()` and sets\n/// the fuel budget for instruction-level metering.\npub fn create_store(\n    engine: &Engine,\n    host_state: HostState,\n    fuel: u64,\n) -> Result<Store<HostState>, EngineError> {\n    let mut store = Store::new(engine, host_state);\n\n    // Connect resource limiter (memory, tables)\n    store.limiter(|state| &mut state.store_limits);\n\n    // Set fuel budget\n    store\n        .set_fuel(fuel)\n        .map_err(|e| EngineError::Config(e.to_string()))?;\n\n    Ok(store)\n}\n\n/// Sets an epoch deadline on a store for timeout enforcement.\n///\n/// The store will trap when the engine's epoch counter exceeds\n/// `ticks_beyond_current`. Use `Engine::increment_epoch()` from\n/// a separate tokio task to trigger the deadline after a timeout.\npub fn set_epoch_deadline(store: &mut Store<HostState>, ticks: u64) {\n    store.epoch_deadline_trap();\n    store.set_epoch_deadline(ticks);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wasmtime_wasi::WasiCtxBuilder;\n\n    #[test]\n    fn create_engine_with_defaults() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(&config);\n        assert!(engine.is_ok());\n    }\n\n    #[test]\n    fn create_store_with_fuel() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(&config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        let store = create_store(&engine, state, 500_000);\n        assert!(store.is_ok());\n    }\n\n    #[test]\n    fn store_with_memory_limits() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(&config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::with_limits(ctx, 16 * 1024 * 1024);\n        let store = create_store(&engine, state, 500_000);\n        assert!(store.is_ok());\n    }\n\n    #[test]\n    fn epoch_deadline_can_be_set() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(&config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        let mut store = create_store(&engine, state, 500_000).expect(\"store creation\");\n        set_epoch_deadline(&mut store, 1);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":37,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":38,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":39,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":40,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":41,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":42,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":43,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":46,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":53,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":58,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":61,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":64,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":65,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":66,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":68,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":78,"address":[],"length":0,"stats":{"Line":1297036692682702848}}],"covered":20,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","lib.rs"],"content":"//! # kami-engine\n//!\n//! WASM engine powered by Wasmtime with Component Model support.\n//! Handles component compilation, instance creation, WASI linking,\n//! and async execution.\n\npub mod bindings;\npub mod component;\npub mod error;\npub mod instance;\npub mod linker;\npub mod memory;\npub mod state;\n\npub use bindings::{create_tool_linker, instantiate_tool, KamiTool};\npub use component::{\n    call_tool_run, create_linker, instantiate_component, load_component, load_component_from_file,\n};\npub use error::EngineError;\npub use instance::{create_engine, create_store, set_epoch_deadline, InstanceConfig};\npub use memory::MemoryStats;\npub use state::HostState;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","linker.rs"],"content":"//! Host function linking for WASM Component instances.\n//!\n//! Custom host functions beyond WASI will be registered here\n//! in future phases (logging, capability checks, metrics, etc.).\n\npub use crate::component::create_linker;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","memory.rs"],"content":"//! Memory management and limits for WASM instances.\n\n/// Memory usage statistics for a WASM instance.\n#[derive(Debug, Clone, Default)]\npub struct MemoryStats {\n    /// Current memory usage in bytes.\n    pub current_bytes: u64,\n    /// Peak memory usage in bytes.\n    pub peak_bytes: u64,\n    /// Memory limit in bytes.\n    pub limit_bytes: u64,\n}\n\nimpl MemoryStats {\n    /// Returns the usage as a percentage of the limit.\n    pub fn usage_percent(&self) -> f64 {\n        if self.limit_bytes == 0 {\n            return 0.0;\n        }\n        (self.current_bytes as f64 / self.limit_bytes as f64) * 100.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn usage_percent_zero_limit_returns_zero() {\n        let stats = MemoryStats {\n            current_bytes: 1024,\n            peak_bytes: 2048,\n            limit_bytes: 0,\n        };\n        assert!((stats.usage_percent() - 0.0).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn usage_percent_computes_correctly() {\n        let stats = MemoryStats {\n            current_bytes: 50,\n            peak_bytes: 75,\n            limit_bytes: 100,\n        };\n        assert!((stats.usage_percent() - 50.0).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn default_stats_are_zeroed() {\n        let stats = MemoryStats::default();\n        assert_eq!(stats.current_bytes, 0);\n        assert_eq!(stats.limit_bytes, 0);\n        assert!((stats.usage_percent() - 0.0).abs() < f64::EPSILON);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":4,"coverable":4},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","state.rs"],"content":"//! Host state for WASM component instances.\n//!\n//! `HostState` is the `T` in `Store<T>` and must implement `WasiView`.\n//! It holds the WASI context, resource table, store limits, and\n//! per-instance metadata.\n\nuse wasmtime::component::ResourceTable;\nuse wasmtime::{StoreLimits, StoreLimitsBuilder};\nuse wasmtime_wasi::{WasiCtx, WasiView};\n\n/// Per-instance host state passed to `Store<HostState>`.\n///\n/// Contains the `StoreLimits` so that `Store::limiter()` can reference it.\n/// Extensible: future phases will add fields for capability tracking,\n/// metrics, and host function state.\npub struct HostState {\n    /// WASI context controlling I/O permissions.\n    wasi_ctx: WasiCtx,\n    /// Resource table for Component Model resources.\n    resource_table: ResourceTable,\n    /// Wasmtime resource limiter (memory, tables, instances).\n    pub(crate) store_limits: StoreLimits,\n    /// Fuel consumed so far (for reporting).\n    fuel_consumed: u64,\n}\n\nimpl HostState {\n    /// Creates a new host state from a pre-built `WasiCtx` with default\n    /// resource limits (no memory cap).\n    pub fn new(wasi_ctx: WasiCtx) -> Self {\n        Self {\n            wasi_ctx,\n            resource_table: ResourceTable::new(),\n            store_limits: StoreLimitsBuilder::new().build(),\n            fuel_consumed: 0,\n        }\n    }\n\n    /// Creates a new host state with explicit memory limits.\n    ///\n    /// `max_memory_bytes` caps each linear memory allocation.\n    pub fn with_limits(wasi_ctx: WasiCtx, max_memory_bytes: usize) -> Self {\n        let store_limits = StoreLimitsBuilder::new()\n            .memory_size(max_memory_bytes)\n            .trap_on_grow_failure(true)\n            .build();\n        Self {\n            wasi_ctx,\n            resource_table: ResourceTable::new(),\n            store_limits,\n            fuel_consumed: 0,\n        }\n    }\n\n    /// Returns fuel consumed so far.\n    pub fn fuel_consumed(&self) -> u64 {\n        self.fuel_consumed\n    }\n\n    /// Records fuel consumption.\n    pub fn record_fuel(&mut self, consumed: u64) {\n        self.fuel_consumed = consumed;\n    }\n}\n\nimpl WasiView for HostState {\n    fn ctx(&mut self) -> &mut WasiCtx {\n        &mut self.wasi_ctx\n    }\n\n    fn table(&mut self) -> &mut ResourceTable {\n        &mut self.resource_table\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wasmtime_wasi::WasiCtxBuilder;\n\n    #[test]\n    fn host_state_creation() {\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        assert_eq!(state.fuel_consumed(), 0);\n    }\n\n    #[test]\n    fn host_state_with_memory_limits() {\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::with_limits(ctx, 32 * 1024 * 1024);\n        assert_eq!(state.fuel_consumed(), 0);\n    }\n\n    #[test]\n    fn record_fuel_updates_consumed() {\n        let ctx = WasiCtxBuilder::new().build();\n        let mut state = HostState::new(ctx);\n        state.record_fuel(500);\n        assert_eq!(state.fuel_consumed(), 500);\n        state.record_fuel(1000);\n        assert_eq!(state.fuel_consumed(), 1000);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":33,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":34,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":42,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":43,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":44,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":49,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","abi.rs"],"content":"//! ABI helpers for guest WASM modules.\n//!\n//! Provides the low-level interface between guest tool code and the\n//! KAMI host. Guest tools use these helpers to parse input, build\n//! results, and interact with host functions.\n\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\n/// Parses JSON input string into a typed struct.\n///\n/// Returns `Err(String)` with a human-readable message on failure.\n///\n/// # Example\n/// ```ignore\n/// #[derive(serde::Deserialize)]\n/// struct MyInput { url: String }\n///\n/// let input: MyInput = kami_guest::abi::parse_input(raw_json)?;\n/// ```\npub fn parse_input<T: DeserializeOwned>(input: &str) -> Result<T, String> {\n    serde_json::from_str(input).map_err(|e| format!(\"invalid input: {e}\"))\n}\n\n/// Serializes a value into a JSON result string.\n///\n/// Returns `Err(String)` if serialization fails.\npub fn to_output<T: Serialize>(value: &T) -> Result<String, String> {\n    serde_json::to_string(value).map_err(|e| format!(\"serialization error: {e}\"))\n}\n\n/// Builds a simple text result.\npub fn text_result(text: &str) -> Result<String, String> {\n    Ok(serde_json::json!({ \"text\": text }).to_string())\n}\n\n/// Builds an error result.\npub fn error_result(message: &str) -> String {\n    serde_json::json!({ \"error\": message }).to_string()\n}\n\n/// Tool metadata for the `describe` export.\n#[derive(Debug, Clone, Serialize)]\npub struct ToolMetadata {\n    /// Tool name.\n    pub name: String,\n    /// Tool description.\n    pub description: String,\n    /// Tool version.\n    pub version: String,\n}\n\nimpl ToolMetadata {\n    /// Serializes metadata to JSON for the `describe` ABI call.\n    pub fn to_json(&self) -> String {\n        serde_json::to_string(self).unwrap_or_else(|_| \"{}\".to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::Deserialize;\n\n    #[derive(Debug, Deserialize, PartialEq)]\n    struct TestInput {\n        url: String,\n        count: u32,\n    }\n\n    #[test]\n    fn parse_valid_input() {\n        let json = r#\"{\"url\":\"https://example.com\",\"count\":5}\"#;\n        let input: TestInput = parse_input(json).expect(\"parse\");\n        assert_eq!(input.url, \"https://example.com\");\n        assert_eq!(input.count, 5);\n    }\n\n    #[test]\n    fn parse_invalid_input_returns_error() {\n        let result = parse_input::<TestInput>(\"not json\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"invalid input\"));\n    }\n\n    #[test]\n    fn to_output_serializes() {\n        let data = serde_json::json!({\"result\": 42});\n        let json = to_output(&data).expect(\"serialize\");\n        assert!(json.contains(\"42\"));\n    }\n\n    #[test]\n    fn text_result_wraps_string() {\n        let result = text_result(\"hello\").expect(\"ok\");\n        let parsed: serde_json::Value = serde_json::from_str(&result).expect(\"parse\");\n        assert_eq!(parsed[\"text\"], \"hello\");\n    }\n\n    #[test]\n    fn error_result_wraps_message() {\n        let result = error_result(\"something failed\");\n        let parsed: serde_json::Value = serde_json::from_str(&result).expect(\"parse\");\n        assert_eq!(parsed[\"error\"], \"something failed\");\n    }\n\n    #[test]\n    fn tool_metadata_to_json() {\n        let meta = ToolMetadata {\n            name: \"test-tool\".to_string(),\n            description: \"A test\".to_string(),\n            version: \"1.0.0\".to_string(),\n        };\n        let json = meta.to_json();\n        assert!(json.contains(\"test-tool\"));\n        assert!(json.contains(\"1.0.0\"));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":22,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":10,"coverable":10},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","bindings.rs"],"content":"//! Auto-generated Component Model bindings from WIT interfaces.\r\n//!\r\n//! Gated behind the `component-model` feature flag. When enabled,\r\n//! `wit-bindgen` generates the `Guest` trait and host import functions\r\n//! from the WIT definitions in `wit/`.\r\n//!\r\n//! # For Tool Authors\r\n//!\r\n//! To build a real WASM component (not just a test binary):\r\n//!\r\n//! ```toml\r\n//! # your-tool/Cargo.toml\r\n//! [dependencies]\r\n//! kami-guest = { path = \"../../crates/kami-guest\", features = [\"component-model\"] }\r\n//! ```\r\n//!\r\n//! ```ignore\r\n//! // your-tool/src/lib.rs\r\n//! use kami_guest::bindings;\r\n//!\r\n//! struct MyTool;\r\n//!\r\n//! impl bindings::Guest for MyTool {\r\n//!     fn run(input: String) -> Result<String, String> {\r\n//!         // your logic\r\n//!         Ok(format!(\"result: {input}\"))\r\n//!     }\r\n//!     fn describe() -> String {\r\n//!         r#\"{\"name\":\"my-tool\",\"version\":\"1.0.0\"}\"#.into()\r\n//!     }\r\n//! }\r\n//!\r\n//! bindings::export!(MyTool with_types_in bindings);\r\n//! ```\r\n//!\r\n//! Build with: `cargo build --target wasm32-wasip2 --release`\r\n//!\r\n//! # Native Testing\r\n//!\r\n//! For native tests (no WASM), use `kami_tool!` macro instead:\r\n//!\r\n//! ```ignore\r\n//! kami_guest::kami_tool! {\r\n//!     name: \"my-tool\",\r\n//!     version: \"1.0.0\",\r\n//!     description: \"My tool\",\r\n//!     handler: my_handler,\r\n//! }\r\n//! ```\r\n\r\n#[cfg(feature = \"component-model\")]\r\nwit_bindgen::generate!({\r\n    world: \"kami-tool\",\r\n    path: \"../../wit\",\r\n});\r\n\r\n#[cfg(feature = \"component-model\")]\r\npub use exports::kami::tool::tool::Guest;\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","lib.rs"],"content":"//! # kami-guest\n//!\n//! SDK for building WASM tools that run inside KAMI.\n//!\n//! This crate provides:\n//! - **ABI helpers**: Parse input, serialize output, build results\n//! - **`kami_tool!` macro**: Generate Component Model exports from a handler function\n//!\n//! # Quick Start\n//!\n//! ```ignore\n//! use kami_guest::kami_tool;\n//!\n//! kami_tool! {\n//!     name: \"dev.example.echo\",\n//!     version: \"1.0.0\",\n//!     description: \"Echoes back the input\",\n//!     handler: handle,\n//! }\n//!\n//! fn handle(input: &str) -> Result<String, String> {\n//!     Ok(format!(\"echo: {input}\"))\n//! }\n//! ```\n\npub mod abi;\npub mod macros;\n\n#[cfg(feature = \"component-model\")]\npub mod bindings;\n\npub use abi::{error_result, parse_input, text_result, to_output, ToolMetadata};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","macros.rs"],"content":"//! Declarative macros for KAMI guest tools.\n//!\n//! Provides `kami_tool!` to generate the handler wiring and metadata\n//! for tools targeting the KAMI runtime.\n//!\n//! Two compilation modes are supported:\n//! - **Native** (default): generates test-friendly `__kami_run` / `__kami_describe`\n//! - **Component Model** (`component-model` feature + wasm32 target):\n//!   additionally generates `impl Guest` + `export!()` from WIT bindings\n\n/// Generates the KAMI tool entry points from a handler function.\n///\n/// This macro creates:\n/// - A `__kami_run` function that delegates to your handler\n/// - A `__kami_describe` function that returns tool metadata JSON\n///\n/// When the `component-model` feature is active and targeting wasm32,\n/// it also generates the Component Model `impl Guest` and `export!` glue\n/// from the WIT interface definitions.\n///\n/// # Usage\n///\n/// ```ignore\n/// use kami_guest::kami_tool;\n///\n/// kami_tool! {\n///     name: \"dev.example.my-tool\",\n///     version: \"1.0.0\",\n///     description: \"Does something useful\",\n///     handler: my_handler,\n/// }\n///\n/// fn my_handler(input: &str) -> Result<String, String> {\n///     let args: serde_json::Value = serde_json::from_str(input)\n///         .map_err(|e| e.to_string())?;\n///     Ok(format!(\"processed: {}\", args))\n/// }\n/// ```\n#[macro_export]\nmacro_rules! kami_tool {\n    (\n        name: $name:expr,\n        version: $version:expr,\n        description: $desc:expr,\n        handler: $handler:ident $(,)?\n    ) => {\n        /// Entry point: execute the tool with JSON input.\n        pub fn __kami_run(input: &str) -> Result<String, String> {\n            $handler(input)\n        }\n\n        /// Entry point: return tool metadata as JSON.\n        pub fn __kami_describe() -> String {\n            let meta = $crate::abi::ToolMetadata {\n                name: $name.to_string(),\n                description: $desc.to_string(),\n                version: $version.to_string(),\n            };\n            meta.to_json()\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    fn sample_handler(input: &str) -> Result<String, String> {\n        Ok(format!(\"echo: {input}\"))\n    }\n\n    kami_tool! {\n        name: \"dev.test.sample\",\n        version: \"0.1.0\",\n        description: \"Test tool\",\n        handler: sample_handler,\n    }\n\n    #[test]\n    fn macro_generates_run() {\n        let result = __kami_run(\"hello\");\n        assert_eq!(result, Ok(\"echo: hello\".to_string()));\n    }\n\n    #[test]\n    fn macro_generates_describe() {\n        let json = __kami_describe();\n        assert!(json.contains(\"dev.test.sample\"));\n        assert!(json.contains(\"0.1.0\"));\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","jsonrpc.rs"],"content":"//! JSON-RPC 2.0 types for MCP transport.\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// JSON-RPC 2.0 request.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcRequest {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID.\n    pub id: RequestId,\n    /// Method name.\n    pub method: String,\n    /// Optional parameters.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub params: Option<Value>,\n}\n\n/// JSON-RPC 2.0 success response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcResponse {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID (matches the request).\n    pub id: RequestId,\n    /// Result value.\n    pub result: Value,\n}\n\n/// JSON-RPC 2.0 error response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcErrorResponse {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID (matches the request).\n    pub id: RequestId,\n    /// Error details.\n    pub error: JsonRpcError,\n}\n\n/// JSON-RPC 2.0 error object.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcError {\n    /// Error code.\n    pub code: i32,\n    /// Human-readable message.\n    pub message: String,\n    /// Optional structured data.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub data: Option<Value>,\n}\n\n/// Request ID can be a number or string.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RequestId {\n    /// Numeric ID.\n    Number(i64),\n    /// String ID.\n    String(String),\n}\n\n/// JSON-RPC 2.0 notification (no id).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcNotification {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Method name.\n    pub method: String,\n    /// Optional parameters.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub params: Option<Value>,\n}\n\n/// Standard JSON-RPC error codes.\npub mod error_codes {\n    /// Invalid JSON was received.\n    pub const PARSE_ERROR: i32 = -32700;\n    /// The JSON sent is not a valid Request object.\n    pub const INVALID_REQUEST: i32 = -32600;\n    /// The method does not exist.\n    pub const METHOD_NOT_FOUND: i32 = -32601;\n    /// Invalid method parameter(s).\n    pub const INVALID_PARAMS: i32 = -32602;\n    /// Internal JSON-RPC error.\n    pub const INTERNAL_ERROR: i32 = -32603;\n}\n\nimpl JsonRpcRequest {\n    /// Creates a new JSON-RPC 2.0 request.\n    pub fn new(id: RequestId, method: impl Into<String>, params: Option<Value>) -> Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            method: method.into(),\n            params,\n        }\n    }\n}\n\nimpl JsonRpcResponse {\n    /// Creates a success response.\n    pub fn success(id: RequestId, result: Value) -> Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            result,\n        }\n    }\n}\n\nimpl JsonRpcErrorResponse {\n    /// Creates an error response.\n    pub fn error(id: RequestId, code: i32, message: impl Into<String>) -> Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            error: JsonRpcError {\n                code,\n                message: message.into(),\n                data: None,\n            },\n        }\n    }\n}\n","traces":[{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":96,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":104,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":106,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":115,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":117,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":119,"address":[],"length":0,"stats":{"Line":504403158265495552}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","lib.rs"],"content":"//! # kami-protocol\n//!\n//! MCP protocol and JSON-RPC 2.0 type definitions.\n//! This crate defines the wire format for communication between\n//! AI agents and the KAMI orchestrator.\n\npub mod jsonrpc;\npub mod mcp;\npub mod schema;\n\npub use jsonrpc::*;\npub use mcp::methods;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","initialize.rs"],"content":"//! MCP initialize method types.\n//!\n//! The initialize handshake is the first message exchanged between\n//! client and server to negotiate capabilities and protocol version.\n\nuse serde::{Deserialize, Serialize};\n\n/// Client capabilities declared during initialization.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ClientCapabilities {\n    /// Whether the client supports tool execution.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option<ToolCapability>,\n}\n\n/// Tool-related capability.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolCapability {}\n\n/// Server capabilities returned during initialization.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ServerCapabilities {\n    /// Tools capability (present if server exposes tools).\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option<ToolCapability>,\n}\n\n/// Client info sent during initialization.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClientInfo {\n    /// Client name.\n    pub name: String,\n    /// Client version.\n    pub version: String,\n}\n\n/// Server info returned during initialization.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerInfo {\n    /// Server name.\n    pub name: String,\n    /// Server version.\n    pub version: String,\n}\n\n/// Request params for `initialize`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InitializeParams {\n    /// Protocol version requested by client.\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    /// Client capabilities.\n    pub capabilities: ClientCapabilities,\n    /// Client info.\n    #[serde(rename = \"clientInfo\")]\n    pub client_info: ClientInfo,\n}\n\n/// Response for `initialize`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InitializeResult {\n    /// Protocol version agreed by server.\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    /// Server capabilities.\n    pub capabilities: ServerCapabilities,\n    /// Server info.\n    #[serde(rename = \"serverInfo\")]\n    pub server_info: ServerInfo,\n}\n\n/// MCP protocol version supported by this implementation.\npub const PROTOCOL_VERSION: &str = \"2024-11-05\";\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn initialize_params_roundtrip() {\n        let params = InitializeParams {\n            protocol_version: PROTOCOL_VERSION.to_string(),\n            capabilities: ClientCapabilities {\n                tools: Some(ToolCapability {}),\n            },\n            client_info: ClientInfo {\n                name: \"test-client\".to_string(),\n                version: \"1.0.0\".to_string(),\n            },\n        };\n        let json = serde_json::to_string(&params).expect(\"serialize\");\n        let back: InitializeParams = serde_json::from_str(&json).expect(\"deserialize\");\n        assert_eq!(back.protocol_version, PROTOCOL_VERSION);\n        assert_eq!(back.client_info.name, \"test-client\");\n    }\n\n    #[test]\n    fn initialize_result_roundtrip() {\n        let result = InitializeResult {\n            protocol_version: PROTOCOL_VERSION.to_string(),\n            capabilities: ServerCapabilities {\n                tools: Some(ToolCapability {}),\n            },\n            server_info: ServerInfo {\n                name: \"kami\".to_string(),\n                version: \"0.1.0\".to_string(),\n            },\n        };\n        let json = serde_json::to_string(&result).expect(\"serialize\");\n        let back: InitializeResult = serde_json::from_str(&json).expect(\"deserialize\");\n        assert_eq!(back.server_info.name, \"kami\");\n    }\n\n    #[test]\n    fn client_capabilities_default_has_no_tools() {\n        let caps = ClientCapabilities::default();\n        assert!(caps.tools.is_none());\n    }\n\n    #[test]\n    fn server_capabilities_empty_roundtrip() {\n        let caps = ServerCapabilities::default();\n        let json = serde_json::to_string(&caps).expect(\"ser\");\n        let back: ServerCapabilities = serde_json::from_str(&json).expect(\"de\");\n        assert!(back.tools.is_none());\n    }\n\n    #[test]\n    fn protocol_version_constant() {\n        assert_eq!(PROTOCOL_VERSION, \"2024-11-05\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","mod.rs"],"content":"//! MCP (Model Context Protocol) type definitions.\n\npub mod initialize;\npub mod prompts;\npub mod resources;\npub mod tools;\n\npub use initialize::*;\npub use prompts::*;\npub use resources::*;\npub use tools::*;\n\n/// MCP protocol method names.\npub mod methods {\n    /// Handshake request.\n    pub const INITIALIZE: &str = \"initialize\";\n    /// Client notification after successful initialization.\n    pub const NOTIFICATIONS_INITIALIZED: &str = \"notifications/initialized\";\n    /// List available tools.\n    pub const TOOLS_LIST: &str = \"tools/list\";\n    /// Execute a tool.\n    pub const TOOLS_CALL: &str = \"tools/call\";\n    /// List available prompts.\n    pub const PROMPTS_LIST: &str = \"prompts/list\";\n    /// List available resources.\n    pub const RESOURCES_LIST: &str = \"resources/list\";\n    /// Read a resource.\n    pub const RESOURCES_READ: &str = \"resources/read\";\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","prompts.rs"],"content":"//! MCP prompts/* method types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Request params for `prompts/list`.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct PromptsListParams {\n    /// Optional cursor for pagination.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub cursor: Option<String>,\n}\n\n/// A prompt definition.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpPromptDefinition {\n    /// Prompt name.\n    pub name: String,\n    /// Prompt description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n}\n\n/// Response for `prompts/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PromptsListResult {\n    /// Available prompts.\n    pub prompts: Vec<McpPromptDefinition>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn prompts_list_params_default() {\n        let p = PromptsListParams::default();\n        assert!(p.cursor.is_none());\n    }\n\n    #[test]\n    fn prompt_definition_serde_roundtrip() {\n        let def = McpPromptDefinition {\n            name: \"summarize\".into(),\n            description: Some(\"Summarize text\".into()),\n        };\n        let s = serde_json::to_string(&def).expect(\"ser\");\n        let back: McpPromptDefinition = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.name, \"summarize\");\n        assert!(back.description.is_some());\n    }\n\n    #[test]\n    fn prompts_list_result_roundtrip() {\n        let r = PromptsListResult {\n            prompts: vec![McpPromptDefinition {\n                name: \"p\".into(),\n                description: None,\n            }],\n        };\n        let s = serde_json::to_string(&r).expect(\"ser\");\n        let back: PromptsListResult = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.prompts.len(), 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","resources.rs"],"content":"//! MCP resources/* method types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Request params for `resources/read`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourcesReadParams {\n    /// URI of the resource to read.\n    pub uri: String,\n}\n\n/// A resource definition.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpResourceDefinition {\n    /// Resource URI.\n    pub uri: String,\n    /// Resource name.\n    pub name: String,\n    /// Resource description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    /// MIME type.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option<String>,\n}\n\n/// Response for `resources/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourcesListResult {\n    /// Available resources.\n    pub resources: Vec<McpResourceDefinition>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resources_read_params_serde() {\n        let p = ResourcesReadParams {\n            uri: \"file:///data.txt\".into(),\n        };\n        let s = serde_json::to_string(&p).expect(\"ser\");\n        let back: ResourcesReadParams = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.uri, \"file:///data.txt\");\n    }\n\n    #[test]\n    fn resource_definition_roundtrip() {\n        let def = McpResourceDefinition {\n            uri: \"file:///x\".into(),\n            name: \"config\".into(),\n            description: Some(\"Config file\".into()),\n            mime_type: Some(\"text/plain\".into()),\n        };\n        let s = serde_json::to_string(&def).expect(\"ser\");\n        let back: McpResourceDefinition = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.name, \"config\");\n        assert_eq!(back.mime_type, Some(\"text/plain\".into()));\n    }\n\n    #[test]\n    fn resources_list_result_roundtrip() {\n        let r = ResourcesListResult {\n            resources: vec![McpResourceDefinition {\n                uri: \"x\".into(),\n                name: \"r\".into(),\n                description: None,\n                mime_type: None,\n            }],\n        };\n        let s = serde_json::to_string(&r).expect(\"ser\");\n        let back: ResourcesListResult = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.resources.len(), 1);\n    }\n\n    #[test]\n    fn resource_definition_optional_fields_skipped() {\n        let def = McpResourceDefinition {\n            uri: \"x\".into(),\n            name: \"r\".into(),\n            description: None,\n            mime_type: None,\n        };\n        let s = serde_json::to_string(&def).expect(\"ser\");\n        assert!(!s.contains(\"description\"));\n        assert!(!s.contains(\"mime_type\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","tools.rs"],"content":"//! MCP tools/* method types.\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// Request params for `tools/list`.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolsListParams {\n    /// Optional cursor for pagination.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub cursor: Option<String>,\n}\n\n/// A single tool definition in the MCP response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpToolDefinition {\n    /// Tool name.\n    pub name: String,\n    /// Tool description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    /// JSON Schema for input parameters.\n    #[serde(rename = \"inputSchema\")]\n    pub input_schema: Value,\n}\n\n/// Response for `tools/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsListResult {\n    /// Available tools.\n    pub tools: Vec<McpToolDefinition>,\n    /// Pagination cursor for next page.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option<String>,\n}\n\n/// Request params for `tools/call`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsCallParams {\n    /// Name of the tool to invoke.\n    pub name: String,\n    /// Arguments to pass.\n    #[serde(default)]\n    pub arguments: Value,\n}\n\n/// Content item in a tool call response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\npub enum ToolContent {\n    /// Text content.\n    Text { text: String },\n    /// Image content (base64).\n    Image { data: String, mime_type: String },\n}\n\n/// Response for `tools/call`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsCallResult {\n    /// Content items returned by the tool.\n    pub content: Vec<ToolContent>,\n    /// Whether the tool call resulted in an error.\n    #[serde(default, rename = \"isError\")]\n    pub is_error: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn tools_list_params_default() {\n        let p = ToolsListParams::default();\n        assert!(p.cursor.is_none());\n    }\n\n    #[test]\n    fn tool_definition_serde_roundtrip() {\n        let def = McpToolDefinition {\n            name: \"my-tool\".into(),\n            description: Some(\"A tool\".into()),\n            input_schema: json!({\"type\": \"object\"}),\n        };\n        let s = serde_json::to_string(&def).expect(\"ser\");\n        assert!(s.contains(\"inputSchema\"));\n        let back: McpToolDefinition = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.name, \"my-tool\");\n    }\n\n    #[test]\n    fn tools_list_result_with_tools() {\n        let res = ToolsListResult {\n            tools: vec![McpToolDefinition {\n                name: \"t\".into(),\n                description: None,\n                input_schema: json!({}),\n            }],\n            next_cursor: None,\n        };\n        let s = serde_json::to_string(&res).expect(\"ser\");\n        let back: ToolsListResult = serde_json::from_str(&s).expect(\"de\");\n        assert_eq!(back.tools.len(), 1);\n    }\n\n    #[test]\n    fn tools_call_params_serde() {\n        let j = r#\"{\"name\":\"echo\",\"arguments\":{\"x\":1}}\"#;\n        let p: ToolsCallParams = serde_json::from_str(j).expect(\"de\");\n        assert_eq!(p.name, \"echo\");\n        assert_eq!(p.arguments[\"x\"], 1);\n    }\n\n    #[test]\n    fn tool_content_text_variant() {\n        let c = ToolContent::Text { text: \"hello\".into() };\n        let s = serde_json::to_string(&c).expect(\"ser\");\n        assert!(s.contains(\"\\\"type\\\":\\\"text\\\"\"));\n    }\n\n    #[test]\n    fn tools_call_result_roundtrip() {\n        let r = ToolsCallResult {\n            content: vec![ToolContent::Text { text: \"ok\".into() }],\n            is_error: false,\n        };\n        let s = serde_json::to_string(&r).expect(\"ser\");\n        let back: ToolsCallResult = serde_json::from_str(&s).expect(\"de\");\n        assert!(!back.is_error);\n        assert_eq!(back.content.len(), 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","schema.rs"],"content":"//! JSON Schema helpers for MCP tool input validation.\n\nuse serde_json::Value;\nuse thiserror::Error;\n\n/// Schema validation errors.\n#[derive(Debug, Error)]\npub enum SchemaError {\n    /// The input does not match the expected schema.\n    #[error(\"schema validation failed: {message}\")]\n    ValidationFailed { message: String },\n    /// The schema itself is malformed.\n    #[error(\"invalid schema: {message}\")]\n    InvalidSchema { message: String },\n}\n\n/// Checks that a JSON value contains required properties from a schema.\n///\n/// This is a minimal validator - checks required fields and basic types.\npub fn validate_required_fields(schema: &Value, input: &Value) -> Result<(), SchemaError> {\n    let required = match schema.get(\"required\") {\n        Some(Value::Array(arr)) => arr,\n        _ => return Ok(()),\n    };\n\n    let input_obj = input\n        .as_object()\n        .ok_or_else(|| SchemaError::ValidationFailed {\n            message: \"input must be an object\".to_string(),\n        })?;\n\n    for field in required {\n        let field_name = field.as_str().ok_or_else(|| SchemaError::InvalidSchema {\n            message: \"required field names must be strings\".to_string(),\n        })?;\n        if !input_obj.contains_key(field_name) {\n            return Err(SchemaError::ValidationFailed {\n                message: format!(\"missing required field: {field_name}\"),\n            });\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn validates_required_fields() {\n        let schema = json!({\n            \"required\": [\"url\"],\n            \"properties\": {\n                \"url\": {\"type\": \"string\"}\n            }\n        });\n        let input = json!({\"url\": \"https://example.com\"});\n        assert!(validate_required_fields(&schema, &input).is_ok());\n    }\n\n    #[test]\n    fn rejects_missing_required_field() {\n        let schema = json!({\"required\": [\"url\"]});\n        let input = json!({});\n        assert!(validate_required_fields(&schema, &input).is_err());\n    }\n\n    #[test]\n    fn no_required_array_passes() {\n        let schema = json!({\"properties\": {\"x\": {\"type\": \"string\"}}});\n        let input = json!({});\n        assert!(validate_required_fields(&schema, &input).is_ok());\n    }\n\n    #[test]\n    fn non_object_input_rejected() {\n        let schema = json!({\"required\": [\"a\"]});\n        let input = json!(42);\n        assert!(validate_required_fields(&schema, &input).is_err());\n    }\n\n    #[test]\n    fn multiple_required_all_present() {\n        let schema = json!({\"required\": [\"a\", \"b\", \"c\"]});\n        let input = json!({\"a\": 1, \"b\": 2, \"c\": 3});\n        assert!(validate_required_fields(&schema, &input).is_ok());\n    }\n\n    #[test]\n    fn multiple_required_one_missing() {\n        let schema = json!({\"required\": [\"a\", \"b\"]});\n        let input = json!({\"a\": 1});\n        assert!(validate_required_fields(&schema, &input).is_err());\n    }\n\n    #[test]\n    fn empty_required_array_passes() {\n        let schema = json!({\"required\": []});\n        let input = json!({\"x\": 1});\n        assert!(validate_required_fields(&schema, &input).is_ok());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":21,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":33,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":13,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","lib.rs"],"content":"//! # kami-registry\n//!\n//! Port definitions (abstract traits) for the tool registry.\n//! Adapter crates implement these traits.\n\npub mod query;\npub mod repository;\n\npub use query::ToolQuery;\npub use repository::{RepositoryError, ToolRepository};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","query.rs"],"content":"//! Query types for tool repository lookups.\n\nuse serde::{Deserialize, Serialize};\n\n/// Filtering and pagination for tool queries.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolQuery {\n    /// Filter by name (substring match).\n    pub name_filter: Option<String>,\n    /// Filter by keyword.\n    pub keyword: Option<String>,\n    /// Only enabled tools.\n    pub enabled_only: bool,\n    /// Maximum results to return.\n    pub limit: Option<u32>,\n    /// Offset for pagination.\n    pub offset: Option<u32>,\n}\n\nimpl ToolQuery {\n    /// Creates a query that matches all tools.\n    pub fn all() -> Self {\n        Self::default()\n    }\n\n    /// Sets the name filter.\n    pub fn with_name(mut self, name: impl Into<String>) -> Self {\n        self.name_filter = Some(name.into());\n        self\n    }\n\n    /// Sets the limit.\n    pub fn with_limit(mut self, limit: u32) -> Self {\n        self.limit = Some(limit);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_returns_default_query() {\n        let q = ToolQuery::all();\n        assert!(q.name_filter.is_none());\n        assert!(q.keyword.is_none());\n        assert!(!q.enabled_only);\n        assert!(q.limit.is_none());\n        assert!(q.offset.is_none());\n    }\n\n    #[test]\n    fn with_name_sets_filter() {\n        let q = ToolQuery::all().with_name(\"fetch\");\n        assert_eq!(q.name_filter.as_deref(), Some(\"fetch\"));\n    }\n\n    #[test]\n    fn builder_chaining_sets_all_fields() {\n        let q = ToolQuery::all().with_name(\"echo\").with_limit(10);\n        assert_eq!(q.name_filter.as_deref(), Some(\"echo\"));\n        assert_eq!(q.limit, Some(10));\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":23,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":29,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","repository.rs"],"content":"//! Abstract repository trait (port) for tool storage.\n\nuse async_trait::async_trait;\nuse thiserror::Error;\n\nuse kami_types::{Tool, ToolId};\n\nuse crate::query::ToolQuery;\n\n/// Errors returned by repository implementations.\n#[derive(Debug, Error)]\n#[non_exhaustive]\npub enum RepositoryError {\n    /// The requested tool was not found.\n    #[error(\"tool not found: {id}\")]\n    NotFound { id: String },\n    /// A database or I/O error occurred.\n    #[error(\"storage error: {message}\")]\n    Storage { message: String },\n    /// A conflict (duplicate id, etc.).\n    #[error(\"conflict: {message}\")]\n    Conflict { message: String },\n    /// Stored data is corrupt or cannot be deserialized.\n    #[error(\"data corruption for tool '{tool_id}': {message}\")]\n    DataCorruption { tool_id: String, message: String },\n}\n\n/// Abstract trait for tool persistence.\n///\n/// Implementations live in adapter crates (e.g., `kami-store-sqlite`).\n#[async_trait]\npub trait ToolRepository: Send + Sync {\n    /// Finds a tool by its unique ID.\n    async fn find_by_id(&self, id: &ToolId) -> Result<Option<Tool>, RepositoryError>;\n\n    /// Finds tools matching a query.\n    async fn find_all(&self, query: ToolQuery) -> Result<Vec<Tool>, RepositoryError>;\n\n    /// Inserts a new tool.\n    async fn insert(&self, tool: &Tool) -> Result<(), RepositoryError>;\n\n    /// Updates an existing tool. Returns `NotFound` if absent.\n    async fn update(&self, tool: &Tool) -> Result<(), RepositoryError>;\n\n    /// Deletes a tool by ID. Returns true if it existed.\n    async fn delete(&self, id: &ToolId) -> Result<bool, RepositoryError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","benches","cache_bench.rs"],"content":"//! Benchmark for `ComponentCache` LRU operations.\n//!\n//! Measures insert, get (hit/miss), and eviction under load using a real\n//! (minimal) WASM component for realistic cache entry sizes.\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse kami_runtime::cache::{CachedComponent, ComponentCache};\nuse kami_types::{SecurityConfig, ToolId};\nuse wasmtime::{component::Component, Config, Engine};\n\n/// Minimal valid WASM component (empty component, ~8 bytes).\nconst MINIMAL_WAT: &str = \"(component)\";\n\n/// Creates a `CachedComponent` wrapping a real compiled component.\nfn make_entry(engine: &Engine, path: &str) -> CachedComponent {\n    let component = Component::new(engine, MINIMAL_WAT).expect(\"bench: compile minimal\");\n    CachedComponent {\n        component,\n        security: SecurityConfig::default(),\n        wasm_path: path.to_string(),\n    }\n}\n\n/// Shared engine (component model enabled).\nfn bench_engine() -> Engine {\n    let mut config = Config::new();\n    config.wasm_component_model(true);\n    Engine::new(&config).expect(\"bench: engine\")\n}\n\nfn bench_cache_insert(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n\n    c.bench_function(\"cache_insert_100\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let cache = ComponentCache::new(100);\n                for i in 0..100u32 {\n                    let id_str = format!(\"dev.test.tool-{i}\");\n                    let id = ToolId::new(&id_str).expect(\"bench: id\");\n                    cache\n                        .insert(&id, make_entry(&engine, &format!(\"t{i}.wasm\")))\n                        .await;\n                }\n                black_box(cache.len().await);\n            });\n        });\n    });\n}\n\nfn bench_cache_get_hit(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n    let cache = rt.block_on(async {\n        let c = ComponentCache::new(100);\n        for i in 0..100u32 {\n            let id_str = format!(\"dev.test.tool-{i}\");\n            let id = ToolId::new(&id_str).expect(\"bench: id\");\n            c.insert(&id, make_entry(&engine, &format!(\"t{i}.wasm\")))\n                .await;\n        }\n        c\n    });\n\n    c.bench_function(\"cache_get_hit\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let id = ToolId::new(\"dev.test.tool-50\").expect(\"bench: id\");\n                black_box(cache.get(&id).await);\n            });\n        });\n    });\n}\n\nfn bench_cache_get_miss(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let cache = ComponentCache::new(100);\n\n    c.bench_function(\"cache_get_miss\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let id = ToolId::new(\"dev.test.none\").expect(\"bench: id\");\n                black_box(cache.get(&id).await);\n            });\n        });\n    });\n}\n\nfn bench_cache_eviction(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n\n    c.bench_function(\"cache_evict_lru_10\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let cache = ComponentCache::new(10);\n                for i in 0..20u32 {\n                    let id_str = format!(\"dev.test.tool-{i}\");\n                    let id = ToolId::new(&id_str).expect(\"bench: id\");\n                    cache\n                        .insert(&id, make_entry(&engine, &format!(\"t{i}.wasm\")))\n                        .await;\n                }\n                black_box(cache.len().await);\n            });\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_cache_insert,\n    bench_cache_get_hit,\n    bench_cache_get_miss,\n    bench_cache_eviction,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","cache.rs"],"content":"//! Compiled component cache with LRU eviction.\n//!\n//! Caches pre-compiled `wasmtime::component::Component` instances keyed\n//! by `ToolId`. Compilation is expensive; instantiation is cheap.\n//! Uses a `Mutex` since LRU tracking requires mutable access on reads.\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse tokio::sync::Mutex;\nuse wasmtime::component::Component;\n\nuse kami_types::{SecurityConfig, ToolId};\n\n/// A cached compiled component with its security config.\n#[derive(Clone)]\npub struct CachedComponent {\n    /// Pre-compiled wasmtime component.\n    pub component: Component,\n    /// Security config from the tool manifest.\n    pub security: SecurityConfig,\n    /// WASM file path for cache invalidation.\n    pub wasm_path: String,\n}\n\n/// Thread-safe LRU cache for compiled WASM components.\n///\n/// Components are keyed by `ToolId` and can be shared across\n/// concurrent executions. Uses LRU eviction when the cache\n/// reaches its maximum capacity.\n#[derive(Clone)]\npub struct ComponentCache {\n    inner: Arc<Mutex<LruInner>>,\n}\n\n/// Internal LRU state: `order` front = least recently used.\nstruct LruInner {\n    entries: HashMap<String, CachedComponent>,\n    order: Vec<String>,\n    max_size: usize,\n}\n\nimpl ComponentCache {\n    /// Creates a new cache with the given maximum size.\n    pub fn new(max_size: usize) -> Self {\n        Self {\n            inner: Arc::new(Mutex::new(LruInner {\n                entries: HashMap::new(),\n                order: Vec::with_capacity(max_size),\n                max_size,\n            })),\n        }\n    }\n\n    /// Gets a cached component by tool ID, marking it as recently used.\n    pub async fn get(&self, id: &ToolId) -> Option<CachedComponent> {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str();\n        if inner.entries.contains_key(key) {\n            inner.touch(key);\n            inner.entries.get(key).cloned()\n        } else {\n            None\n        }\n    }\n\n    /// Inserts a compiled component into the cache.\n    ///\n    /// If the cache is full, the least recently used entry is evicted.\n    pub async fn insert(&self, id: &ToolId, entry: CachedComponent) {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str().to_string();\n        if inner.entries.contains_key(&key) {\n            inner.touch(&key);\n        } else {\n            if inner.entries.len() >= inner.max_size {\n                inner.evict_lru();\n            }\n            inner.order.push(key.clone());\n        }\n        inner.entries.insert(key, entry);\n    }\n\n    /// Removes a cached component.\n    pub async fn invalidate(&self, id: &ToolId) {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str();\n        inner.entries.remove(key);\n        inner.order.retain(|k| k != key);\n    }\n\n    /// Clears the entire cache.\n    pub async fn clear(&self) {\n        let mut inner = self.inner.lock().await;\n        inner.entries.clear();\n        inner.order.clear();\n    }\n\n    /// Returns the number of cached components.\n    pub async fn len(&self) -> usize {\n        let inner = self.inner.lock().await;\n        inner.entries.len()\n    }\n\n    /// Returns true if the cache is empty.\n    pub async fn is_empty(&self) -> bool {\n        self.len().await == 0\n    }\n}\n\nimpl LruInner {\n    /// Moves `key` to the back (most recently used).\n    fn touch(&mut self, key: &str) {\n        self.order.retain(|k| k != key);\n        self.order.push(key.to_string());\n    }\n\n    /// Evicts the least recently used entry (front of the order vec).\n    fn evict_lru(&mut self) {\n        if let Some(lru_key) = self.order.first().cloned() {\n            self.order.remove(0);\n            self.entries.remove(&lru_key);\n        }\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":47,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":56,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":57,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":58,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":59,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":60,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":61,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":63,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":70,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":71,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":72,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":73,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":81,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":115,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":32,"coverable":39},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","context.rs"],"content":"//! Execution context for tool invocations.\n\nuse std::collections::HashMap;\nuse std::time::Duration;\n\nuse kami_types::ToolId;\n\n/// Context passed to a tool execution.\n#[derive(Debug, Clone)]\npub struct ExecutionContext {\n    /// The tool being executed.\n    pub tool_id: ToolId,\n    /// Arguments for the tool.\n    pub arguments: HashMap<String, serde_json::Value>,\n    /// Execution timeout.\n    pub timeout: Duration,\n    /// Unique execution ID for tracing.\n    pub execution_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","error.rs"],"content":"//! Runtime-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the runtime orchestrator.\n#[derive(Debug, Error)]\npub enum RuntimeError {\n    /// Tool not found in registry.\n    #[error(\"tool not found: {name}\")]\n    ToolNotFound { name: String },\n    /// Engine error during execution.\n    #[error(\"engine error: {0}\")]\n    Engine(#[from] kami_engine::EngineError),\n    /// Sandbox policy violation.\n    #[error(\"sandbox error: {0}\")]\n    Sandbox(#[from] kami_sandbox::SandboxError),\n    /// Execution timed out.\n    #[error(\"execution timed out after {timeout_ms}ms\")]\n    Timeout { timeout_ms: u64 },\n    /// Pool exhausted (no available instances).\n    #[error(\"instance pool exhausted\")]\n    PoolExhausted,\n    /// WASM file hash does not match the stored SHA-256 digest.\n    #[error(\"integrity violation for tool '{tool_id}': {detail}\")]\n    IntegrityViolation { tool_id: String, detail: String },\n    /// Request rejected by rate limiter.\n    #[error(\"rate limited: tool '{tool_id}' exceeded {limit} req/{window_secs}s\")]\n    RateLimited {\n        tool_id: String,\n        limit: u64,\n        window_secs: u64,\n    },\n}\n\nimpl From<RuntimeError> for KamiError {\n    fn from(e: RuntimeError) -> Self {\n        let kind = match &e {\n            RuntimeError::ToolNotFound { .. } => ErrorKind::NotFound,\n            RuntimeError::Sandbox(kami_sandbox::SandboxError::InvalidConfig { .. }) => {\n                ErrorKind::InvalidInput\n            }\n            RuntimeError::Sandbox(_) => ErrorKind::PermissionDenied,\n            RuntimeError::Timeout { .. } => ErrorKind::Timeout,\n            RuntimeError::PoolExhausted => ErrorKind::ResourceExhausted,\n            RuntimeError::IntegrityViolation { .. } => ErrorKind::PermissionDenied,\n            RuntimeError::RateLimited { .. } => ErrorKind::ResourceExhausted,\n            RuntimeError::Engine(_) => ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for RuntimeError {\n    fn hint(&self) -> Option<String> {\n        match self {\n            Self::ToolNotFound { name } => Some(format!(\n                \"No tool with id '{name}' is registered in the local database.\"\n            )),\n            Self::Timeout { timeout_ms } => {\n                Some(format!(\"Execution exceeded the {timeout_ms}ms time limit.\"))\n            }\n            Self::PoolExhausted => {\n                Some(\"All execution slots are busy. The system is under heavy load.\".into())\n            }\n            Self::IntegrityViolation { .. } => Some(\n                \"The WASM file on disk does not match the SHA-256 hash recorded at install time.\"\n                    .into(),\n            ),\n            Self::RateLimited { .. } => {\n                Some(\"Too many requests for this tool in the current time window.\".into())\n            }\n            Self::Engine(e) => e.hint(),\n            Self::Sandbox(e) => e.hint(),\n        }\n    }\n\n    fn fix(&self) -> Option<String> {\n        match self {\n            Self::ToolNotFound { .. } => {\n                Some(\"Install the tool first: kami install <path-to-tool>\".into())\n            }\n            Self::Timeout { .. } => Some(\n                \"Increase the timeout in tool.toml:\\n  [security]\\n  max_execution_ms = 10000\"\n                    .into(),\n            ),\n            Self::PoolExhausted => {\n                Some(\"Increase runtime concurrency: kami serve --concurrency 16\".into())\n            }\n            Self::IntegrityViolation { .. } => {\n                Some(\"Re-install the tool: kami uninstall <id> && kami install <path>\".into())\n            }\n            Self::RateLimited { .. } => {\n                Some(\"Wait before retrying, or increase rate_limit_per_tool in config.\".into())\n            }\n            Self::Engine(e) => e.fix(),\n            Self::Sandbox(e) => e.fix(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn tool_not_found_maps_to_not_found() {\n        let err: KamiError = RuntimeError::ToolNotFound { name: \"x\".into() }.into();\n        assert_eq!(err.kind, ErrorKind::NotFound);\n    }\n\n    #[test]\n    fn timeout_maps_to_timeout_kind() {\n        let err: KamiError = RuntimeError::Timeout { timeout_ms: 5000 }.into();\n        assert_eq!(err.kind, ErrorKind::Timeout);\n    }\n\n    #[test]\n    fn rate_limited_has_fix_suggestion() {\n        let e = RuntimeError::RateLimited {\n            tool_id: \"t\".into(),\n            limit: 10,\n            window_secs: 60,\n        };\n        assert!(e.fix().expect(\"has fix\").contains(\"rate_limit\"));\n    }\n\n    #[test]\n    fn pool_exhausted_maps_to_resource_exhausted() {\n        let err: KamiError = RuntimeError::PoolExhausted.into();\n        assert_eq!(err.kind, ErrorKind::ResourceExhausted);\n    }\n\n    #[test]\n    fn integrity_violation_maps_to_permission_denied() {\n        let err: KamiError = RuntimeError::IntegrityViolation {\n            tool_id: \"t\".into(),\n            detail: \"mismatch\".into(),\n        }\n        .into();\n        assert_eq!(err.kind, ErrorKind::PermissionDenied);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":55,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":56,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":25,"coverable":33},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","executor.rs"],"content":"//! Async tool executor with full isolation pipeline.\n//!\n//! Pipeline: validate config → build sandbox → apply limits → execute with timeout.\n\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse tracing::{debug, warn};\nuse wasmtime::component::{Component, Linker};\nuse wasmtime::Engine;\n\nuse kami_engine::{\n    call_tool_run, create_store, instantiate_component, instantiate_tool, set_epoch_deadline,\n    HostState,\n};\nuse kami_sandbox::{build_wasi_ctx, validate_security_config, WasiConfig};\nuse kami_types::SecurityConfig;\n\nuse crate::error::RuntimeError;\nuse crate::types::{ExecutionResult, ToolExecutor};\n\n/// Concrete executor that runs WASM components through the\n/// engine + sandbox pipeline with full isolation enforcement.\npub struct WasmToolExecutor {\n    engine: Engine,\n    linker: Linker<HostState>,\n}\n\nimpl WasmToolExecutor {\n    /// Creates a new executor with a pre-configured engine and linker.\n    pub fn new(engine: Engine, linker: Linker<HostState>) -> Self {\n        Self { engine, linker }\n    }\n}\n\n#[async_trait]\nimpl ToolExecutor for WasmToolExecutor {\n    /// Executes a component with full isolation pipeline.\n    ///\n    /// # Errors\n    ///\n    /// Returns `RuntimeError::Sandbox` if security config is invalid.\n    /// Returns `RuntimeError::Engine` if the component fails to execute.\n    /// Returns `RuntimeError::Timeout` if execution exceeds the deadline.\n    #[tracing::instrument(skip_all, fields(\n        max_fuel = security.limits.max_fuel,\n        timeout_ms = security.limits.max_execution_ms,\n    ))]\n    async fn execute(\n        &self,\n        component: &Component,\n        input: &str,\n        security: &SecurityConfig,\n    ) -> Result<ExecutionResult, RuntimeError> {\n        let start = Instant::now();\n\n        // 1. Validate security config\n        validate_security_config(security)?;\n\n        let fuel = security.limits.max_fuel;\n        let max_memory = security.limits.max_memory_mb as usize * 1024 * 1024;\n        let timeout_duration = Duration::from_millis(security.limits.max_execution_ms);\n\n        debug!(\n            fuel,\n            max_memory_mb = security.limits.max_memory_mb,\n            timeout_ms = security.limits.max_execution_ms,\n            \"starting isolated execution\"\n        );\n\n        // 2. Build sandboxed WASI context\n        let wasi_config = WasiConfig {\n            inherit_stdout: true,\n            inherit_stderr: true,\n            ..WasiConfig::default()\n        };\n        let wasi_ctx = build_wasi_ctx(security, &wasi_config, None)?;\n\n        // 3. Create store with memory limits + fuel\n        let host_state = HostState::with_limits(wasi_ctx, max_memory);\n        let mut store = create_store(&self.engine, host_state, fuel)?;\n\n        // 4. Set epoch deadline (1 tick = timeout reached)\n        set_epoch_deadline(&mut store, 1);\n\n        // 5. Spawn epoch ticker that increments epoch after timeout\n        let engine_clone = self.engine.clone();\n        let tick_handle = tokio::spawn(async move {\n            tokio::time::sleep(timeout_duration).await;\n            engine_clone.increment_epoch();\n        });\n\n        // 6. Instantiate and call: try typed API (WIT components), fallback to flat\n        let outer_timeout = timeout_duration + Duration::from_millis(500);\n        let call_result = tokio::time::timeout(outer_timeout, async {\n            match instantiate_tool(&self.linker, &mut store, component).await {\n                Ok(tool) => kami_engine::bindings::call_run(&mut store, &tool, input).await,\n                Err(_) => {\n                    let inst = instantiate_component(&self.linker, &mut store, component).await?;\n                    call_tool_run(&mut store, &inst, input).await\n                }\n            }\n        })\n        .await;\n\n        tick_handle.abort();\n\n        let duration_ms = start.elapsed().as_millis() as u64;\n        let fuel_remaining = store.get_fuel().unwrap_or(0);\n        let fuel_consumed = fuel.saturating_sub(fuel_remaining);\n\n        match call_result {\n            Ok(Ok(Ok(output))) => Ok(ExecutionResult {\n                content: output,\n                duration_ms,\n                success: true,\n                fuel_consumed,\n            }),\n            Ok(Ok(Err(error))) => Ok(ExecutionResult {\n                content: error,\n                duration_ms,\n                success: false,\n                fuel_consumed,\n            }),\n            Ok(Err(engine_err)) => {\n                warn!(?engine_err, \"engine error during execution\");\n                Err(engine_err.into())\n            }\n            Err(_elapsed) => {\n                warn!(\n                    timeout_ms = security.limits.max_execution_ms,\n                    \"execution timed out\"\n                );\n                Err(RuntimeError::Timeout {\n                    timeout_ms: security.limits.max_execution_ms,\n                })\n            }\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":96,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":97,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":99,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":100,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":6,"coverable":9},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","integrity.rs"],"content":"//! WASM component integrity verification.\n//!\n//! Computes and verifies SHA-256 hashes of WASM files to detect\n//! tampering between install time and execution time.\n\nuse std::io;\nuse std::path::Path;\n\nuse hex::ToHex;\nuse sha2::{Digest, Sha256};\n\n/// Computes the SHA-256 hash of a file and returns it as a hex string.\n///\n/// # Errors\n///\n/// Returns `io::Error` if the file cannot be read.\npub fn compute_file_hash(path: &Path) -> Result<String, io::Error> {\n    let bytes = std::fs::read(path)?;\n    let mut hasher = Sha256::new();\n    hasher.update(&bytes);\n    Ok(hasher.finalize().encode_hex::<String>())\n}\n\n/// Verifies that a file matches an expected SHA-256 hex digest.\n///\n/// Returns `Ok(())` if the hash matches or if `expected` is `None`\n/// (no stored hash = verification skipped for backwards compatibility).\n///\n/// # Errors\n///\n/// Returns `Err(actual_hash)` if the computed hash differs from `expected`.\npub fn verify_hash(path: &Path, expected: &Option<String>) -> Result<(), io::Error> {\n    let Some(expected_hash) = expected else {\n        // No stored hash — skip verification (pre-integrity install).\n        return Ok(());\n    };\n\n    let actual = compute_file_hash(path)?;\n    if actual != *expected_hash {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\"integrity violation: expected {expected_hash}, got {actual}\"),\n        ));\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn hash_deterministic() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"hello\").unwrap();\n        let h1 = compute_file_hash(f.path()).unwrap();\n        let h2 = compute_file_hash(f.path()).unwrap();\n        assert_eq!(h1, h2);\n    }\n\n    #[test]\n    fn hash_known_value() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"\").unwrap();\n        let h = compute_file_hash(f.path()).unwrap();\n        // SHA-256 of empty input\n        assert_eq!(\n            h,\n            \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n        );\n    }\n\n    #[test]\n    fn verify_passes_when_no_expected() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        assert!(verify_hash(f.path(), &None).is_ok());\n    }\n\n    #[test]\n    fn verify_passes_with_correct_hash() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        let hash = compute_file_hash(f.path()).unwrap();\n        assert!(verify_hash(f.path(), &Some(hash)).is_ok());\n    }\n\n    #[test]\n    fn verify_fails_with_wrong_hash() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        let wrong = \"0\".repeat(64);\n        assert!(verify_hash(f.path(), &Some(wrong)).is_err());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":18,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":19,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":20,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":21,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":32,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":33,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":39,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":14,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","lib.rs"],"content":"//! # kami-runtime\n//!\n//! Runtime orchestrator for KAMI.\n//! Manages tool execution, scheduling, component caching, and\n//! tool resolution from the registry.\n//!\n//! Use `KamiRuntime` for high-level tool execution by ID, or\n//! `WasmToolExecutor` directly for low-level component execution.\n\npub mod cache;\npub mod context;\npub mod error;\npub mod executor;\npub mod integrity;\npub mod metrics;\npub mod orchestrator;\npub mod pipeline;\npub mod rate_limiter;\npub mod resolver;\npub mod runtime_config;\npub mod scheduler;\npub mod types;\n\npub use cache::{CachedComponent, ComponentCache};\npub use context::ExecutionContext;\npub use error::RuntimeError;\npub use executor::WasmToolExecutor;\npub use integrity::{compute_file_hash, verify_hash};\npub use metrics::{ExecutionMetrics, MetricsSnapshot};\npub use orchestrator::KamiRuntime;\npub use pipeline::{\n    execute_pipeline, PipelineDefinition, PipelineError, PipelineResult, PipelineStep, StepResult,\n};\npub use rate_limiter::{RateLimitConfig, RateLimiter};\npub use resolver::ToolResolver;\npub use runtime_config::RuntimeConfig;\npub use scheduler::{Priority, Scheduler, SchedulerConfig};\npub use types::{ExecutionResult, ToolExecutor};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","metrics.rs"],"content":"//! Execution metrics for the KAMI runtime.\n//!\n//! Tracks key counters using lock-free atomics for zero-overhead recording\n//! from concurrent async tasks. Use [`MetricsSnapshot`] for human-readable output.\n\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\n/// Shared, thread-safe execution metrics collected by [`super::KamiRuntime`].\n///\n/// All fields are `AtomicU64` — incrementing from any async task is safe and fast.\n#[derive(Debug, Default)]\npub struct ExecutionMetrics {\n    /// Total number of tool executions attempted.\n    pub total_executions: AtomicU64,\n    /// Number of executions that completed successfully.\n    pub successful_executions: AtomicU64,\n    /// Number of executions that returned an error.\n    pub failed_executions: AtomicU64,\n    /// Cumulative fuel consumed across all successful executions.\n    pub total_fuel_consumed: AtomicU64,\n    /// Number of times a compiled component was found in the cache.\n    pub cache_hits: AtomicU64,\n    /// Number of times a component had to be compiled from scratch.\n    pub cache_misses: AtomicU64,\n}\n\n/// A point-in-time snapshot of [`ExecutionMetrics`].\n///\n/// Use [`ExecutionMetrics::snapshot`] to obtain a copyable view.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MetricsSnapshot {\n    /// Total executions attempted.\n    pub total_executions: u64,\n    /// Successful executions.\n    pub successful_executions: u64,\n    /// Failed executions.\n    pub failed_executions: u64,\n    /// Cumulative fuel consumed.\n    pub total_fuel_consumed: u64,\n    /// Cache hits (compiled component reused).\n    pub cache_hits: u64,\n    /// Cache misses (component compiled fresh).\n    pub cache_misses: u64,\n}\n\nimpl ExecutionMetrics {\n    /// Creates a new zeroed metrics instance wrapped in an [`Arc`].\n    pub fn new_shared() -> Arc<Self> {\n        Arc::new(Self::default())\n    }\n\n    /// Records one attempted execution.\n    pub fn record_attempt(&self) {\n        self.total_executions.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a successful execution with the given fuel consumed.\n    pub fn record_success(&self, fuel_consumed: u64) {\n        self.successful_executions.fetch_add(1, Ordering::Relaxed);\n        self.total_fuel_consumed\n            .fetch_add(fuel_consumed, Ordering::Relaxed);\n    }\n\n    /// Records a failed execution.\n    pub fn record_failure(&self) {\n        self.failed_executions.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a cache hit (component was reused from the cache).\n    pub fn record_cache_hit(&self) {\n        self.cache_hits.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a cache miss (component was compiled and stored).\n    pub fn record_cache_miss(&self) {\n        self.cache_misses.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Returns a point-in-time snapshot of all counters.\n    pub fn snapshot(&self) -> MetricsSnapshot {\n        MetricsSnapshot {\n            total_executions: self.total_executions.load(Ordering::Relaxed),\n            successful_executions: self.successful_executions.load(Ordering::Relaxed),\n            failed_executions: self.failed_executions.load(Ordering::Relaxed),\n            total_fuel_consumed: self.total_fuel_consumed.load(Ordering::Relaxed),\n            cache_hits: self.cache_hits.load(Ordering::Relaxed),\n            cache_misses: self.cache_misses.load(Ordering::Relaxed),\n        }\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":50,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":54,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":55,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":60,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":66,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":81,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":83,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":84,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":85,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":86,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":87,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":88,"address":[],"length":0,"stats":{"Line":1008806316530991104}}],"covered":21,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","orchestrator.rs"],"content":"//! Top-level runtime orchestrator — combines resolution, scheduling, and WASM execution.\n\nuse std::sync::Arc;\n\nuse kami_engine::{create_engine, create_linker, HostState, InstanceConfig};\nuse kami_registry::ToolRepository;\nuse kami_types::ToolId;\nuse tracing::{info, warn};\nuse wasmtime::{component::Linker, Engine};\n\nuse crate::scheduler::{Scheduler, SchedulerConfig};\nuse crate::types::{ExecutionResult, ToolExecutor};\nuse crate::{cache::ComponentCache, error::RuntimeError, executor::WasmToolExecutor};\nuse crate::{metrics::ExecutionMetrics, resolver::ToolResolver, runtime_config::RuntimeConfig};\n\n/// Top-level runtime orchestrator.\n///\n/// Combines tool resolution, scheduling, and sandboxed WASM execution.\n/// Use `metrics()` to read live atomic counters.\npub struct KamiRuntime {\n    executor: WasmToolExecutor,\n    resolver: ToolResolver,\n    scheduler: Scheduler,\n    metrics: Arc<ExecutionMetrics>,\n}\n\nimpl KamiRuntime {\n    /// Creates a new runtime with the given configuration and repository.\n    ///\n    /// # Errors\n    /// Returns `RuntimeError` if the engine or linker cannot be created.\n    pub fn new(\n        config: RuntimeConfig,\n        repository: Arc<dyn ToolRepository>,\n    ) -> Result<Self, RuntimeError> {\n        let instance_config = InstanceConfig {\n            epoch_interruption: config.epoch_interruption,\n            ..InstanceConfig::default()\n        };\n        let engine = create_engine(&instance_config)?;\n        let linker = create_linker(&engine)?;\n        let cache = ComponentCache::new(config.cache_size);\n        let scheduler = Scheduler::new(&SchedulerConfig {\n            max_concurrent: config.max_concurrent,\n        });\n        let metrics = ExecutionMetrics::new_shared();\n        Ok(Self {\n            executor: WasmToolExecutor::new(engine.clone(), linker),\n            resolver: ToolResolver::new(engine, cache, repository),\n            scheduler,\n            metrics,\n        })\n    }\n\n    /// Creates a runtime from an existing engine and linker.\n    pub fn with_engine(\n        engine: Engine,\n        linker: Linker<HostState>,\n        config: RuntimeConfig,\n        repository: Arc<dyn ToolRepository>,\n    ) -> Self {\n        let cache = ComponentCache::new(config.cache_size);\n        let scheduler_config = SchedulerConfig {\n            max_concurrent: config.max_concurrent,\n        };\n        let metrics = ExecutionMetrics::new_shared();\n        Self {\n            executor: WasmToolExecutor::new(engine.clone(), linker),\n            resolver: ToolResolver::new(engine, cache, repository),\n            scheduler: Scheduler::new(&scheduler_config),\n            metrics,\n        }\n    }\n\n    /// Executes a tool by its ID with the given JSON input.\n    ///\n    /// # Errors\n    /// Returns `RuntimeError::ToolNotFound` or `RuntimeError::PoolExhausted`.\n    #[tracing::instrument(skip(self, input), fields(tool_id = %tool_id))]\n    pub async fn execute(\n        &self,\n        tool_id: &ToolId,\n        input: &str,\n    ) -> Result<ExecutionResult, RuntimeError> {\n        info!(%tool_id, \"executing tool\");\n        self.metrics.record_attempt();\n\n        if self.resolver.cache().get(tool_id).await.is_some() {\n            self.metrics.record_cache_hit();\n        } else {\n            self.metrics.record_cache_miss();\n        }\n\n        let _permit = self\n            .scheduler\n            .acquire()\n            .await\n            .inspect_err(|_| self.metrics.record_failure())?;\n        let cached = self\n            .resolver\n            .resolve(tool_id)\n            .await\n            .inspect_err(|_| self.metrics.record_failure())?;\n\n        let result = self\n            .executor\n            .execute(&cached.component, input, &cached.security)\n            .await;\n\n        match &result {\n            Ok(r) => {\n                self.metrics.record_success(r.fuel_consumed);\n                info!(%tool_id, success = r.success, duration_ms = r.duration_ms,\n                    fuel = r.fuel_consumed, \"execution complete\");\n            }\n            Err(e) => {\n                self.metrics.record_failure();\n                warn!(%tool_id, error = %e, \"execution failed\");\n            }\n        }\n        result\n    }\n\n    /// Gracefully shuts down the runtime by draining all in-flight executions.\n    pub async fn shutdown(&self) {\n        self.scheduler.drain().await;\n        info!(\"runtime shutdown complete\");\n    }\n\n    /// Invalidates the component cache for a specific tool.\n    pub async fn invalidate_cache(&self, tool_id: &ToolId) {\n        self.resolver.invalidate(tool_id).await;\n    }\n\n    /// Returns a shared handle to the runtime execution metrics.\n    pub fn metrics(&self) -> Arc<ExecutionMetrics> {\n        self.metrics.clone()\n    }\n\n    pub fn resolver(&self) -> &ToolResolver {\n        &self.resolver\n    }\n\n    pub fn scheduler(&self) -> &Scheduler {\n        &self.scheduler\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":37,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":40,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":41,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":42,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":43,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":44,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":46,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":47,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":48,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":49,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":50,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":51,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":137,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":21,"coverable":34},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","pipeline.rs"],"content":"//! Multi-tool pipeline execution — chains tool outputs as inputs.\n//!\n//! A pipeline is an ordered sequence of steps where each step's output\n//! can feed into the next step's input via `input_from: \"previous\"`.\n\nuse serde::{Deserialize, Serialize};\n\nuse kami_types::ToolId;\n\n/// A single step in a pipeline.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineStep {\n    /// Tool to execute.\n    pub tool: ToolId,\n    /// Explicit JSON input (used if `input_from` is `None`).\n    #[serde(default)]\n    pub input: Option<serde_json::Value>,\n    /// Source of input: `\"previous\"` uses the prior step's output.\n    #[serde(default)]\n    pub input_from: Option<String>,\n}\n\n/// Definition of a multi-step pipeline.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineDefinition {\n    /// Ordered list of execution steps.\n    pub steps: Vec<PipelineStep>,\n}\n\n/// Result of a single pipeline step.\n#[derive(Debug, Clone)]\npub struct StepResult {\n    /// The tool that was executed.\n    pub tool: ToolId,\n    /// JSON output string.\n    pub output: String,\n    /// Whether execution succeeded.\n    pub success: bool,\n    /// Execution time in milliseconds.\n    pub duration_ms: u64,\n}\n\n/// Result of a complete pipeline execution.\n#[derive(Debug, Clone)]\npub struct PipelineResult {\n    /// Results for each step, in order.\n    pub steps: Vec<StepResult>,\n    /// Whether all steps completed successfully.\n    pub success: bool,\n}\n\n/// Errors specific to pipeline execution.\n#[derive(Debug, thiserror::Error)]\npub enum PipelineError {\n    /// The pipeline has no steps.\n    #[error(\"pipeline has no steps\")]\n    Empty,\n    /// A step references `input_from` but has no previous step.\n    #[error(\"step {index} uses input_from but is the first step\")]\n    NoPreviousStep { index: usize },\n    /// A step failed, halting the pipeline.\n    #[error(\"step {index} (tool '{tool}') failed: {reason}\")]\n    StepFailed {\n        index: usize,\n        tool: String,\n        reason: String,\n    },\n    /// Runtime error during execution.\n    #[error(\"runtime error at step {index}: {source}\")]\n    Runtime {\n        index: usize,\n        #[source]\n        source: crate::error::RuntimeError,\n    },\n}\n\n/// Executes a pipeline against the given runtime.\n///\n/// Runs steps sequentially. If a step sets `input_from: \"previous\"`,\n/// it receives the output of the prior step as its input.\n///\n/// # Errors\n/// Returns `PipelineError` if any step fails or the definition is invalid.\npub async fn execute_pipeline(\n    runtime: &crate::orchestrator::KamiRuntime,\n    definition: &PipelineDefinition,\n) -> Result<PipelineResult, PipelineError> {\n    if definition.steps.is_empty() {\n        return Err(PipelineError::Empty);\n    }\n    let mut results: Vec<StepResult> = Vec::with_capacity(definition.steps.len());\n\n    for (index, step) in definition.steps.iter().enumerate() {\n        let input = resolve_step_input(step, index, results.last())?;\n        let exec = runtime\n            .execute(&step.tool, &input)\n            .await\n            .map_err(|e| PipelineError::Runtime { index, source: e })?;\n        if !exec.success {\n            return Err(PipelineError::StepFailed {\n                index,\n                tool: step.tool.to_string(),\n                reason: exec.content.clone(),\n            });\n        }\n        results.push(StepResult {\n            tool: step.tool.clone(),\n            output: exec.content,\n            success: exec.success,\n            duration_ms: exec.duration_ms,\n        });\n    }\n\n    Ok(PipelineResult {\n        success: true,\n        steps: results,\n    })\n}\n\n/// Resolves the input for a step, either explicit or from previous output.\npub fn resolve_step_input(\n    step: &PipelineStep,\n    index: usize,\n    previous: Option<&StepResult>,\n) -> Result<String, PipelineError> {\n    if let Some(ref source) = step.input_from {\n        if source == \"previous\" {\n            let prev = previous.ok_or(PipelineError::NoPreviousStep { index })?;\n            return Ok(prev.output.clone());\n        }\n    }\n    match &step.input {\n        Some(v) => Ok(v.to_string()),\n        None => Ok(\"{}\".to_string()),\n    }\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":126,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":129,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":8,"coverable":31},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","pool.rs"],"content":"//! Instance pool for warm-start optimization.\n\n/// Configuration for the instance pool.\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    /// Maximum number of cached instances.\n    pub max_size: usize,\n}\n\nimpl Default for PoolConfig {\n    fn default() -> Self {\n        Self { max_size: 5 }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","rate_limiter.rs"],"content":"//! Token-bucket rate limiter for tool execution.\n//!\n//! Provides per-tool and global rate limits to prevent abuse.\n//! Uses an atomic token bucket that refills over a configurable window.\n\nuse std::collections::HashMap;\nuse std::sync::Mutex;\nuse std::time::{Duration, Instant};\n\nuse kami_types::ToolId;\n\n/// Configuration for the rate limiter.\n#[derive(Debug, Clone)]\npub struct RateLimitConfig {\n    /// Maximum requests per window per tool (0 = unlimited).\n    pub per_tool: u64,\n    /// Maximum global requests per window (0 = unlimited).\n    pub global: u64,\n    /// Sliding window duration.\n    pub window: Duration,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -> Self {\n        Self {\n            per_tool: 100,\n            global: 1000,\n            window: Duration::from_secs(60),\n        }\n    }\n}\n\n/// Token bucket for a single rate-limit counter.\n#[derive(Debug)]\nstruct TokenBucket {\n    tokens: u64,\n    capacity: u64,\n    last_refill: Instant,\n    window: Duration,\n}\n\nimpl TokenBucket {\n    fn new(capacity: u64, window: Duration) -> Self {\n        Self {\n            tokens: capacity,\n            capacity,\n            last_refill: Instant::now(),\n            window,\n        }\n    }\n\n    /// Tries to consume one token. Returns `true` if allowed.\n    fn try_acquire(&mut self) -> bool {\n        self.refill();\n        if self.tokens > 0 {\n            self.tokens -= 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    fn refill(&mut self) {\n        let elapsed = self.last_refill.elapsed();\n        if elapsed >= self.window {\n            self.tokens = self.capacity;\n            self.last_refill = Instant::now();\n        }\n    }\n}\n\n/// Rate limiter with per-tool and global limits.\n#[derive(Debug)]\npub struct RateLimiter {\n    config: RateLimitConfig,\n    global: Mutex<TokenBucket>,\n    per_tool: Mutex<HashMap<ToolId, TokenBucket>>,\n}\n\nimpl RateLimiter {\n    /// Creates a new rate limiter with the given configuration.\n    pub fn new(config: &RateLimitConfig) -> Self {\n        Self {\n            config: config.clone(),\n            global: Mutex::new(TokenBucket::new(config.global, config.window)),\n            per_tool: Mutex::new(HashMap::new()),\n        }\n    }\n\n    /// Checks if a request for the given tool is allowed.\n    ///\n    /// Returns `true` if the request is within both the per-tool and\n    /// global rate limits.\n    pub fn check(&self, tool_id: &ToolId) -> bool {\n        if self.config.global == 0 && self.config.per_tool == 0 {\n            return true;\n        }\n        if self.config.global > 0 {\n            let mut global = self.global.lock().unwrap_or_else(|e| e.into_inner());\n            if !global.try_acquire() {\n                return false;\n            }\n        }\n        if self.config.per_tool > 0 {\n            let mut map = self.per_tool.lock().unwrap_or_else(|e| e.into_inner());\n            let bucket = map\n                .entry(tool_id.clone())\n                .or_insert_with(|| TokenBucket::new(self.config.per_tool, self.config.window));\n            if !bucket.try_acquire() {\n                return false;\n            }\n        }\n        true\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":47,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":53,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":54,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":55,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":56,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":57,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":64,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":65,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":84,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":85,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":94,"address":[],"length":0,"stats":{"Line":17221764975064776704}},{"line":95,"address":[],"length":0,"stats":{"Line":15492382718154506243}},{"line":96,"address":[],"length":0,"stats":{"Line":16717361816799281155}},{"line":98,"address":[],"length":0,"stats":{"Line":504403158265495549}},{"line":99,"address":[],"length":0,"stats":{"Line":2017612633061982220}},{"line":100,"address":[],"length":0,"stats":{"Line":504403158265495555}},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927939}},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567610}},{"line":105,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":106,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":107,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":108,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":360287970189639674}}],"covered":32,"coverable":34},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","resolver.rs"],"content":"//! Tool resolution from registry to compiled component.\n//!\n//! Resolves a `ToolId` by looking it up in the registry, loading the\n//! WASM file, compiling it, and caching the result.\n\nuse std::path::Path;\nuse std::sync::Arc;\n\nuse tracing::{debug, info};\nuse wasmtime::Engine;\n\nuse kami_engine::load_component_from_file;\nuse kami_registry::ToolRepository;\nuse kami_types::ToolId;\n\nuse crate::cache::{CachedComponent, ComponentCache};\nuse crate::error::RuntimeError;\nuse crate::integrity;\n\n/// Resolves tools from the registry and compiles their WASM components.\n///\n/// Uses `ComponentCache` to avoid recompilation on subsequent calls.\npub struct ToolResolver {\n    engine: Engine,\n    cache: ComponentCache,\n    repository: Arc<dyn ToolRepository>,\n}\n\nimpl ToolResolver {\n    /// Creates a new resolver with the given engine, cache, and repository.\n    pub fn new(engine: Engine, cache: ComponentCache, repository: Arc<dyn ToolRepository>) -> Self {\n        Self {\n            engine,\n            cache,\n            repository,\n        }\n    }\n\n    /// Resolves a tool ID to a compiled component.\n    ///\n    /// Returns the cached component if available, otherwise loads from\n    /// the registry, compiles, and caches.\n    #[tracing::instrument(skip(self), fields(tool_id = %id))]\n    pub async fn resolve(&self, id: &ToolId) -> Result<CachedComponent, RuntimeError> {\n        // 1. Check cache first\n        if let Some(cached) = self.cache.get(id).await {\n            debug!(%id, \"cache hit\");\n            return Ok(cached);\n        }\n\n        // 2. Look up in registry\n        let tool = self\n            .repository\n            .find_by_id(id)\n            .await\n            .map_err(|e| RuntimeError::ToolNotFound {\n                name: format!(\"{id}: {e}\"),\n            })?\n            .ok_or_else(|| RuntimeError::ToolNotFound {\n                name: id.to_string(),\n            })?;\n\n        // 3. Resolve WASM file path\n        let wasm_path = Path::new(&tool.install_path).join(&tool.manifest.wasm);\n\n        if !wasm_path.exists() {\n            return Err(RuntimeError::ToolNotFound {\n                name: format!(\"WASM file missing: {}\", wasm_path.display()),\n            });\n        }\n\n        // 4. Verify WASM integrity (skipped if no hash stored at install time)\n        integrity::verify_hash(&wasm_path, &tool.manifest.wasm_sha256).map_err(|e| {\n            RuntimeError::IntegrityViolation {\n                tool_id: id.to_string(),\n                detail: e.to_string(),\n            }\n        })?;\n\n        info!(%id, path = %wasm_path.display(), \"compiling component\");\n\n        // 5. Compile the component\n        let component = load_component_from_file(&self.engine, &wasm_path)?;\n\n        // 6. Cache it\n        let cached = CachedComponent {\n            component,\n            security: tool.manifest.security.clone(),\n            wasm_path: wasm_path.display().to_string(),\n        };\n        self.cache.insert(id, cached.clone()).await;\n\n        Ok(cached)\n    }\n\n    /// Invalidates the cache for a specific tool.\n    pub async fn invalidate(&self, id: &ToolId) {\n        self.cache.invalidate(id).await;\n    }\n\n    /// Returns a reference to the component cache.\n    pub fn cache(&self) -> &ComponentCache {\n        &self.cache\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":44,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":11,"coverable":12},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","runtime_config.rs"],"content":"//! Configuration for the KAMI runtime.\n\n/// Configuration for the KAMI runtime.\n#[derive(Debug, Clone)]\npub struct RuntimeConfig {\n    /// Component cache size.\n    pub cache_size: usize,\n    /// Scheduler concurrency limit.\n    pub max_concurrent: usize,\n    /// Enable epoch interruption for timeout.\n    pub epoch_interruption: bool,\n}\n\nimpl Default for RuntimeConfig {\n    fn default() -> Self {\n        Self {\n            cache_size: 32,\n            max_concurrent: 4,\n            epoch_interruption: true,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn default_config_values() {\n        let cfg = RuntimeConfig::default();\n        assert_eq!(cfg.cache_size, 32);\n        assert_eq!(cfg.max_concurrent, 4);\n        assert!(cfg.epoch_interruption);\n    }\n\n    #[test]\n    fn config_is_cloneable() {\n        let cfg = RuntimeConfig {\n            cache_size: 64,\n            max_concurrent: 8,\n            epoch_interruption: false,\n        };\n        let copy = cfg.clone();\n        assert_eq!(copy.cache_size, 64);\n        assert!(!copy.epoch_interruption);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":1,"coverable":1},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","scheduler.rs"],"content":"//! Task scheduling with concurrency control and priorities.\n//!\n//! Uses a `tokio::sync::Semaphore` to limit concurrent WASM executions,\n//! preventing resource exhaustion on the host.\n\nuse std::sync::Arc;\n\nuse tokio::sync::Semaphore;\nuse tracing::debug;\n\n/// Task priority levels.\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord)]\npub enum Priority {\n    /// Low priority (background tasks).\n    Low = 0,\n    /// Normal priority (default).\n    #[default]\n    Normal = 1,\n    /// High priority (interactive).\n    High = 2,\n}\n\n/// Configuration for the task scheduler.\n#[derive(Debug, Clone)]\npub struct SchedulerConfig {\n    /// Maximum concurrent WASM executions.\n    pub max_concurrent: usize,\n}\n\nimpl Default for SchedulerConfig {\n    fn default() -> Self {\n        Self { max_concurrent: 4 }\n    }\n}\n\n/// Concurrency-limited task scheduler.\n///\n/// Wraps a semaphore to ensure at most `max_concurrent` WASM\n/// executions run simultaneously.\n#[derive(Clone)]\npub struct Scheduler {\n    semaphore: Arc<Semaphore>,\n    max_concurrent: usize,\n}\n\nimpl Scheduler {\n    /// Creates a new scheduler with the given config.\n    pub fn new(config: &SchedulerConfig) -> Self {\n        Self {\n            semaphore: Arc::new(Semaphore::new(config.max_concurrent)),\n            max_concurrent: config.max_concurrent,\n        }\n    }\n\n    /// Acquires a permit to execute a task.\n    ///\n    /// Blocks until a slot is available. Returns a guard that\n    /// releases the permit when dropped.\n    pub async fn acquire(&self) -> Result<SchedulerPermit, crate::error::RuntimeError> {\n        debug!(\n            available = self.semaphore.available_permits(),\n            max = self.max_concurrent,\n            \"acquiring scheduler permit\"\n        );\n\n        let permit = self\n            .semaphore\n            .clone()\n            .acquire_owned()\n            .await\n            .map_err(|_| crate::error::RuntimeError::PoolExhausted)?;\n\n        Ok(SchedulerPermit { _permit: permit })\n    }\n\n    /// Returns the number of available execution slots.\n    pub fn available_permits(&self) -> usize {\n        self.semaphore.available_permits()\n    }\n\n    /// Returns the maximum concurrency level.\n    pub fn max_concurrent(&self) -> usize {\n        self.max_concurrent\n    }\n\n    /// Drains the scheduler by waiting until all in-flight tasks finish.\n    ///\n    /// Acquires every permit — once all are held simultaneously, every\n    /// previously-issued permit has been released, meaning all executing\n    /// tasks have completed. Permits are dropped immediately after.\n    pub async fn drain(&self) {\n        let mut permits = Vec::with_capacity(self.max_concurrent);\n        for _ in 0..self.max_concurrent {\n            if let Ok(p) = self.semaphore.clone().acquire_owned().await {\n                permits.push(p);\n            }\n        }\n        // All in-flight executions are done; permits dropped here.\n    }\n}\n\n/// RAII guard that releases a scheduler permit when dropped.\npub struct SchedulerPermit {\n    _permit: tokio::sync::OwnedSemaphorePermit,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn scheduler_acquire_and_release() {\n        let scheduler = Scheduler::new(&SchedulerConfig { max_concurrent: 2 });\n\n        assert_eq!(scheduler.available_permits(), 2);\n\n        let _p1 = scheduler.acquire().await.expect(\"permit 1\");\n        assert_eq!(scheduler.available_permits(), 1);\n\n        let _p2 = scheduler.acquire().await.expect(\"permit 2\");\n        assert_eq!(scheduler.available_permits(), 0);\n\n        drop(_p1);\n        assert_eq!(scheduler.available_permits(), 1);\n    }\n\n    #[tokio::test]\n    async fn scheduler_blocks_at_capacity() {\n        let scheduler = Scheduler::new(&SchedulerConfig { max_concurrent: 1 });\n\n        let _p1 = scheduler.acquire().await.expect(\"permit\");\n        assert_eq!(scheduler.available_permits(), 0);\n\n        // Second acquire should block; use try_acquire to test\n        let try_result = scheduler.semaphore.clone().try_acquire_owned();\n        assert!(try_result.is_err(), \"should be at capacity\");\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":48,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":50,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":51,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":59,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":60,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":67,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":70,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":71,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":73,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":77,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":78,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":83,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":92,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":95,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":20,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","types.rs"],"content":"//! Shared types for tool execution results and the executor trait.\n\nuse async_trait::async_trait;\nuse wasmtime::component::Component;\n\nuse kami_types::SecurityConfig;\n\nuse crate::error::RuntimeError;\n\n/// Result of a tool execution.\n#[derive(Debug, Clone)]\npub struct ExecutionResult {\n    /// Output content from the tool.\n    pub content: String,\n    /// Execution duration in milliseconds.\n    pub duration_ms: u64,\n    /// Whether execution succeeded.\n    pub success: bool,\n    /// Fuel consumed during execution.\n    pub fuel_consumed: u64,\n}\n\n/// Trait for executing compiled WASM components.\n///\n/// Implementations apply the full isolation pipeline:\n/// sandbox, resource limits, epoch timeout.\n#[async_trait]\npub trait ToolExecutor: Send + Sync {\n    /// Executes a compiled component with the given input and security policy.\n    async fn execute(\n        &self,\n        component: &Component,\n        input: &str,\n        security: &SecurityConfig,\n    ) -> Result<ExecutionResult, RuntimeError>;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn execution_result_clone_preserves_fields() {\n        let r = ExecutionResult {\n            content: \"ok\".into(),\n            duration_ms: 42,\n            success: true,\n            fuel_consumed: 1000,\n        };\n        let c = r.clone();\n        assert_eq!(c.content, \"ok\");\n        assert_eq!(c.duration_ms, 42);\n        assert!(c.success);\n        assert_eq!(c.fuel_consumed, 1000);\n    }\n\n    #[test]\n    fn execution_result_debug_format() {\n        let r = ExecutionResult {\n            content: \"x\".into(),\n            duration_ms: 0,\n            success: false,\n            fuel_consumed: 0,\n        };\n        let dbg = format!(\"{r:?}\");\n        assert!(dbg.contains(\"ExecutionResult\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","capability.rs"],"content":"//! Capability checking trait and types.\n\nuse kami_types::{Capability, FsAccess, SecurityConfig};\n\nuse crate::error::SandboxError;\nuse crate::network::is_host_allowed;\n\n/// Trait for checking capabilities against a security config.\npub trait CapabilityChecker: Send + Sync {\n    /// Checks whether a capability is allowed by the security config.\n    fn check(&self, capability: &Capability, config: &SecurityConfig) -> Result<(), SandboxError>;\n}\n\n/// Default capability checker enforcing deny-all by default.\npub struct DefaultCapabilityChecker;\n\nimpl CapabilityChecker for DefaultCapabilityChecker {\n    fn check(&self, capability: &Capability, config: &SecurityConfig) -> Result<(), SandboxError> {\n        match capability {\n            Capability::Network(host) => {\n                if !is_host_allowed(host, &config.net_allow_list) {\n                    return Err(SandboxError::NetworkDenied { host: host.clone() });\n                }\n            }\n            Capability::FsRead(path) => {\n                if config.fs_access == FsAccess::None {\n                    return Err(SandboxError::FsDenied { path: path.clone() });\n                }\n            }\n            Capability::FsWrite(path) => {\n                if config.fs_access != FsAccess::Sandbox {\n                    return Err(SandboxError::FsDenied { path: path.clone() });\n                }\n            }\n            Capability::EnvVar(var) => {\n                if !config.env_allow_list.iter().any(|v| v == var) {\n                    return Err(SandboxError::CapabilityDenied {\n                        capability: format!(\"env:{var}\"),\n                    });\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n/// Validates a `SecurityConfig` for well-formedness before use.\n///\n/// Catches misconfigurations early rather than at execution time.\npub fn validate_security_config(config: &SecurityConfig) -> Result<(), SandboxError> {\n    // Validate network patterns\n    crate::network::validate_allow_list(&config.net_allow_list)\n        .map_err(|reason| SandboxError::InvalidConfig { reason })?;\n\n    // Validate resource limits\n    if config.limits.max_fuel == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_fuel must be > 0\".to_string(),\n        });\n    }\n    if config.limits.max_memory_mb == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_memory_mb must be > 0\".to_string(),\n        });\n    }\n    if config.limits.max_execution_ms == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_execution_ms must be > 0\".to_string(),\n        });\n    }\n\n    Ok(())\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":19,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":21,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":52,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":53,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":56,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":504403158265495552}}],"covered":29,"coverable":29},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","error.rs"],"content":"//! Sandbox-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the sandbox layer.\n#[derive(Debug, Error)]\npub enum SandboxError {\n    /// A required capability was not granted.\n    #[error(\"capability denied: {capability}\")]\n    CapabilityDenied { capability: String },\n    /// Network access denied.\n    #[error(\"network access denied for host: {host}\")]\n    NetworkDenied { host: String },\n    /// Filesystem access denied.\n    #[error(\"filesystem access denied: {path}\")]\n    FsDenied { path: String },\n    /// WASI context build failure.\n    #[error(\"failed to build WASI context: {reason}\")]\n    WasiBuild { reason: String },\n    /// Invalid security configuration.\n    #[error(\"invalid security config: {reason}\")]\n    InvalidConfig { reason: String },\n}\n\nimpl From<SandboxError> for KamiError {\n    fn from(e: SandboxError) -> Self {\n        let kind = match &e {\n            SandboxError::CapabilityDenied { .. }\n            | SandboxError::NetworkDenied { .. }\n            | SandboxError::FsDenied { .. } => ErrorKind::PermissionDenied,\n            SandboxError::WasiBuild { .. } => ErrorKind::Internal,\n            SandboxError::InvalidConfig { .. } => ErrorKind::InvalidInput,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for SandboxError {\n    fn hint(&self) -> Option<String> {\n        match self {\n            Self::CapabilityDenied { capability } => Some(format!(\n                \"The tool requires the '{capability}' capability but it was not granted.\"\n            )),\n            Self::NetworkDenied { host } => Some(format!(\n                \"The tool tried to connect to '{host}' but network access is denied.\"\n            )),\n            Self::FsDenied { path } => Some(format!(\n                \"The tool tried to access '{path}' outside its sandbox.\"\n            )),\n            Self::InvalidConfig { .. } => {\n                Some(\"The security configuration in tool.toml has invalid values.\".into())\n            }\n            Self::WasiBuild { .. } => None,\n        }\n    }\n\n    fn fix(&self) -> Option<String> {\n        match self {\n            Self::NetworkDenied { host } => Some(format!(\n                \"Add to tool.toml:\\n  [security]\\n  net_allow_list = [\\\"{host}\\\"]\"\n            )),\n            Self::FsDenied { .. } => Some(\n                \"Set fs_access in tool.toml:\\n  [security]\\n  fs_access = \\\"read-only\\\"\".into(),\n            ),\n            Self::CapabilityDenied { .. } => {\n                Some(\"Grant the required capability in tool.toml [security] section.\".into())\n            }\n            _ => None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn capability_denied_maps_to_permission_denied() {\n        let err: KamiError = SandboxError::CapabilityDenied {\n            capability: \"net\".into(),\n        }\n        .into();\n        assert_eq!(err.kind, ErrorKind::PermissionDenied);\n    }\n\n    #[test]\n    fn network_denied_has_hint_with_host() {\n        let e = SandboxError::NetworkDenied {\n            host: \"evil.com\".into(),\n        };\n        let hint = e.hint().expect(\"has hint\");\n        assert!(hint.contains(\"evil.com\"));\n    }\n\n    #[test]\n    fn network_denied_has_fix_with_toml() {\n        let e = SandboxError::NetworkDenied {\n            host: \"api.x.com\".into(),\n        };\n        let fix = e.fix().expect(\"has fix\");\n        assert!(fix.contains(\"net_allow_list\"));\n        assert!(fix.contains(\"api.x.com\"));\n    }\n\n    #[test]\n    fn fs_denied_maps_to_permission_denied() {\n        let err: KamiError = SandboxError::FsDenied {\n            path: \"/etc\".into(),\n        }\n        .into();\n        assert_eq!(err.kind, ErrorKind::PermissionDenied);\n    }\n\n    #[test]\n    fn invalid_config_maps_to_invalid_input() {\n        let err: KamiError = SandboxError::InvalidConfig {\n            reason: \"bad\".into(),\n        }\n        .into();\n        assert_eq!(err.kind, ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn wasi_build_has_no_fix() {\n        let e = SandboxError::WasiBuild {\n            reason: \"oom\".into(),\n        };\n        assert!(e.fix().is_none());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":40,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":49,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":59,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":23,"coverable":23},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","filesystem.rs"],"content":"//! Filesystem jail for sandboxed tool execution.\n//!\n//! Three-layer defence: reject absolute paths, reject `..` components,\n//! then verify via canonicalization that the resolved path stays within the\n//! jail root (anti-symlink).\n\nuse std::path::{Component, Path, PathBuf};\n\nuse crate::error::SandboxError;\n\n/// Filesystem jail constraining tool access to a specific directory.\n#[derive(Debug, Clone)]\npub struct FsJail {\n    /// Root directory of the jail (NOT pre-canonicalized — done lazily).\n    root: PathBuf,\n}\n\nimpl FsJail {\n    /// Creates a new filesystem jail rooted at the given path.\n    pub fn new(root: impl Into<PathBuf>) -> Self {\n        Self { root: root.into() }\n    }\n\n    /// Validates that `path` is safe and lies within the jail.\n    ///\n    /// # Errors\n    ///\n    /// Returns `SandboxError::FsDenied` if:\n    /// - `path` is absolute\n    /// - `path` contains `..` components (traversal attempt)\n    /// - The resolved path escapes the jail root (symlink escape)\n    pub fn validate_path(&self, path: &Path) -> Result<PathBuf, SandboxError> {\n        // 1. Reject absolute/rooted paths — only relative paths allowed.\n        //    `has_root()` catches Unix-style `/foo` on Windows where\n        //    `is_absolute()` requires a drive-letter prefix (e.g. `C:\\`).\n        if path.has_root() || path.is_absolute() {\n            return Err(SandboxError::FsDenied {\n                path: path.display().to_string(),\n            });\n        }\n\n        // 2. Reject any \"..\" component — no parent-dir traversal\n        for component in path.components() {\n            if matches!(component, Component::ParentDir) {\n                return Err(SandboxError::FsDenied {\n                    path: path.display().to_string(),\n                });\n            }\n        }\n\n        // 3. Build the full path within the jail\n        let full_path = self.root.join(path);\n\n        // 4. If the path exists, canonicalize both sides and verify containment\n        //    (protects against symlinks pointing outside the jail)\n        if full_path.exists() {\n            let canonical_root = self\n                .root\n                .canonicalize()\n                .map_err(|e| SandboxError::FsDenied {\n                    path: format!(\"cannot canonicalize root '{}': {e}\", self.root.display()),\n                })?;\n\n            let real_path = full_path\n                .canonicalize()\n                .map_err(|e| SandboxError::FsDenied {\n                    path: format!(\"cannot canonicalize '{}': {e}\", full_path.display()),\n                })?;\n\n            if !real_path.starts_with(&canonical_root) {\n                return Err(SandboxError::FsDenied {\n                    path: path.display().to_string(),\n                });\n            }\n        }\n\n        Ok(full_path)\n    }\n\n    /// Returns the jail root.\n    pub fn root(&self) -> &Path {\n        &self.root\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_path_within_jail() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/output.txt\"));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn reject_parent_traversal() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"../../../etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn reject_embedded_parent() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/../../etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn reject_absolute_path() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"/etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn accept_nested_valid_path() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/subdir/file.txt\"));\n        assert!(result.is_ok());\n        let full = result.unwrap();\n        assert!(full.starts_with(\"/sandbox/tool1\"));\n    }\n\n    #[test]\n    fn reject_single_dot_dot() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"..\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":21,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":32,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":36,"address":[],"length":0,"stats":{"Line":4611686018427387896}},{"line":37,"address":[],"length":0,"stats":{"Line":8791026472627208197}},{"line":38,"address":[],"length":0,"stats":{"Line":8791026472627208197}},{"line":43,"address":[],"length":0,"stats":{"Line":12177733392409821174}},{"line":44,"address":[],"length":0,"stats":{"Line":13907115649320091652}},{"line":45,"address":[],"length":0,"stats":{"Line":4971973988617027576}},{"line":46,"address":[],"length":0,"stats":{"Line":4971973988617027576}},{"line":52,"address":[],"length":0,"stats":{"Line":10736581511651262464}},{"line":56,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":23,"coverable":25},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","lib.rs"],"content":"//! # kami-sandbox\n//!\n//! Isolation and security enforcement for WASM tool execution.\n//! Implements capability-based security with deny-all defaults.\n//!\n//! Produces a `WasiCtx` that enforces network allow-lists,\n//! filesystem jailing, and resource limits.\n\npub mod capability;\npub mod error;\npub mod filesystem;\npub mod network;\npub mod wasi;\n\npub use capability::{validate_security_config, CapabilityChecker, DefaultCapabilityChecker};\npub use error::SandboxError;\npub use filesystem::FsJail;\npub use wasi::{build_wasi_ctx, WasiConfig};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","network.rs"],"content":"//! Network allow-list enforcement.\n//!\n//! Supports hostname patterns AND explicit IP addresses.\n//! Direct IP connections are blocked by default unless the IP is explicitly\n//! listed — this prevents bypassing hostname-based allow-lists.\n\nuse std::net::IpAddr;\nuse std::net::SocketAddr;\n\n/// Checks if a socket address is permitted by the allow list.\n///\n/// The allow list supports:\n/// - Exact hostnames: `\"api.github.com\"`\n/// - Wildcard hostnames: `\"*.example.com\"`\n/// - Explicit IPv4/IPv6 addresses: `\"93.184.216.34\"`\n///\n/// **Security:** Raw IP connections only succeed if the IP is explicitly\n/// listed. Hostnames are checked separately by `is_host_allowed`.\n/// This prevents bypassing hostname allow-lists via direct IP connections.\npub fn is_addr_allowed(addr: &SocketAddr, allow_list: &[String]) -> bool {\n    let ip = addr.ip();\n    let ip_str = ip.to_string();\n\n    allow_list.iter().any(|pattern| {\n        // Explicit IP match (e.g. \"93.184.216.34\" or \"::1\")\n        if let Ok(allowed_ip) = pattern.parse::<IpAddr>() {\n            return ip == allowed_ip;\n        }\n        // Hostname pattern — IP strings never match hostname patterns\n        // (prevents \"*.example.com\" from matching \"93.184.216.34\")\n        is_ip_str_matching_hostname_pattern(&ip_str, pattern)\n    })\n}\n\n/// Checks if a hostname string matches any pattern in the allow list.\n///\n/// Supports:\n/// - Exact matches: `\"api.github.com\"`\n/// - Wildcard subdomain: `\"*.example.com\"` (matches `sub.example.com`)\npub fn is_host_allowed(host: &str, allow_list: &[String]) -> bool {\n    allow_list.iter().any(|pattern| {\n        if let Some(suffix) = pattern.strip_prefix(\"*.\") {\n            host == suffix || host.ends_with(&format!(\".{suffix}\"))\n        } else {\n            host == pattern\n        }\n    })\n}\n\n/// Returns false for IP strings against hostname patterns.\n///\n/// An IP address string (e.g. `\"93.184.216.34\"`) can never match a hostname\n/// pattern (e.g. `\"*.example.com\"` or `\"api.github.com\"`). This function\n/// enforces that separation to prevent IP-based bypasses.\nfn is_ip_str_matching_hostname_pattern(ip_str: &str, pattern: &str) -> bool {\n    // Only allow if the pattern IS a literal IP that matches exactly\n    // (already handled above via IpAddr parse). For hostname patterns,\n    // an IP string should never match.\n    ip_str == pattern\n}\n\n/// Validates that all entries in a network allow list are well-formed.\n///\n/// # Errors\n///\n/// Returns an error string if any pattern is empty or a malformed wildcard.\npub fn validate_allow_list(patterns: &[String]) -> Result<(), String> {\n    for pattern in patterns {\n        if pattern.is_empty() {\n            return Err(\"empty pattern in network allow list\".to_string());\n        }\n        if pattern.starts_with(\"*.\") && pattern.len() <= 2 {\n            return Err(format!(\"invalid wildcard pattern: {pattern}\"));\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":21,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":22,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":24,"address":[],"length":0,"stats":{"Line":1585267068834414593}},{"line":26,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711743}},{"line":31,"address":[],"length":0,"stats":{"Line":864691128455135238}},{"line":40,"address":[],"length":0,"stats":{"Line":1080863910568919042}},{"line":41,"address":[],"length":0,"stats":{"Line":3242591731706757125}},{"line":42,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":43,"address":[],"length":0,"stats":{"Line":2666130979403333625}},{"line":45,"address":[],"length":0,"stats":{"Line":360287970189639682}},{"line":55,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":67,"address":[],"length":0,"stats":{"Line":1369094286720630787}},{"line":68,"address":[],"length":0,"stats":{"Line":1945555039024054275}},{"line":69,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927939}},{"line":76,"address":[],"length":0,"stats":{"Line":1080863910568919040}}],"covered":21,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","wasi.rs"],"content":"//! WASI context builder for sandboxed execution.\n//!\n//! Builds a `WasiCtx` from a `SecurityConfig`, enforcing deny-all defaults\n//! and granular permissions for network and filesystem access.\n\nuse std::sync::Arc;\n\nuse kami_types::{FsAccess, SecurityConfig};\nuse wasmtime_wasi::{DirPerms, FilePerms, WasiCtx, WasiCtxBuilder};\n\nuse crate::error::SandboxError;\nuse crate::network::is_addr_allowed;\n\n/// Options controlling WASI context construction.\n#[derive(Debug, Clone, Default)]\npub struct WasiConfig {\n    /// Whether to inherit stdout (useful for CLI tools).\n    pub inherit_stdout: bool,\n    /// Whether to inherit stderr (useful for debugging).\n    pub inherit_stderr: bool,\n    /// Extra environment variables to expose.\n    pub env_vars: Vec<(String, String)>,\n}\n\n/// Builds a `WasiCtx` from a `SecurityConfig` and optional overrides.\n///\n/// Enforces:\n/// - Network: deny-all unless hosts match `net_allow_list` patterns\n/// - Filesystem: deny-all / read-only / sandbox based on `fs_access`\n/// - Env vars: only explicit vars from `wasi_config`\n/// - DNS: disabled unless network is allowed\npub fn build_wasi_ctx(\n    security: &SecurityConfig,\n    wasi_config: &WasiConfig,\n    sandbox_dir: Option<&str>,\n) -> Result<WasiCtx, SandboxError> {\n    let mut builder = WasiCtxBuilder::new();\n\n    // -- stdio --\n    if wasi_config.inherit_stdout {\n        builder.inherit_stdout();\n    }\n    if wasi_config.inherit_stderr {\n        builder.inherit_stderr();\n    }\n\n    // -- environment variables (filtered by env_allow_list) --\n    // If env_allow_list is non-empty, only listed vars are exposed.\n    // If env_allow_list is empty, all explicitly provided vars are allowed.\n    for (key, value) in &wasi_config.env_vars {\n        if !security.env_allow_list.is_empty() && !security.env_allow_list.contains(key) {\n            tracing::warn!(\n                key = %key,\n                \"env var blocked by allow-list\"\n            );\n            continue;\n        }\n        builder.env(key, value);\n    }\n\n    // -- filesystem --\n    configure_filesystem(&mut builder, security, sandbox_dir)?;\n\n    // -- network --\n    configure_network(&mut builder, security);\n\n    Ok(builder.build())\n}\n\n/// Configures filesystem access based on security policy.\nfn configure_filesystem(\n    builder: &mut WasiCtxBuilder,\n    security: &SecurityConfig,\n    sandbox_dir: Option<&str>,\n) -> Result<(), SandboxError> {\n    match security.fs_access {\n        FsAccess::None => {\n            // No filesystem access - nothing to configure\n        }\n        FsAccess::ReadOnly => {\n            if let Some(dir) = sandbox_dir {\n                builder\n                    .preopened_dir(dir, \".\", DirPerms::READ, FilePerms::READ)\n                    .map_err(|e| SandboxError::WasiBuild {\n                        reason: format!(\"failed to preopen read-only dir: {e}\"),\n                    })?;\n            }\n        }\n        FsAccess::Sandbox => {\n            if let Some(dir) = sandbox_dir {\n                builder\n                    .preopened_dir(dir, \".\", DirPerms::all(), FilePerms::all())\n                    .map_err(|e| SandboxError::WasiBuild {\n                        reason: format!(\"failed to preopen sandbox dir: {e}\"),\n                    })?;\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Configures network access using `socket_addr_check` for granular control.\nfn configure_network(builder: &mut WasiCtxBuilder, security: &SecurityConfig) {\n    let allow_list = security.net_allow_list.clone();\n    let has_network = !allow_list.is_empty();\n\n    if has_network {\n        let patterns = Arc::new(allow_list);\n        builder.socket_addr_check(move |addr, _addr_use| {\n            let patterns = Arc::clone(&patterns);\n            Box::pin(async move {\n                // Use is_addr_allowed: direct IP connections require explicit\n                // IP in the allow list — hostname patterns do not match IPs.\n                is_addr_allowed(&addr, &patterns)\n            })\n        });\n        builder.allow_ip_name_lookup(true);\n    }\n    // If no allow_list: network is deny-all by default (no inherit_network)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_types::SecurityConfig;\n\n    #[test]\n    fn default_security_produces_ctx() {\n        let security = SecurityConfig::default();\n        let wasi_config = WasiConfig::default();\n        let ctx = build_wasi_ctx(&security, &wasi_config, None);\n        assert!(ctx.is_ok());\n    }\n\n    #[test]\n    fn ctx_with_stdout_and_env() {\n        let security = SecurityConfig::default();\n        let wasi_config = WasiConfig {\n            inherit_stdout: true,\n            inherit_stderr: true,\n            env_vars: vec![(\"LANG\".to_string(), \"en_US\".to_string())],\n        };\n        let ctx = build_wasi_ctx(&security, &wasi_config, None);\n        assert!(ctx.is_ok());\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":37,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":40,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":41,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":43,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":44,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":50,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":51,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":62,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":65,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":67,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":71,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":76,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":77,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":103,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":104,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":105,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":107,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":108,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":109,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":27,"coverable":38},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","lib.rs"],"content":"//! # kami-store-sqlite\n//!\n//! SQLite adapter for the KAMI tool registry.\n//! Implements `ToolRepository` with full CRUD operations.\n\npub mod migrations;\nmod query_builder;\npub mod repository;\nmod repository_impl;\nmod row_mapping;\n\npub use repository::SqliteToolRepository;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","migrations.rs"],"content":"//! Database schema migrations for the tool registry.\n\nuse kami_registry::RepositoryError;\nuse rusqlite::Connection;\n\n/// Current schema version.\nconst SCHEMA_VERSION: u32 = 3;\n\n/// Runs all pending migrations on the database.\npub fn run_migrations(conn: &Connection) -> Result<(), RepositoryError> {\n    let current = get_schema_version(conn)?;\n\n    if current < 1 {\n        migrate_v1(conn)?;\n    }\n    if current < 2 {\n        migrate_v2(conn)?;\n    }\n    if current < 3 {\n        migrate_v3(conn)?;\n    }\n\n    set_schema_version(conn, SCHEMA_VERSION)?;\n    Ok(())\n}\n\n/// Adds the `wasm_sha256` column for WASM integrity verification (v2).\nfn migrate_v2(conn: &Connection) -> Result<(), RepositoryError> {\n    conn.execute_batch(\"ALTER TABLE tools ADD COLUMN wasm_sha256 TEXT;\")\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"migration v2 failed: {e}\"),\n        })\n}\n\n/// Adds versioning columns for update & pin support (v3).\nfn migrate_v3(conn: &Connection) -> Result<(), RepositoryError> {\n    conn.execute_batch(\n        \"ALTER TABLE tools ADD COLUMN pinned_version TEXT;\n         ALTER TABLE tools ADD COLUMN updated_at TEXT;\",\n    )\n    .map_err(|e| RepositoryError::Storage {\n        message: format!(\"migration v3 failed: {e}\"),\n    })\n}\n\n/// Creates the initial schema (v1).\nfn migrate_v1(conn: &Connection) -> Result<(), RepositoryError> {\n    conn.execute_batch(\n        \"CREATE TABLE IF NOT EXISTS tools (\n            id          TEXT PRIMARY KEY NOT NULL,\n            name        TEXT NOT NULL,\n            version     TEXT NOT NULL,\n            description TEXT NOT NULL DEFAULT '',\n            wasm_path   TEXT NOT NULL,\n            install_path TEXT NOT NULL,\n            enabled     INTEGER NOT NULL DEFAULT 1,\n            security    TEXT NOT NULL DEFAULT '{}',\n            arguments   TEXT NOT NULL DEFAULT '[]',\n            installed_at TEXT NOT NULL DEFAULT (datetime('now'))\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_tools_name ON tools(name);\n        CREATE INDEX IF NOT EXISTS idx_tools_enabled ON tools(enabled);\",\n    )\n    .map_err(|e| RepositoryError::Storage {\n        message: format!(\"migration v1 failed: {e}\"),\n    })\n}\n\n/// Reads the current schema version from PRAGMA user_version.\nfn get_schema_version(conn: &Connection) -> Result<u32, RepositoryError> {\n    conn.query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"failed to read schema version: {e}\"),\n        })\n}\n\n/// Sets the schema version via PRAGMA user_version.\nfn set_schema_version(conn: &Connection, version: u32) -> Result<(), RepositoryError> {\n    conn.pragma_update(None, \"user_version\", version)\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"failed to set schema version: {e}\"),\n        })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn migrations_run_on_fresh_db() {\n        let conn = Connection::open_in_memory().expect(\"in-memory db\");\n        run_migrations(&conn).expect(\"migrations should succeed\");\n\n        let version = get_schema_version(&conn).expect(\"version\");\n        assert_eq!(version, SCHEMA_VERSION);\n    }\n\n    #[test]\n    fn migrations_are_idempotent() {\n        let conn = Connection::open_in_memory().expect(\"in-memory db\");\n        run_migrations(&conn).expect(\"first run\");\n        run_migrations(&conn).expect(\"second run should also succeed\");\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":11,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":13,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":14,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":16,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":17,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":19,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":20,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":23,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":24,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":28,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":29,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":30,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":37,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":41,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":48,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":65,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":72,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":73,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":80,"address":[],"length":0,"stats":{"Line":11889503016258109440}},{"line":81,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":25,"coverable":30},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","query_builder.rs"],"content":"//! SQL query builder for `find_all` operations.\r\n\r\nuse kami_registry::ToolQuery;\r\n\r\nuse crate::repository_impl::COLS;\r\n\r\n/// Builds the SQL and parameters for `find_all`.\r\npub(crate) fn build_find_all_query(\r\n    query: &ToolQuery,\r\n) -> (String, Vec<Box<dyn rusqlite::types::ToSql>>) {\r\n    let mut sql = format!(\"SELECT {COLS} FROM tools WHERE 1=1\");\r\n    let mut params: Vec<Box<dyn rusqlite::types::ToSql>> = Vec::new();\r\n    if query.enabled_only {\r\n        sql.push_str(\" AND enabled = 1\");\r\n    }\r\n    if let Some(ref name) = query.name_filter {\r\n        sql.push_str(\" AND name LIKE ?\");\r\n        params.push(Box::new(format!(\"%{name}%\")));\r\n    }\r\n    sql.push_str(\" ORDER BY name ASC\");\r\n    if let Some(limit) = query.limit {\r\n        sql.push_str(\" LIMIT ?\");\r\n        params.push(Box::new(limit as i64));\r\n    }\r\n    if let Some(offset) = query.offset {\r\n        sql.push_str(\" OFFSET ?\");\r\n        params.push(Box::new(offset as i64));\r\n    }\r\n    (sql, params)\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":11,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":11,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","repository.rs"],"content":"//! SQLite implementation of `ToolRepository` — struct and constructors.\n\nuse std::sync::Mutex;\n\nuse kami_registry::RepositoryError;\nuse rusqlite::Connection;\n\nuse crate::migrations::run_migrations;\n\n/// SQLite-backed tool repository.\npub struct SqliteToolRepository {\n    pub(crate) conn: Mutex<Connection>,\n}\n\nimpl SqliteToolRepository {\n    /// Opens or creates a SQLite database at the given path and runs\n    /// migrations.\n    pub fn open(path: &str) -> Result<Self, RepositoryError> {\n        let conn = Connection::open(path).map_err(|e| RepositoryError::Storage {\n            message: e.to_string(),\n        })?;\n        run_migrations(&conn)?;\n        Ok(Self {\n            conn: Mutex::new(conn),\n        })\n    }\n\n    /// Opens an in-memory database (for testing).\n    pub fn open_in_memory() -> Result<Self, RepositoryError> {\n        let conn = Connection::open_in_memory().map_err(|e| RepositoryError::Storage {\n            message: e.to_string(),\n        })?;\n        run_migrations(&conn)?;\n        Ok(Self {\n            conn: Mutex::new(conn),\n        })\n    }\n\n    /// Acquires the connection lock.\n    pub(crate) fn lock_conn(\n        &self,\n    ) -> Result<std::sync::MutexGuard<'_, Connection>, RepositoryError> {\n        self.conn.lock().map_err(|e| RepositoryError::Storage {\n            message: format!(\"lock poisoned: {e}\"),\n        })\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":30,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":34,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":35,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":40,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":43,"address":[],"length":0,"stats":{"Line":8430738502437568512}},{"line":44,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","repository_impl.rs"],"content":"//! `ToolRepository` trait implementation for `SqliteToolRepository`.\n\nuse async_trait::async_trait;\nuse kami_registry::{RepositoryError, ToolQuery, ToolRepository};\nuse kami_types::{Tool, ToolId};\nuse rusqlite::params;\n\nuse crate::query_builder::build_find_all_query;\nuse crate::repository::SqliteToolRepository;\nuse crate::row_mapping::{row_to_tool, OptionalExt};\n\n/// Column list shared across all SELECT and UPDATE queries.\npub(crate) const COLS: &str = \"\\\n    id, name, version, description, wasm_path, \\\n    install_path, enabled, security, arguments, wasm_sha256, \\\n    pinned_version, updated_at\";\n\n/// Maps a `rusqlite::Error` to a `RepositoryError::Storage`.\nfn map_sqlite_err(e: rusqlite::Error) -> RepositoryError {\n    RepositoryError::Storage {\n        message: e.to_string(),\n    }\n}\n\n#[async_trait]\nimpl ToolRepository for SqliteToolRepository {\n    async fn find_by_id(&self, id: &ToolId) -> Result<Option<Tool>, RepositoryError> {\n        let conn = self.lock_conn()?;\n        let sql = format!(\"SELECT {COLS} FROM tools WHERE id = ?1\");\n        let mut stmt = conn.prepare(&sql).map_err(map_sqlite_err)?;\n        let result = stmt\n            .query_row(params![id.as_str()], row_to_tool)\n            .optional()\n            .map_err(map_sqlite_err)?;\n        Ok(result)\n    }\n\n    async fn find_all(&self, query: ToolQuery) -> Result<Vec<Tool>, RepositoryError> {\n        let conn = self.lock_conn()?;\n        let (sql, param_values) = build_find_all_query(&query);\n        let mut stmt = conn.prepare(&sql).map_err(map_sqlite_err)?;\n        let params_refs: Vec<&dyn rusqlite::types::ToSql> =\n            param_values.iter().map(|p| p.as_ref()).collect();\n        let tools = stmt\n            .query_map(params_refs.as_slice(), row_to_tool)\n            .map_err(map_sqlite_err)?\n            .collect::<Result<Vec<_>, _>>()\n            .map_err(map_sqlite_err)?;\n        Ok(tools)\n    }\n\n    async fn insert(&self, tool: &Tool) -> Result<(), RepositoryError> {\n        let conn = self.lock_conn()?;\n        let m = &tool.manifest;\n        let security_json =\n            serde_json::to_string(&m.security).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize security: {e}\"),\n            })?;\n        let args_json =\n            serde_json::to_string(&m.arguments).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize arguments: {e}\"),\n            })?;\n        conn.execute(\n            \"INSERT INTO tools (id, name, version, description, wasm_path, \\\n             install_path, enabled, security, arguments, wasm_sha256) \\\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\",\n            params![\n                m.id.as_str(),\n                m.name,\n                m.version.to_string(),\n                m.description,\n                m.wasm,\n                tool.install_path,\n                tool.enabled as i32,\n                security_json,\n                args_json,\n                m.wasm_sha256,\n            ],\n        )\n        .map_err(|e| {\n            if let rusqlite::Error::SqliteFailure(ref err, _) = e {\n                if err.code == rusqlite::ErrorCode::ConstraintViolation {\n                    return RepositoryError::Conflict {\n                        message: format!(\"tool already exists: {}\", m.id),\n                    };\n                }\n            }\n            RepositoryError::Storage {\n                message: e.to_string(),\n            }\n        })?;\n        Ok(())\n    }\n\n    async fn update(&self, tool: &Tool) -> Result<(), RepositoryError> {\n        let conn = self.lock_conn()?;\n        let m = &tool.manifest;\n        let security_json =\n            serde_json::to_string(&m.security).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize security: {e}\"),\n            })?;\n        let args_json =\n            serde_json::to_string(&m.arguments).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize arguments: {e}\"),\n            })?;\n        let affected = conn\n            .execute(\n                \"UPDATE tools SET name=?2, version=?3, description=?4, wasm_path=?5, \\\n                 install_path=?6, enabled=?7, security=?8, arguments=?9, wasm_sha256=?10, \\\n                 pinned_version=?11, updated_at=?12 WHERE id=?1\",\n                params![\n                    m.id.as_str(),\n                    m.name,\n                    m.version.to_string(),\n                    m.description,\n                    m.wasm,\n                    tool.install_path,\n                    tool.enabled as i32,\n                    security_json,\n                    args_json,\n                    m.wasm_sha256,\n                    tool.pinned_version,\n                    tool.updated_at,\n                ],\n            )\n            .map_err(map_sqlite_err)?;\n        if affected == 0 {\n            return Err(RepositoryError::NotFound {\n                id: m.id.to_string(),\n            });\n        }\n        Ok(())\n    }\n\n    async fn delete(&self, id: &ToolId) -> Result<bool, RepositoryError> {\n        let conn = self.lock_conn()?;\n        let affected = conn\n            .execute(\"DELETE FROM tools WHERE id = ?1\", params![id.as_str()])\n            .map_err(map_sqlite_err)?;\n        Ok(affected > 0)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":11,"coverable":19},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","row_mapping.rs"],"content":"//! Row-to-domain mapping for the SQLite tool repository.\n//!\n//! Converts raw SQLite rows into `Tool` domain objects and provides\n//! the `OptionalExt` helper for query results.\n\nuse kami_types::{SecurityConfig, Tool, ToolArgument, ToolId, ToolManifest, ToolVersion};\n\n/// Maps a SQLite row to a `Tool` domain object.\npub(crate) fn row_to_tool(row: &rusqlite::Row<'_>) -> rusqlite::Result<Tool> {\n    let id_str: String = row.get(0)?;\n    let name: String = row.get(1)?;\n    let version_str: String = row.get(2)?;\n    let description: String = row.get(3)?;\n    let wasm_path: String = row.get(4)?;\n    let install_path: String = row.get(5)?;\n    let enabled: bool = row.get(6)?;\n    let security_json: String = row.get(7)?;\n    let args_json: String = row.get(8)?;\n    let wasm_sha256: Option<String> = row.get(9)?;\n    let pinned_version: Option<String> = row.get(10)?;\n    let updated_at: Option<String> = row.get(11)?;\n\n    let id = ToolId::new(id_str).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(0, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    let version: ToolVersion = version_str.parse().map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(2, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    // Propagate parse errors rather than silently falling back to defaults.\n    // A corrupt JSON column should surface as a repository error, not a\n    // silent permission downgrade.\n    let security: SecurityConfig = serde_json::from_str(&security_json).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(7, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    let arguments: Vec<ToolArgument> = serde_json::from_str(&args_json).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(8, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    Ok(Tool {\n        manifest: ToolManifest {\n            id,\n            name,\n            version,\n            wasm: wasm_path,\n            description,\n            arguments,\n            security,\n            wasm_sha256,\n        },\n        install_path,\n        enabled,\n        pinned_version,\n        updated_at,\n    })\n}\n\n/// Extension trait for optional query results.\npub(crate) trait OptionalExt<T> {\n    /// Converts a \"no rows\" error into `Ok(None)`.\n    fn optional(self) -> Result<Option<T>, rusqlite::Error>;\n}\n\nimpl<T> OptionalExt<T> for Result<T, rusqlite::Error> {\n    fn optional(self) -> Result<Option<T>, rusqlite::Error> {\n        match self {\n            Ok(val) => Ok(Some(val)),\n            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),\n            Err(e) => Err(e),\n        }\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":10,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":11,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":12,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":13,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":14,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":15,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":16,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":17,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":18,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":19,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":20,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":21,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":23,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":43,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":44,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":45,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":46,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":47,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":48,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":49,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":50,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":51,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":53,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":54,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":55,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":56,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":67,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":68,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":69,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":70,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","auth.rs"],"content":"//! Bearer token authentication for MCP HTTP requests.\n\nuse axum::http::{header, HeaderMap, StatusCode};\n\n/// Validates the `Authorization: Bearer <token>` header.\n///\n/// # Errors\n///\n/// Returns `StatusCode::UNAUTHORIZED` if the header is absent or the\n/// token does not match `expected`.\npub(crate) fn validate_bearer(headers: &HeaderMap, expected: &str) -> Result<(), StatusCode> {\n    let provided = headers\n        .get(header::AUTHORIZATION)\n        .and_then(|v| v.to_str().ok())\n        .and_then(|v| v.strip_prefix(\"Bearer \"));\n\n    if provided == Some(expected) {\n        Ok(())\n    } else {\n        Err(StatusCode::UNAUTHORIZED)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::http::{HeaderMap, HeaderValue};\n\n    #[test]\n    fn valid_bearer_passes() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Bearer secret123\"),\n        );\n        assert!(validate_bearer(&headers, \"secret123\").is_ok());\n    }\n\n    #[test]\n    fn wrong_token_rejected() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Bearer wrong\"),\n        );\n        assert!(validate_bearer(&headers, \"secret123\").is_err());\n    }\n\n    #[test]\n    fn missing_header_rejected() {\n        let headers = HeaderMap::new();\n        assert!(validate_bearer(&headers, \"secret123\").is_err());\n    }\n\n    #[test]\n    fn basic_auth_scheme_rejected() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Basic secret123\"),\n        );\n        assert!(validate_bearer(&headers, \"secret123\").is_err());\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":12,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":13,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":14,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":15,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":17,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","error.rs"],"content":"//! Error types for the HTTP/MCP transport layer.\n\nuse thiserror::Error;\n\n/// Errors that can occur in the HTTP transport.\n#[derive(Debug, Error)]\npub enum HttpTransportError {\n    /// Failed to bind to the TCP address.\n    #[error(\"failed to bind on {addr}: {source}\")]\n    Bind {\n        /// The address string.\n        addr: String,\n        /// The underlying I/O error.\n        #[source]\n        source: std::io::Error,\n    },\n    /// The HTTP server encountered an I/O error while serving.\n    #[error(\"server error: {0}\")]\n    Serve(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn bind_error_displays_address() {\n        let err = HttpTransportError::Bind {\n            addr: \"127.0.0.1:8080\".into(),\n            source: std::io::Error::new(std::io::ErrorKind::AddrInUse, \"in use\"),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"127.0.0.1:8080\"));\n    }\n\n    #[test]\n    fn serve_error_displays_message() {\n        let err = HttpTransportError::Serve(\"connection reset\".into());\n        assert!(err.to_string().contains(\"connection reset\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","lib.rs"],"content":"//! HTTP/JSON-RPC transport adapter for KAMI.\n//! Exposes MCP over `POST /mcp` with optional Bearer token authentication.\n\nmod auth;\nmod error;\nmod router;\npub mod server;\n\npub use error::HttpTransportError;\npub use server::HttpServer;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","router.rs"],"content":"//! Axum router for the MCP HTTP/JSON-RPC transport.\n//! Exposes `POST /mcp` for requests and `GET /health` for liveness checks.\n\nuse std::sync::Arc;\n\nuse axum::{\n    extract::State,\n    http::{header, HeaderMap, StatusCode},\n    response::IntoResponse,\n    routing::{get, post},\n    Json, Router,\n};\nuse serde_json::{json, Value};\n\nuse kami_protocol::{error_codes, JsonRpcNotification, JsonRpcRequest};\nuse kami_transport_stdio::McpHandler;\n\nuse crate::auth;\n\n/// Shared state threaded through all axum handlers.\n#[derive(Clone)]\npub(crate) struct AppState {\n    /// The MCP request dispatcher.\n    pub handler: Arc<McpHandler>,\n    /// Optional Bearer token (None = no authentication required).\n    pub token: Option<String>,\n}\n\n/// Builds the axum `Router` with all MCP routes.\npub(crate) fn build_router(state: AppState) -> Router {\n    Router::new()\n        .route(\"/mcp\", post(handle_mcp))\n        .route(\"/health\", get(handle_health))\n        .with_state(state)\n}\n\nasync fn handle_health() -> impl IntoResponse {\n    Json(json!({\"status\": \"ok\", \"service\": \"kami\"}))\n}\n\nasync fn handle_mcp(\n    State(state): State<AppState>,\n    headers: HeaderMap,\n    body: String,\n) -> impl IntoResponse {\n    if let Some(ref token) = state.token {\n        if auth::validate_bearer(&headers, token).is_err() {\n            return (\n                StatusCode::UNAUTHORIZED,\n                Json(json!({\"error\": \"unauthorized\"})),\n            )\n                .into_response();\n        }\n    }\n\n    let json_val: Value = match serde_json::from_str(&body) {\n        Ok(v) => v,\n        Err(_) => return json_rpc_error(StatusCode::OK, error_codes::PARSE_ERROR, \"Parse error\"),\n    };\n\n    let has_id = json_val.get(\"id\").is_some_and(|v| !v.is_null());\n    if !has_id {\n        if let Ok(notif) = serde_json::from_value::<JsonRpcNotification>(json_val) {\n            state.handler.handle_notification(&notif);\n        }\n        return StatusCode::NO_CONTENT.into_response();\n    }\n\n    let request: JsonRpcRequest = match serde_json::from_value(json_val) {\n        Ok(r) => r,\n        Err(e) => {\n            return json_rpc_error(\n                StatusCode::OK,\n                error_codes::INVALID_REQUEST,\n                &format!(\"Invalid request: {e}\"),\n            )\n        }\n    };\n\n    let output = state.handler.dispatch(&request).await;\n    match output.to_json() {\n        Ok(json_str) => (\n            StatusCode::OK,\n            [(header::CONTENT_TYPE, \"application/json\")],\n            json_str,\n        )\n            .into_response(),\n        Err(e) => json_rpc_error(\n            StatusCode::INTERNAL_SERVER_ERROR,\n            error_codes::INTERNAL_ERROR,\n            &e.to_string(),\n        ),\n    }\n}\n\n/// Produces a JSON-RPC error response without a request ID (id: null).\nfn json_rpc_error(status: StatusCode, code: i32, message: &str) -> axum::response::Response {\n    let body = json!({\n        \"jsonrpc\": \"2.0\",\n        \"id\": null,\n        \"error\": { \"code\": code, \"message\": message }\n    });\n    (status, Json(body)).into_response()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::body::Body;\n    use http::Request;\n    use tower::ServiceExt;\n\n    fn make_state() -> AppState {\n        let repo = Arc::new(\n            kami_store_sqlite::SqliteToolRepository::open_in_memory().expect(\"db\"),\n        );\n        let config = kami_runtime::RuntimeConfig {\n            cache_size: 4,\n            max_concurrent: 2,\n            epoch_interruption: false,\n        };\n        let runtime = Arc::new(\n            kami_runtime::KamiRuntime::new(config, repo.clone()).expect(\"rt\"),\n        );\n        AppState {\n            handler: Arc::new(kami_transport_stdio::McpHandler::new(runtime, repo)),\n            token: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn health_endpoint_returns_ok() {\n        let app = build_router(make_state());\n        let req = Request::builder()\n            .uri(\"/health\")\n            .body(Body::empty())\n            .expect(\"request\");\n        let resp = app.oneshot(req).await.expect(\"response\");\n        assert_eq!(resp.status(), StatusCode::OK);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","server.rs"],"content":"//! HTTP server that binds an axum Router to a TCP socket.\n\nuse std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse tokio::net::TcpListener;\n\nuse kami_transport_stdio::McpHandler;\n\nuse crate::error::HttpTransportError;\nuse crate::router::{build_router, AppState};\n\n/// Axum-based HTTP server for the MCP JSON-RPC transport.\npub struct HttpServer {\n    pub(crate) addr: SocketAddr,\n    pub(crate) state: AppState,\n}\n\nimpl HttpServer {\n    /// Creates a new HTTP server.\n    ///\n    /// # Arguments\n    ///\n    /// * `handler` — shared MCP dispatcher\n    /// * `port` — TCP port to listen on\n    /// * `token` — optional Bearer token for authentication\n    pub fn new(handler: Arc<McpHandler>, port: u16, token: Option<String>) -> Self {\n        Self {\n            addr: SocketAddr::from(([0, 0, 0, 0], port)),\n            state: AppState { handler, token },\n        }\n    }\n\n    /// Starts the server and blocks until it exits.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the TCP bind fails or the server crashes.\n    pub async fn run(self) -> Result<(), HttpTransportError> {\n        let listener =\n            TcpListener::bind(self.addr)\n                .await\n                .map_err(|e| HttpTransportError::Bind {\n                    addr: self.addr.to_string(),\n                    source: e,\n                })?;\n\n        tracing::info!(addr = %self.addr, \"KAMI MCP HTTP server ready\");\n\n        let router = build_router(self.state);\n        axum::serve(listener, router)\n            .await\n            .map_err(|e| HttpTransportError::Serve(e.to_string()))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_runtime::{KamiRuntime, RuntimeConfig};\n    use kami_store_sqlite::SqliteToolRepository;\n    use kami_transport_stdio::McpHandler;\n\n    fn make_handler() -> Arc<McpHandler> {\n        let repo = Arc::new(SqliteToolRepository::open_in_memory().expect(\"in-memory db\"));\n        let config = RuntimeConfig {\n            cache_size: 4,\n            max_concurrent: 2,\n            epoch_interruption: false,\n        };\n        let runtime = Arc::new(KamiRuntime::new(config, repo.clone()).expect(\"runtime\"));\n        Arc::new(McpHandler::new(runtime, repo))\n    }\n\n    #[test]\n    fn new_sets_correct_port() {\n        let server = HttpServer::new(make_handler(), 3000, None);\n        assert_eq!(server.addr.port(), 3000);\n    }\n\n    #[test]\n    fn new_stores_bearer_token() {\n        let server = HttpServer::new(make_handler(), 8080, Some(\"s3cret\".to_string()));\n        assert_eq!(server.state.token.as_deref(), Some(\"s3cret\"));\n    }\n\n    #[test]\n    fn new_with_no_token() {\n        let server = HttpServer::new(make_handler(), 9000, None);\n        assert!(server.state.token.is_none());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":29,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":30,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","initialize.rs"],"content":"//! Handles the `initialize` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::initialize::{\n    InitializeParams, InitializeResult, ServerCapabilities, ServerInfo, ToolCapability,\n    PROTOCOL_VERSION,\n};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `initialize` request and returns the server capabilities.\npub(crate) fn handle_initialize(id: RequestId, params: &Option<Value>) -> JsonRpcOutput {\n    if let Some(p) = params {\n        if let Err(e) = serde_json::from_value::<InitializeParams>(p.clone()) {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                format!(\"invalid initialize params: {e}\"),\n            ));\n        }\n    }\n\n    let result = InitializeResult {\n        protocol_version: PROTOCOL_VERSION.to_string(),\n        capabilities: ServerCapabilities {\n            tools: Some(ToolCapability {}),\n        },\n        server_info: ServerInfo {\n            name: \"kami\".to_string(),\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        },\n    };\n\n    match serde_json::to_value(result) {\n        Ok(v) => JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) => JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":15,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":16,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","mod.rs"],"content":"//! MCP method dispatch functions.\n//!\n//! Each sub-module handles one family of MCP methods as free functions,\n//! keeping `McpHandler` itself thin (struct + routing only).\n\npub(crate) mod initialize;\npub(crate) mod tools_call;\npub(crate) mod tools_list;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","tools_call.rs"],"content":"//! Handles the `tools/call` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::tools::{ToolContent, ToolsCallParams, ToolsCallResult};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\nuse kami_runtime::KamiRuntime;\nuse kami_types::ToolId;\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `tools/call` request.\npub(crate) async fn handle_tools_call(\n    id: RequestId,\n    params: &Option<Value>,\n    runtime: &KamiRuntime,\n) -> JsonRpcOutput {\n    // 1. Parse params\n    let call_params = match params {\n        Some(p) => match serde_json::from_value::<ToolsCallParams>(p.clone()) {\n            Ok(cp) => cp,\n            Err(e) => {\n                return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                    id,\n                    error_codes::INVALID_PARAMS,\n                    format!(\"invalid tools/call params: {e}\"),\n                ));\n            }\n        },\n        None => {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                \"tools/call requires params\",\n            ));\n        }\n    };\n\n    // 2. Parse tool ID\n    let tool_id = match ToolId::new(&call_params.name) {\n        Ok(tid) => tid,\n        Err(e) => {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                format!(\"invalid tool name: {e}\"),\n            ));\n        }\n    };\n\n    // 3. Execute via runtime\n    let input = call_params.arguments.to_string();\n    tracing::debug!(%tool_id, \"executing tool via MCP\");\n\n    let (content, is_error) = match runtime.execute(&tool_id, &input).await {\n        Ok(result) => (result.content, !result.success),\n        Err(e) => (e.to_string(), true),\n    };\n\n    let call_result = ToolsCallResult {\n        content: vec![ToolContent::Text { text: content }],\n        is_error,\n    };\n\n    match serde_json::to_value(call_result) {\n        Ok(v) => JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) => JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":20,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":27,"coverable":32},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","tools_list.rs"],"content":"//! Handles the `tools/list` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::tools::{McpToolDefinition, ToolsListResult};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\nuse kami_registry::{ToolQuery, ToolRepository};\nuse kami_types::ToolArgument;\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `tools/list` request.\npub(crate) async fn handle_tools_list(\n    id: RequestId,\n    repository: &dyn ToolRepository,\n) -> JsonRpcOutput {\n    let tools = match repository.find_all(ToolQuery::all()).await {\n        Ok(t) => t,\n        Err(e) => {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INTERNAL_ERROR,\n                format!(\"registry error: {e}\"),\n            ));\n        }\n    };\n\n    let definitions: Vec<McpToolDefinition> = tools\n        .iter()\n        .filter(|t| t.enabled)\n        .map(|t| {\n            let m = &t.manifest;\n            McpToolDefinition {\n                name: m.id.to_string(),\n                description: Some(m.description.clone()),\n                input_schema: build_input_schema(&m.arguments),\n            }\n        })\n        .collect();\n\n    let result = ToolsListResult {\n        tools: definitions,\n        next_cursor: None,\n    };\n\n    match serde_json::to_value(result) {\n        Ok(v) => JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) => JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n\n/// Builds a JSON Schema `inputSchema` from tool arguments.\npub(crate) fn build_input_schema(arguments: &[ToolArgument]) -> Value {\n    let mut properties = serde_json::Map::new();\n    let mut required = Vec::new();\n\n    for arg in arguments {\n        let mut prop = serde_json::Map::new();\n        prop.insert(\"type\".to_string(), Value::String(arg.arg_type.clone()));\n        prop.insert(\n            \"description\".to_string(),\n            Value::String(arg.description.clone()),\n        );\n        properties.insert(arg.name.clone(), Value::Object(prop));\n        if arg.required {\n            required.push(Value::String(arg.name.clone()));\n        }\n    }\n\n    let mut schema = serde_json::Map::new();\n    schema.insert(\"type\".to_string(), Value::String(\"object\".to_string()));\n    schema.insert(\"properties\".to_string(), Value::Object(properties));\n    if !required.is_empty() {\n        schema.insert(\"required\".to_string(), Value::Array(required));\n    }\n\n    Value::Object(schema)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_types::ToolArgument;\n\n    #[test]\n    fn build_input_schema_empty_args() {\n        let schema = build_input_schema(&[]);\n        assert_eq!(schema[\"type\"], \"object\");\n        assert!(schema[\"properties\"].as_object().expect(\"obj\").is_empty());\n        assert!(schema.get(\"required\").is_none());\n    }\n\n    #[test]\n    fn build_input_schema_with_args() {\n        let args = vec![\n            ToolArgument {\n                name: \"url\".to_string(),\n                arg_type: \"string\".to_string(),\n                description: \"The URL\".to_string(),\n                required: true,\n                default: None,\n            },\n            ToolArgument {\n                name: \"timeout\".to_string(),\n                arg_type: \"number\".to_string(),\n                description: \"Timeout in ms\".to_string(),\n                required: false,\n                default: Some(\"5000\".to_string()),\n            },\n        ];\n        let schema = build_input_schema(&args);\n        assert_eq!(schema[\"type\"], \"object\");\n        assert_eq!(schema[\"properties\"][\"url\"][\"type\"], \"string\");\n        assert_eq!(schema[\"properties\"][\"timeout\"][\"type\"], \"number\");\n        let req = schema[\"required\"].as_array().expect(\"arr\");\n        assert_eq!(req.len(), 1);\n        assert_eq!(req[0], \"url\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":63,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":76,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":78,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":31,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","error.rs"],"content":"//! Transport-layer error types.\n\nuse kami_types::{ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the stdio transport layer.\n#[derive(Debug, Error)]\npub enum TransportError {\n    /// Failed to read from stdin.\n    #[error(\"read error: {0}\")]\n    Read(String),\n    /// Failed to write to stdout.\n    #[error(\"write error: {0}\")]\n    Write(String),\n    /// Failed to parse incoming JSON message.\n    #[error(\"parse error: {0}\")]\n    Parse(String),\n    /// The connection was closed (EOF on stdin).\n    #[error(\"connection closed\")]\n    ConnectionClosed,\n    /// Handler returned an error during dispatch.\n    #[error(\"dispatch error: {0}\")]\n    Dispatch(String),\n}\n\nimpl From<TransportError> for KamiError {\n    fn from(e: TransportError) -> Self {\n        let kind = match &e {\n            TransportError::Parse(_) => ErrorKind::InvalidInput,\n            TransportError::ConnectionClosed => ErrorKind::Internal,\n            _ => ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_error_converts_to_invalid_input() {\n        let err: KamiError = TransportError::Parse(\"bad json\".into()).into();\n        assert_eq!(err.kind, ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn connection_closed_converts_to_internal() {\n        let err: KamiError = TransportError::ConnectionClosed.into();\n        assert_eq!(err.kind, ErrorKind::Internal);\n    }\n\n    #[test]\n    fn dispatch_error_converts_to_internal() {\n        let err: KamiError = TransportError::Dispatch(\"fail\".into()).into();\n        assert_eq!(err.kind, ErrorKind::Internal);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":6,"coverable":6},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","handler.rs"],"content":"//! MCP method dispatch handler.\n//!\n//! `McpHandler` routes incoming JSON-RPC requests to the method-specific\n//! handlers in the `dispatch` sub-modules and returns a typed response.\n\nuse std::sync::Arc;\n\nuse tracing::debug;\n\nuse kami_protocol::mcp::methods;\nuse kami_protocol::{\n    error_codes, JsonRpcErrorResponse, JsonRpcNotification, JsonRpcRequest, JsonRpcResponse,\n};\nuse kami_registry::ToolRepository;\nuse kami_runtime::KamiRuntime;\n\nuse crate::dispatch;\nuse crate::error::TransportError;\n\n/// Handles MCP method dispatch over JSON-RPC.\n///\n/// Combines a `KamiRuntime` (for tool execution) and a\n/// `ToolRepository` (for tool listing) to serve MCP requests.\npub struct McpHandler {\n    runtime: Arc<KamiRuntime>,\n    repository: Arc<dyn ToolRepository>,\n}\n\n/// Enum representing either a success or error JSON-RPC response.\n#[derive(Debug)]\npub enum JsonRpcOutput {\n    /// Success response.\n    Success(JsonRpcResponse),\n    /// Error response.\n    Error(JsonRpcErrorResponse),\n}\n\nimpl JsonRpcOutput {\n    /// Serializes the output to a JSON string.\n    pub fn to_json(&self) -> Result<String, TransportError> {\n        match self {\n            Self::Success(r) => serde_json::to_string(r),\n            Self::Error(r) => serde_json::to_string(r),\n        }\n        .map_err(|e| TransportError::Write(e.to_string()))\n    }\n}\n\nimpl McpHandler {\n    /// Creates a new handler with the given runtime and repository.\n    pub fn new(runtime: Arc<KamiRuntime>, repository: Arc<dyn ToolRepository>) -> Self {\n        Self {\n            runtime,\n            repository,\n        }\n    }\n\n    /// Dispatches a JSON-RPC request to the appropriate method handler.\n    #[tracing::instrument(skip(self, request), fields(method = %request.method))]\n    pub async fn dispatch(&self, request: &JsonRpcRequest) -> JsonRpcOutput {\n        debug!(method = %request.method, \"dispatching MCP request\");\n\n        match request.method.as_str() {\n            methods::INITIALIZE => {\n                dispatch::initialize::handle_initialize(request.id.clone(), &request.params)\n            }\n            methods::TOOLS_LIST => {\n                dispatch::tools_list::handle_tools_list(\n                    request.id.clone(),\n                    self.repository.as_ref(),\n                )\n                .await\n            }\n            methods::TOOLS_CALL => {\n                dispatch::tools_call::handle_tools_call(\n                    request.id.clone(),\n                    &request.params,\n                    &self.runtime,\n                )\n                .await\n            }\n            other => {\n                tracing::warn!(method = other, \"unknown MCP method\");\n                JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                    request.id.clone(),\n                    error_codes::METHOD_NOT_FOUND,\n                    format!(\"unknown method: {other}\"),\n                ))\n            }\n        }\n    }\n\n    /// Handles a JSON-RPC notification silently (no response is sent).\n    ///\n    /// Per the MCP spec, `notifications/initialized` must be accepted\n    /// without generating a response.\n    pub fn handle_notification(&self, notification: &JsonRpcNotification) {\n        match notification.method.as_str() {\n            methods::NOTIFICATIONS_INITIALIZED => {\n                debug!(\"MCP session initialized by client\");\n            }\n            other => {\n                debug!(method = other, \"notification ignored\");\n            }\n        }\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":41,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":42,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":43,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":45,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":51,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":60,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":13,"coverable":13},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","lib.rs"],"content":"//! # kami-transport-stdio\n//!\n//! Stdio transport adapter for MCP JSON-RPC communication.\n//!\n//! Provides line-delimited JSON transport over stdin/stdout,\n//! MCP method dispatch, and a server loop that ties them together.\n\nmod dispatch;\npub mod error;\npub mod handler;\npub mod server;\npub mod transport;\n\npub use error::TransportError;\npub use handler::McpHandler;\npub use server::McpServer;\npub use transport::StdioTransport;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","server.rs"],"content":"//! MCP server loop over stdio transport.\n//!\n//! Reads JSON-RPC requests line by line, dispatches them via\n//! `McpHandler`, and writes responses back. JSON-RPC notifications\n//! (which have no `id` field) are handled silently without a response.\n\nuse tracing::{debug, error, info, warn};\n\nuse kami_protocol::{\n    error_codes, JsonRpcErrorResponse, JsonRpcNotification, JsonRpcRequest, RequestId,\n};\n\nuse crate::error::TransportError;\nuse crate::handler::{JsonRpcOutput, McpHandler};\nuse crate::transport::StdioTransport;\n\n/// MCP server that reads from a transport and dispatches to a handler.\npub struct McpServer<R, W> {\n    transport: StdioTransport<R, W>,\n    handler: McpHandler,\n}\n\nimpl<R, W> McpServer<R, W>\nwhere\n    R: tokio::io::AsyncRead + Unpin,\n    W: tokio::io::AsyncWrite + Unpin,\n{\n    /// Creates a new server with the given transport and handler.\n    pub fn new(transport: StdioTransport<R, W>, handler: McpHandler) -> Self {\n        Self { transport, handler }\n    }\n\n    /// Runs the server loop until the transport is closed.\n    ///\n    /// Each incoming line is parsed as either a JSON-RPC request\n    /// (response required) or a notification (silently handled).\n    pub async fn run(&mut self) -> Result<(), TransportError> {\n        info!(\"MCP server starting on stdio\");\n\n        loop {\n            // 1. Read next line\n            let line = match self.transport.read_line().await? {\n                Some(line) if line.is_empty() => continue,\n                Some(line) => line,\n                None => {\n                    info!(\"stdin closed, shutting down\");\n                    return Ok(());\n                }\n            };\n\n            // 2. Try parsing as a JSON-RPC request (has an `id`)\n            match serde_json::from_str::<JsonRpcRequest>(&line) {\n                Ok(request) => {\n                    debug!(\n                        method = %request.method,\n                        id = ?request.id,\n                        \"received request\"\n                    );\n                    let output = self.handler.dispatch(&request).await;\n                    self.write_output(&output).await?;\n                }\n                Err(_) => {\n                    // 3. Fall back: try as notification (no `id` field)\n                    match serde_json::from_str::<JsonRpcNotification>(&line) {\n                        Ok(notif) => {\n                            debug!(\n                                method = %notif.method,\n                                \"received notification\"\n                            );\n                            self.handler.handle_notification(&notif);\n                            // Notifications must not receive a response.\n                        }\n                        Err(e) => {\n                            warn!(\n                                error = %e,\n                                \"failed to parse JSON-RPC message\"\n                            );\n                            let err = JsonRpcErrorResponse::error(\n                                RequestId::Number(0),\n                                error_codes::PARSE_ERROR,\n                                format!(\"parse error: {e}\"),\n                            );\n                            self.write_output(&JsonRpcOutput::Error(err)).await?;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// Serializes and writes a JSON-RPC output to the transport.\n    async fn write_output(&mut self, output: &JsonRpcOutput) -> Result<(), TransportError> {\n        match output.to_json() {\n            Ok(json) => self.transport.write_line(&json).await,\n            Err(e) => {\n                error!(error = %e, \"failed to serialize response\");\n                Err(e)\n            }\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","transport.rs"],"content":"//! Line-delimited JSON transport over stdin/stdout.\n//!\n//! Each JSON-RPC message is a single line terminated by `\\n`.\n//! This follows the MCP stdio transport specification.\n\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tracing::trace;\n\nuse crate::error::TransportError;\n\n/// Reads JSON-RPC messages from stdin, writes responses to stdout.\n///\n/// Uses line-delimited JSON: one complete JSON object per line.\n/// This struct is generic over reader/writer for testability.\npub struct StdioTransport<R, W> {\n    reader: BufReader<R>,\n    writer: W,\n}\n\nimpl<R, W> StdioTransport<R, W>\nwhere\n    R: tokio::io::AsyncRead + Unpin,\n    W: tokio::io::AsyncWrite + Unpin,\n{\n    /// Creates a new transport with the given reader and writer.\n    pub fn new(reader: R, writer: W) -> Self {\n        Self {\n            reader: BufReader::new(reader),\n            writer,\n        }\n    }\n\n    /// Reads the next line from the input stream.\n    ///\n    /// Returns `None` on EOF (connection closed).\n    pub async fn read_line(&mut self) -> Result<Option<String>, TransportError> {\n        let mut line = String::new();\n        let bytes_read = self\n            .reader\n            .read_line(&mut line)\n            .await\n            .map_err(|e| TransportError::Read(e.to_string()))?;\n\n        if bytes_read == 0 {\n            return Ok(None);\n        }\n\n        let trimmed = line.trim().to_string();\n        if trimmed.is_empty() {\n            return Ok(Some(String::new()));\n        }\n\n        trace!(len = trimmed.len(), \"read message\");\n        Ok(Some(trimmed))\n    }\n\n    /// Writes a JSON-RPC response line to the output stream.\n    pub async fn write_line(&mut self, message: &str) -> Result<(), TransportError> {\n        trace!(len = message.len(), \"writing message\");\n\n        self.writer\n            .write_all(message.as_bytes())\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        self.writer\n            .write_all(b\"\\n\")\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        self.writer\n            .flush()\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[tokio::test]\n    async fn read_single_line() {\n        let input = b\"{\\\"jsonrpc\\\":\\\"2.0\\\"}\\n\";\n        let reader = Cursor::new(input.to_vec());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let line = transport.read_line().await.expect(\"read\");\n        assert_eq!(line, Some(\"{\\\"jsonrpc\\\":\\\"2.0\\\"}\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn read_eof_returns_none() {\n        let reader = Cursor::new(Vec::<u8>::new());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let line = transport.read_line().await.expect(\"read\");\n        assert_eq!(line, None);\n    }\n\n    #[tokio::test]\n    async fn write_appends_newline() {\n        let reader = Cursor::new(Vec::<u8>::new());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        transport.write_line(\"{\\\"ok\\\":true}\").await.expect(\"write\");\n\n        let output = String::from_utf8(transport.writer.clone()).expect(\"utf8\");\n        assert_eq!(output, \"{\\\"ok\\\":true}\\n\");\n    }\n\n    #[tokio::test]\n    async fn read_multiple_lines() {\n        let input = b\"line1\\nline2\\nline3\\n\";\n        let reader = Cursor::new(input.to_vec());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let l1 = transport.read_line().await.expect(\"r1\");\n        let l2 = transport.read_line().await.expect(\"r2\");\n        let l3 = transport.read_line().await.expect(\"r3\");\n        let l4 = transport.read_line().await.expect(\"r4\");\n\n        assert_eq!(l1, Some(\"line1\".to_string()));\n        assert_eq!(l2, Some(\"line2\".to_string()));\n        assert_eq!(l3, Some(\"line3\".to_string()));\n        assert_eq!(l4, None);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":36,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":38,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":49,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":28,"coverable":29},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","capability.rs"],"content":"//! Capability-based security types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Filesystem access level.\n#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum FsAccess {\n    /// No filesystem access.\n    #[default]\n    None,\n    /// Read-only access within sandbox.\n    ReadOnly,\n    /// Read-write within sandbox directory.\n    Sandbox,\n}\n\n/// Resource limits for a WASM instance.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceLimits {\n    /// Maximum memory in megabytes.\n    #[serde(default = \"default_max_memory_mb\")]\n    pub max_memory_mb: u32,\n    /// Maximum execution time in milliseconds.\n    #[serde(default = \"default_max_execution_ms\")]\n    pub max_execution_ms: u64,\n    /// Maximum fuel (instruction budget).\n    #[serde(default = \"default_max_fuel\")]\n    pub max_fuel: u64,\n}\n\nfn default_max_memory_mb() -> u32 {\n    64\n}\nfn default_max_execution_ms() -> u64 {\n    5000\n}\nfn default_max_fuel() -> u64 {\n    1_000_000\n}\n\nimpl Default for ResourceLimits {\n    fn default() -> Self {\n        Self {\n            max_memory_mb: default_max_memory_mb(),\n            max_execution_ms: default_max_execution_ms(),\n            max_fuel: default_max_fuel(),\n        }\n    }\n}\n\n/// Security configuration for a tool.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SecurityConfig {\n    /// Allowed network destinations (glob patterns).\n    #[serde(default)]\n    pub net_allow_list: Vec<String>,\n    /// Filesystem access level.\n    #[serde(default)]\n    pub fs_access: FsAccess,\n    /// Allowed environment variable names (exact match, deny-all by default).\n    #[serde(default)]\n    pub env_allow_list: Vec<String>,\n    /// Resource limits.\n    #[serde(flatten)]\n    pub limits: ResourceLimits,\n}\n\nimpl Default for SecurityConfig {\n    fn default() -> Self {\n        Self {\n            net_allow_list: Vec::new(),\n            fs_access: FsAccess::None,\n            env_allow_list: Vec::new(),\n            limits: ResourceLimits::default(),\n        }\n    }\n}\n\n/// A single capability granted to a tool instance.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum Capability {\n    /// Network access to a specific pattern.\n    Network(String),\n    /// Filesystem read access to a path.\n    FsRead(String),\n    /// Filesystem write access to a path.\n    FsWrite(String),\n    /// Environment variable access.\n    EnvVar(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn default_security_is_deny_all() {\n        let config = SecurityConfig::default();\n        assert!(config.net_allow_list.is_empty());\n        assert!(config.env_allow_list.is_empty());\n        assert_eq!(config.fs_access, FsAccess::None);\n    }\n\n    #[test]\n    fn resource_limits_defaults() {\n        let limits = ResourceLimits::default();\n        assert_eq!(limits.max_memory_mb, 64);\n        assert_eq!(limits.max_execution_ms, 5000);\n        assert_eq!(limits.max_fuel, 1_000_000);\n    }\n\n    #[test]\n    fn fs_access_serialization() {\n        let access = FsAccess::ReadOnly;\n        let json = serde_json::to_string(&access).unwrap();\n        assert_eq!(json, \"\\\"read-only\\\"\");\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":33,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":35,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":36,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":38,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":39,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":43,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":45,"address":[],"length":0,"stats":{"Line":10232178353385766914}},{"line":46,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":47,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":70,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":72,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":74,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":75,"address":[],"length":0,"stats":{"Line":4467570830351532032}}],"covered":14,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","error.rs"],"content":"//! Unified error types for the KAMI domain layer.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Classification of domain errors.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ErrorKind {\n    /// Resource not found.\n    NotFound,\n    /// Permission denied by capability checker.\n    PermissionDenied,\n    /// Invalid input data.\n    InvalidInput,\n    /// Operation timed out.\n    Timeout,\n    /// Resource limit exceeded (memory, fuel, etc.).\n    ResourceExhausted,\n    /// Internal error.\n    Internal,\n}\n\n/// Domain-level error with structured context.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KamiError {\n    /// The kind of error.\n    pub kind: ErrorKind,\n    /// Human-readable error message.\n    pub message: String,\n    /// Optional additional context.\n    pub context: Option<String>,\n}\n\nimpl KamiError {\n    /// Creates a new `KamiError`.\n    pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {\n        Self {\n            kind,\n            message: message.into(),\n            context: None,\n        }\n    }\n\n    /// Adds context to the error.\n    pub fn with_context(mut self, context: impl Into<String>) -> Self {\n        self.context = Some(context.into());\n        self\n    }\n\n    /// Creates a not-found error.\n    pub fn not_found(message: impl Into<String>) -> Self {\n        Self::new(ErrorKind::NotFound, message)\n    }\n\n    /// Creates a permission-denied error.\n    pub fn permission_denied(message: impl Into<String>) -> Self {\n        Self::new(ErrorKind::PermissionDenied, message)\n    }\n\n    /// Creates an invalid-input error.\n    pub fn invalid_input(message: impl Into<String>) -> Self {\n        Self::new(ErrorKind::InvalidInput, message)\n    }\n}\n\nimpl fmt::Display for KamiError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"[{:?}] {}\", self.kind, self.message)?;\n        if let Some(ctx) = &self.context {\n            write!(f, \" ({})\", ctx)?;\n        }\n        Ok(())\n    }\n}\n\nimpl std::error::Error for KamiError {}\n\n/// Transforms technical errors into user-actionable diagnostics.\n///\n/// Implementors provide optional `hint` (cause explanation) and `fix`\n/// (concrete remediation step) for each error variant.\npub trait DiagnosticError {\n    /// A human-readable explanation of the likely cause.\n    fn hint(&self) -> Option<String> {\n        None\n    }\n    /// A concrete fix the user can apply (e.g. a config change).\n    fn fix(&self) -> Option<String> {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn error_display_without_context() {\n        let err = KamiError::new(ErrorKind::NotFound, \"tool not found\");\n        assert_eq!(err.to_string(), \"[NotFound] tool not found\");\n    }\n\n    #[test]\n    fn error_display_with_context() {\n        let err = KamiError::not_found(\"tool not found\").with_context(\"id: dev.example.fetch\");\n        assert!(err.to_string().contains(\"dev.example.fetch\"));\n    }\n\n    #[test]\n    fn error_serialization_roundtrip() {\n        let err = KamiError::new(ErrorKind::PermissionDenied, \"access denied\");\n        let json = serde_json::to_string(&err).expect(\"serialize\");\n        let back: KamiError = serde_json::from_str(&json).expect(\"deserialize\");\n        assert_eq!(back.kind, ErrorKind::PermissionDenied);\n        assert_eq!(back.message, \"access denied\");\n    }\n\n    #[test]\n    fn not_found_constructor() {\n        let err = KamiError::not_found(\"missing\");\n        assert_eq!(err.kind, ErrorKind::NotFound);\n    }\n\n    #[test]\n    fn permission_denied_constructor() {\n        let err = KamiError::permission_denied(\"nope\");\n        assert_eq!(err.kind, ErrorKind::PermissionDenied);\n    }\n\n    #[test]\n    fn invalid_input_constructor() {\n        let err = KamiError::invalid_input(\"bad data\");\n        assert_eq!(err.kind, ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn diagnostic_trait_defaults_to_none() {\n        struct Dummy;\n        impl DiagnosticError for Dummy {}\n        let d = Dummy;\n        assert!(d.hint().is_none());\n        assert!(d.fix().is_none());\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":40,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":62,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":63,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":68,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":69,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":70,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":20,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","event.rs"],"content":"//! Domain events for observability.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::SystemTime;\n\nuse crate::tool::ToolId;\n\n/// Domain events emitted during tool lifecycle.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum DomainEvent {\n    /// A tool has been installed.\n    ToolInstalled {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n    /// A tool execution has started.\n    ExecutionStarted {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n    /// A tool execution has completed.\n    ExecutionCompleted {\n        tool_id: ToolId,\n        duration_ms: u64,\n        success: bool,\n        timestamp: SystemTime,\n    },\n    /// A tool has been removed.\n    ToolRemoved {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n}\n\nimpl DomainEvent {\n    /// Creates a tool-installed event.\n    pub fn tool_installed(tool_id: ToolId) -> Self {\n        Self::ToolInstalled {\n            tool_id,\n            timestamp: SystemTime::now(),\n        }\n    }\n\n    /// Creates an execution-started event.\n    pub fn execution_started(tool_id: ToolId) -> Self {\n        Self::ExecutionStarted {\n            tool_id,\n            timestamp: SystemTime::now(),\n        }\n    }\n\n    /// Creates an execution-completed event.\n    pub fn execution_completed(tool_id: ToolId, duration_ms: u64, success: bool) -> Self {\n        Self::ExecutionCompleted {\n            tool_id,\n            duration_ms,\n            success,\n            timestamp: SystemTime::now(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn tool_installed_event() {\n        let id = ToolId::new(\"dev.test.tool\").unwrap();\n        let event = DomainEvent::tool_installed(id);\n        match &event {\n            DomainEvent::ToolInstalled { tool_id, .. } => {\n                assert_eq!(tool_id.as_str(), \"dev.test.tool\");\n            }\n            _ => panic!(\"unexpected event variant\"),\n        }\n    }\n\n    #[test]\n    fn execution_started_event() {\n        let id = ToolId::new(\"dev.test.run\").unwrap();\n        let event = DomainEvent::execution_started(id);\n        match &event {\n            DomainEvent::ExecutionStarted { tool_id, .. } => {\n                assert_eq!(tool_id.as_str(), \"dev.test.run\");\n            }\n            _ => panic!(\"unexpected event variant\"),\n        }\n    }\n\n    #[test]\n    fn execution_completed_event() {\n        let id = ToolId::new(\"dev.test.done\").unwrap();\n        let event = DomainEvent::execution_completed(id, 42, true);\n        match &event {\n            DomainEvent::ExecutionCompleted {\n                duration_ms,\n                success,\n                ..\n            } => {\n                assert_eq!(*duration_ms, 42);\n                assert!(*success);\n            }\n            _ => panic!(\"unexpected event variant\"),\n        }\n    }\n\n    #[test]\n    fn event_serialization_roundtrip() {\n        let id = ToolId::new(\"dev.test.serde\").unwrap();\n        let event = DomainEvent::tool_installed(id);\n        let json = serde_json::to_string(&event).expect(\"serialize\");\n        assert!(json.contains(\"tool_installed\"));\n        let back: DomainEvent = serde_json::from_str(&json).expect(\"deserialize\");\n        match back {\n            DomainEvent::ToolInstalled { tool_id, .. } => {\n                assert_eq!(tool_id.as_str(), \"dev.test.serde\");\n            }\n            _ => panic!(\"unexpected variant after roundtrip\"),\n        }\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":6,"coverable":6},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","lib.rs"],"content":"//! # kami-types\n//!\n//! Domain types for the KAMI orchestrator.\n//! Zero external dependencies except `serde` for serialization.\n//! No filesystem I/O — `tool.toml` parsing is in `kami-config`.\n\npub mod capability;\npub mod error;\npub mod event;\npub mod manifest;\npub mod tool;\npub mod version;\n\n// Re-exports for convenience.\npub use capability::{Capability, FsAccess, ResourceLimits, SecurityConfig};\npub use error::{DiagnosticError, ErrorKind, KamiError};\npub use event::DomainEvent;\npub use tool::{Tool, ToolArgument, ToolId, ToolManifest, ToolVersion};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","manifest.rs"],"content":"//! Tool manifest format documentation.\n//!\n//! Parsing of `tool.toml` lives in `kami-config::manifest_loader`\n//! to keep filesystem I/O and the `toml` crate out of the domain layer.\n//! Domain types (`ToolManifest`, `ToolArgument`, etc.) are in `tool.rs`.\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","tool.rs"],"content":"//! Tool identity and manifest types.\n//!\n//! `ToolVersion` display and parsing live in `version.rs`.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\nuse std::str::FromStr;\n\nuse crate::capability::SecurityConfig;\nuse crate::error::KamiError;\n\n/// Unique identifier for a tool (reverse-domain notation).\n/// Example: `dev.example.fetch-url`\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ToolId(String);\n\nimpl ToolId {\n    /// Creates a new `ToolId`, validating the format.\n    pub fn new(id: impl Into<String>) -> Result<Self, KamiError> {\n        let id = id.into();\n        if id.is_empty() {\n            return Err(KamiError::invalid_input(\"tool id cannot be empty\"));\n        }\n        if !id.contains('.') {\n            return Err(KamiError::invalid_input(\n                \"tool id must use reverse-domain notation (e.g. dev.example.tool)\",\n            ));\n        }\n        Ok(Self(id))\n    }\n\n    /// Returns the tool id as a string slice.\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for ToolId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(&self.0)\n    }\n}\n\nimpl FromStr for ToolId {\n    type Err = KamiError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::new(s)\n    }\n}\n\n/// Semantic version for a tool.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct ToolVersion {\n    pub major: u32,\n    pub minor: u32,\n    pub patch: u32,\n}\n\nimpl ToolVersion {\n    /// Creates a new version.\n    pub fn new(major: u32, minor: u32, patch: u32) -> Self {\n        Self {\n            major,\n            minor,\n            patch,\n        }\n    }\n}\n\n/// MCP argument definition for a tool.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolArgument {\n    /// Argument name.\n    pub name: String,\n    /// JSON Schema type (string, number, boolean, etc.).\n    #[serde(rename = \"type\")]\n    pub arg_type: String,\n    /// Human-readable description.\n    pub description: String,\n    /// Whether this argument is required.\n    #[serde(default)]\n    pub required: bool,\n    /// Default value if not required.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub default: Option<String>,\n}\n\n/// Complete tool manifest (parsed from tool.toml).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolManifest {\n    /// Tool identity.\n    pub id: ToolId,\n    /// Human-readable name.\n    pub name: String,\n    /// Tool version.\n    pub version: ToolVersion,\n    /// Path to the WASM component file.\n    pub wasm: String,\n    /// MCP description.\n    pub description: String,\n    /// Tool arguments.\n    #[serde(default)]\n    pub arguments: Vec<ToolArgument>,\n    /// Security configuration.\n    pub security: SecurityConfig,\n    /// SHA-256 hex digest of the WASM file (computed at install time).\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub wasm_sha256: Option<String>,\n}\n\n/// Installed tool with metadata.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Tool {\n    /// The tool manifest.\n    pub manifest: ToolManifest,\n    /// Installation path on disk.\n    pub install_path: String,\n    /// Whether the tool is enabled.\n    pub enabled: bool,\n    /// Pinned version — prevents updates beyond this version.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub pinned_version: Option<String>,\n    /// ISO 8601 timestamp of the last update.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub updated_at: Option<String>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_tool_id() {\n        let id = ToolId::new(\"dev.example.fetch-url\");\n        assert!(id.is_ok());\n        assert_eq!(id.unwrap().as_str(), \"dev.example.fetch-url\");\n    }\n\n    #[test]\n    fn empty_tool_id_rejected() {\n        assert!(ToolId::new(\"\").is_err());\n    }\n\n    #[test]\n    fn tool_id_without_dot_rejected() {\n        assert!(ToolId::new(\"no-dot\").is_err());\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":20,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":21,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757116}},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783804}},{"line":26,"address":[],"length":0,"stats":{"Line":216172782113783804}},{"line":29,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":33,"address":[],"length":0,"stats":{"Line":5260204364768739331}},{"line":34,"address":[],"length":0,"stats":{"Line":5260204364768739331}},{"line":39,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":40,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":13,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","version.rs"],"content":"//! `ToolVersion` parsing and display.\n\nuse std::fmt;\nuse std::str::FromStr;\n\nuse crate::error::KamiError;\nuse crate::tool::ToolVersion;\n\nimpl fmt::Display for ToolVersion {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch)\n    }\n}\n\nimpl FromStr for ToolVersion {\n    type Err = KamiError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let parts: Vec<&str> = s.split('.').collect();\n        if parts.len() != 3 {\n            return Err(KamiError::invalid_input(\n                \"version must be in semver format: MAJOR.MINOR.PATCH\",\n            ));\n        }\n        let parse = |p: &str| -> Result<u32, KamiError> {\n            p.parse::<u32>()\n                .map_err(|_| KamiError::invalid_input(format!(\"invalid version component: {p}\")))\n        };\n        Ok(Self {\n            major: parse(parts[0])?,\n            minor: parse(parts[1])?,\n            patch: parse(parts[2])?,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn version_parse() {\n        let v: ToolVersion = \"1.2.3\".parse().unwrap();\n        assert_eq!(v, ToolVersion::new(1, 2, 3));\n    }\n\n    #[test]\n    fn version_display() {\n        let v = ToolVersion::new(0, 1, 0);\n        assert_eq!(v.to_string(), \"0.1.0\");\n    }\n\n    #[test]\n    fn invalid_version_rejected() {\n        assert!(\"1.2\".parse::<ToolVersion>().is_err());\n        assert!(\"a.b.c\".parse::<ToolVersion>().is_err());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":11,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":18,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":19,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":20,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":25,"address":[],"length":0,"stats":{"Line":5332261958806667263}},{"line":26,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":27,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":30,"address":[],"length":0,"stats":{"Line":2810246167479189502}},{"line":31,"address":[],"length":0,"stats":{"Line":2594073385365405694}},{"line":32,"address":[],"length":0,"stats":{"Line":2594073385365405694}}],"covered":13,"coverable":13},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","echo","src","lib.rs"],"content":"//! Echo KAMI tool — returns the input unchanged.\r\n//!\r\n//! Demonstrates the simplest possible tool: pass input through verbatim.\r\n\r\nuse kami_guest::kami_tool;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.echo\",\r\n    version: \"0.1.0\",\r\n    description: \"Echoes back the JSON input unchanged\",\r\n    handler: handle,\r\n}\r\n\r\nfn handle(input: &str) -> Result<String, String> {\r\n    // Validate that the input is valid JSON, then return it unmodified.\r\n    let _: serde_json::Value = serde_json::from_str(input)\r\n        .map_err(|e| format!(\"invalid JSON input: {e}\"))?;\r\n    Ok(input.to_string())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn echoes_object() {\r\n        let input = r#\"{\"key\":\"value\"}\"#;\r\n        let result = handle(input).unwrap();\r\n        assert_eq!(result, input);\r\n    }\r\n\r\n    #[test]\r\n    fn echoes_array() {\r\n        let input = r#\"[1,2,3]\"#;\r\n        let result = handle(input).unwrap();\r\n        assert_eq!(result, input);\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_invalid_json() {\r\n        let result = handle(\"not json\");\r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","hello-world","src","lib.rs"],"content":"//! Hello-world KAMI tool — minimal example.\r\n//!\r\n//! Takes a JSON `{ \"name\": \"...\" }` input and returns a greeting.\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.hello-world\",\r\n    version: \"0.1.0\",\r\n    description: \"Returns a greeting for the given name\",\r\n    handler: handle,\r\n}\r\n\r\n/// Input schema for the hello-world tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    name: String,\r\n}\r\n\r\nfn handle(input: &str) -> Result<String, String> {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    let greeting = format!(\"Hello, {}! Welcome to KAMI.\", args.name);\r\n    kami_guest::text_result(&greeting)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn greets_with_name() {\r\n        let result = handle(r#\"{\"name\":\"Alice\"}\"#).unwrap();\r\n        assert!(result.contains(\"Hello, Alice!\"));\r\n    }\r\n\r\n    #[test]\r\n    fn missing_name_returns_error() {\r\n        let result = handle(r#\"{}\"#);\r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","http-fetch","src","lib.rs"],"content":"//! HTTP fetch KAMI tool — demonstrates network access.\r\n//!\r\n//! Takes a URL and returns the HTTP response body.\r\n//! Requires `net_allow_list` in `tool.toml` to permit outbound connections.\r\n//!\r\n//! **Note:** This example shows the tool *logic* for URL validation and\r\n//! response formatting. Actual HTTP is performed by the WASI HTTP outgoing\r\n//! handler at runtime — the tool receives the response body from the host.\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.http-fetch\",\r\n    version: \"0.1.0\",\r\n    description: \"Fetches content from a URL via HTTP GET\",\r\n    handler: handle,\r\n}\r\n\r\n/// Maximum response size (64 KiB) to avoid unbounded memory usage.\r\nconst DEFAULT_MAX_BYTES: u64 = 65_536;\r\n\r\n/// Input schema for the http-fetch tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    /// URL to fetch (must start with `http://` or `https://`).\r\n    url: String,\r\n    /// Optional maximum response body size in bytes.\r\n    max_bytes: Option<u64>,\r\n}\r\n\r\n/// Validates that the URL has an acceptable scheme.\r\nfn validate_url(url: &str) -> Result<(), String> {\r\n    if !url.starts_with(\"http://\") && !url.starts_with(\"https://\") {\r\n        return Err(format!(\r\n            \"unsupported URL scheme: expected http:// or https://, got '{url}'\"\r\n        ));\r\n    }\r\n    if url.len() > 2048 {\r\n        return Err(\"URL exceeds maximum length (2048 bytes)\".to_string());\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn handle(input: &str) -> Result<String, String> {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    validate_url(&args.url)?;\r\n\r\n    let max = args.max_bytes.unwrap_or(DEFAULT_MAX_BYTES);\r\n\r\n    // In a real WASI HTTP tool, this would call wasi:http/outgoing-handler.\r\n    // Here we return a structured placeholder showing what would be fetched.\r\n    let response = serde_json::json!({\r\n        \"url\": args.url,\r\n        \"max_bytes\": max,\r\n        \"status\": \"ready\",\r\n        \"note\": \"Actual HTTP fetch requires wasi:http/outgoing-handler\"\r\n    });\r\n\r\n    kami_guest::text_result(&response.to_string())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn valid_https_url() {\r\n        let result = handle(r#\"{\"url\":\"https://example.com\"}\"#);\r\n        assert!(result.is_ok());\r\n        let body = result.unwrap();\r\n        assert!(body.contains(\"example.com\"));\r\n    }\r\n\r\n    #[test]\r\n    fn valid_http_url() {\r\n        let result = handle(r#\"{\"url\":\"http://api.local/data\"}\"#);\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_unsupported_scheme() {\r\n        let result = handle(r#\"{\"url\":\"ftp://evil.com/file\"}\"#);\r\n        assert!(result.is_err());\r\n        let err = result.unwrap_err();\r\n        assert!(err.contains(\"unsupported URL scheme\"));\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_missing_url() {\r\n        let result = handle(r#\"{}\"#);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn custom_max_bytes() {\r\n        let result = handle(r#\"{\"url\":\"https://example.com\",\"max_bytes\":1024}\"#);\r\n        assert!(result.is_ok());\r\n        let body = result.unwrap();\r\n        assert!(body.contains(\"1024\"));\r\n    }\r\n\r\n    #[test]\r\n    fn validate_url_rejects_too_long() {\r\n        let long = format!(\"https://example.com/{}\", \"a\".repeat(2040));\r\n        assert!(validate_url(&long).is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","json-transform","src","lib.rs"],"content":"//! JSON-transform KAMI tool — manipulate JSON objects.\r\n//!\r\n//! Supports three actions:\r\n//! - **pick**: Extract specific keys from an object\r\n//! - **flatten**: Flatten nested objects (dot-notation keys)\r\n//! - **count**: Count top-level keys in an object\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\nuse serde_json::{Map, Value};\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.json-transform\",\r\n    version: \"0.1.0\",\r\n    description: \"Transforms JSON data — pick, flatten, or count\",\r\n    handler: handle,\r\n}\r\n\r\n/// Input schema for the json-transform tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    action: String,\r\n    data: Value,\r\n    #[serde(default)]\r\n    keys: Vec<String>,\r\n}\r\n\r\nfn handle(input: &str) -> Result<String, String> {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    match args.action.as_str() {\r\n        \"pick\" => pick(&args.data, &args.keys),\r\n        \"flatten\" => flatten(&args.data),\r\n        \"count\" => count(&args.data),\r\n        other => Err(format!(\"unknown action: {other}\")),\r\n    }\r\n}\r\n\r\n/// Extracts only the specified keys from an object.\r\nfn pick(data: &Value, keys: &[String]) -> Result<String, String> {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    let picked: Map<String, Value> = keys\r\n        .iter()\r\n        .filter_map(|k| obj.get(k).map(|v| (k.clone(), v.clone())))\r\n        .collect();\r\n    kami_guest::to_output(&picked)\r\n}\r\n\r\n/// Flattens a nested object into dot-notation keys.\r\nfn flatten(data: &Value) -> Result<String, String> {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    let mut result = Map::new();\r\n    flatten_recursive(obj, String::new(), &mut result);\r\n    kami_guest::to_output(&result)\r\n}\r\n\r\n/// Recursively flattens nested objects using dot-separated keys.\r\nfn flatten_recursive(obj: &Map<String, Value>, prefix: String, out: &mut Map<String, Value>) {\r\n    for (key, value) in obj {\r\n        let full_key = if prefix.is_empty() {\r\n            key.clone()\r\n        } else {\r\n            format!(\"{prefix}.{key}\")\r\n        };\r\n        match value {\r\n            Value::Object(nested) => flatten_recursive(nested, full_key, out),\r\n            _ => {\r\n                out.insert(full_key, value.clone());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Counts the top-level keys in an object.\r\nfn count(data: &Value) -> Result<String, String> {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    kami_guest::text_result(&format!(\"{}\", obj.len()))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn pick_extracts_keys() {\r\n        let input = r#\"{\"action\":\"pick\",\"data\":{\"a\":1,\"b\":2,\"c\":3},\"keys\":[\"a\",\"c\"]}\"#;\r\n        let result = handle(input).expect(\"pick\");\r\n        let parsed: Value = serde_json::from_str(&result).expect(\"json\");\r\n        assert_eq!(parsed[\"a\"], 1);\r\n        assert_eq!(parsed[\"c\"], 3);\r\n        assert!(parsed.get(\"b\").is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn flatten_nested_objects() {\r\n        let input = r#\"{\"action\":\"flatten\",\"data\":{\"a\":{\"b\":1},\"c\":2}}\"#;\r\n        let result = handle(input).expect(\"flatten\");\r\n        let parsed: Value = serde_json::from_str(&result).expect(\"json\");\r\n        assert_eq!(parsed[\"a.b\"], 1);\r\n        assert_eq!(parsed[\"c\"], 2);\r\n    }\r\n\r\n    #[test]\r\n    fn count_keys() {\r\n        let input = r#\"{\"action\":\"count\",\"data\":{\"x\":1,\"y\":2,\"z\":3}}\"#;\r\n        let result = handle(input).expect(\"count\");\r\n        assert!(result.contains(\"3\"));\r\n    }\r\n\r\n    #[test]\r\n    fn unknown_action_returns_error() {\r\n        let input = r#\"{\"action\":\"nope\",\"data\":{}}\"#;\r\n        assert!(handle(input).is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn pick_with_non_object_returns_error() {\r\n        let input = r#\"{\"action\":\"pick\",\"data\":\"not-an-object\",\"keys\":[\"a\"]}\"#;\r\n        assert!(handle(input).is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","tests","fixtures","echo-tool","src","lib.rs"],"content":"//! Echo tool — KAMI demo guest component.\r\n//!\r\n//! Implements the `kami:tool/tool` WIT interface.\r\n//! Returns input unchanged as the output.\r\n\r\nwit_bindgen::generate!({\r\n    world: \"kami-tool\",\r\n    path: \"../../../wit\",\r\n});\r\n\r\nuse exports::kami::tool::tool::Guest;\r\n\r\nstruct EchoTool;\r\n\r\nimpl Guest for EchoTool {\r\n    fn run(input: String) -> Result<String, String> {\r\n        Ok(input)\r\n    }\r\n\r\n    fn describe() -> String {\r\n        r#\"{\"name\":\"echo\",\"description\":\"Echoes input back unchanged\",\"version\":\"1.0.0\"}\"#.to_string()\r\n    }\r\n}\r\n\r\nexport!(EchoTool);\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","tests","fixtures","echo-tool","target","release","build","serde-d7ab1670f4604dce","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","tests","fixtures","echo-tool","target","release","build","serde_core-95fdfd2202446d24","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":56.41509433962264,"covered":897,"coverable":1590}