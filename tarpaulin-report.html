<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","dev.rs"],"content":"//! Developer experience commands for KAMI tool authors.\n//!\n//! Provides `kami dev watch \u003ctool-dir\u003e` — rebuilds WASM on file changes.\n\nuse std::path::PathBuf;\nuse std::sync::mpsc;\nuse std::time::{Duration, Instant};\n\nuse clap::{Parser, Subcommand};\nuse notify::{Event, EventKind, RecursiveMode, Watcher};\n\n/// Developer experience commands.\n#[derive(Debug, Parser)]\npub struct DevArgs {\n    #[command(subcommand)]\n    command: DevCommand,\n}\n\n#[derive(Debug, Subcommand)]\nenum DevCommand {\n    /// Watch a tool directory and rebuild WASM on file changes.\n    Watch(WatchArgs),\n}\n\n/// Arguments for the watch subcommand.\n#[derive(Debug, Parser)]\npub struct WatchArgs {\n    /// Path to the tool project directory (contains Cargo.toml).\n    pub tool_dir: PathBuf,\n    /// Build in release mode.\n    #[arg(long)]\n    pub release: bool,\n}\n\n/// Dispatch to the appropriate dev subcommand.\n///\n/// # Errors\n/// Returns an error if the subcommand fails.\npub async fn execute(args: \u0026DevArgs) -\u003e anyhow::Result\u003c()\u003e {\n    match \u0026args.command {\n        DevCommand::Watch(watch) =\u003e run_watch(watch).await,\n    }\n}\n\n/// Watches a tool directory for source changes and rebuilds the WASM.\nasync fn run_watch(args: \u0026WatchArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let dir = args.tool_dir.canonicalize().map_err(|e| {\n        anyhow::anyhow!(\"invalid tool directory '{}': {e}\", args.tool_dir.display())\n    })?;\n    println!(\"[WATCH] monitoring {}\", dir.display());\n\n    let (tx, rx) = mpsc::channel::\u003cnotify::Result\u003cEvent\u003e\u003e();\n    let mut watcher = notify::recommended_watcher(move |ev| {\n        let _ = tx.send(ev);\n    })?;\n    watcher.watch(\u0026dir, RecursiveMode::Recursive)?;\n\n    // Initial build.\n    match build_wasm(\u0026dir, args.release) {\n        Ok(()) =\u003e println!(\"[OK] initial build succeeded\"),\n        Err(e) =\u003e eprintln!(\"[ERROR] initial build failed: {e}\"),\n    }\n\n    let debounce = Duration::from_millis(400);\n    let mut last_build = Instant::now();\n\n    loop {\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        let mut changed = false;\n        while let Ok(Ok(event)) = rx.try_recv() {\n            if is_source_event(\u0026event) {\n                changed = true;\n            }\n        }\n        if changed \u0026\u0026 last_build.elapsed() \u003e= debounce {\n            println!(\"[WATCH] change detected, rebuilding…\");\n            match build_wasm(\u0026dir, args.release) {\n                Ok(()) =\u003e println!(\"[OK] rebuild succeeded\"),\n                Err(e) =\u003e eprintln!(\"[ERROR] rebuild failed: {e}\"),\n            }\n            last_build = Instant::now();\n        }\n    }\n}\n\n/// Returns `true` if the event touched a `.rs` or `.toml` source file.\nfn is_source_event(event: \u0026Event) -\u003e bool {\n    let dominated = matches!(\n        event.kind,\n        EventKind::Create(_) | EventKind::Remove(_) | EventKind::Modify(_)\n    );\n    dominated\n        \u0026\u0026 event\n            .paths\n            .iter()\n            .any(|p| matches!(p.extension().and_then(|e| e.to_str()), Some(\"rs\" | \"toml\")))\n}\n\n/// Runs `cargo build --target wasm32-wasip2` in the given directory.\nfn build_wasm(dir: \u0026std::path::Path, release: bool) -\u003e anyhow::Result\u003c()\u003e {\n    let mut cmd = std::process::Command::new(\"cargo\");\n    cmd.arg(\"build\")\n        .arg(\"--target\")\n        .arg(\"wasm32-wasip2\")\n        .current_dir(dir);\n    if release {\n        cmd.arg(\"--release\");\n    }\n    let status = cmd\n        .status()\n        .map_err(|e| anyhow::anyhow!(\"failed to spawn cargo: {e}\"))?;\n    if status.success() {\n        Ok(())\n    } else {\n        Err(anyhow::anyhow!(\"cargo exited with {status}\"))\n    }\n}\n\n#[cfg(test)]\n#[path = \"dev_tests.rs\"]\nmod tests;\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":96,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":112,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":17,"coverable":46},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","dev_tests.rs"],"content":"//! Tests for the `kami dev` subcommands.\r\n\r\nuse super::*;\r\n\r\n#[test]\r\nfn rs_file_triggers_rebuild() {\r\n    let event = Event {\r\n        kind: EventKind::Create(notify::event::CreateKind::File),\r\n        paths: vec![PathBuf::from(\"src/lib.rs\")],\r\n        attrs: Default::default(),\r\n    };\r\n    assert!(is_source_event(\u0026event));\r\n}\r\n\r\n#[test]\r\nfn png_file_ignored() {\r\n    let event = Event {\r\n        kind: EventKind::Modify(notify::event::ModifyKind::Data(\r\n            notify::event::DataChange::Content,\r\n        )),\r\n        paths: vec![PathBuf::from(\"assets/logo.png\")],\r\n        attrs: Default::default(),\r\n    };\r\n    assert!(!is_source_event(\u0026event));\r\n}\r\n\r\n#[test]\r\nfn build_wasm_fails_without_cargo_toml() {\r\n    let tmp = std::env::temp_dir().join(\"kami_test_no_cargo\");\r\n    std::fs::create_dir_all(\u0026tmp).ok();\r\n    let result = build_wasm(\u0026tmp, false);\r\n    assert!(result.is_err());\r\n    std::fs::remove_dir_all(\u0026tmp).ok();\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","exec.rs"],"content":"//! `kami exec` command.\n//!\n//! Executes a tool by its registry ID using the full runtime pipeline:\n//! resolution, caching, scheduling, and sandboxed execution.\n\nuse clap::Args;\n\nuse kami_types::{DiagnosticError, ToolId};\n\nuse crate::{input, output, shared};\n\n/// Execute a registered tool by its ID.\n#[derive(Debug, Args)]\npub struct ExecArgs {\n    /// Tool ID (reverse-domain notation, e.g. dev.example.fetch-url).\n    pub tool: String,\n    /// JSON input string to pass to the tool's `run` function.\n    #[arg(short, long, default_value = \"{}\")]\n    pub input: String,\n    /// Read JSON input from a file (use \"-\" for stdin).\n    #[arg(short = 'f', long)]\n    pub input_file: Option\u003cString\u003e,\n    /// Maximum concurrent tool executions.\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size.\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the exec command.\npub async fn execute(args: \u0026ExecArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let resolved_input = input::resolve_input(\u0026args.input, args.input_file.as_deref())?;\n\n    let repo = shared::open_repository(\u0026args.db)?;\n    let tool_id = ToolId::new(\u0026args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let runtime = shared::create_runtime(repo, args.concurrency, args.cache_size)?;\n\n    tracing::info!(\n        tool = %args.tool,\n        input = %resolved_input,\n        \"Executing tool from registry\"\n    );\n\n    let result = runtime\n        .execute(\u0026tool_id, \u0026resolved_input)\n        .await\n        .map_err(|e| {\n            if let Some(hint) = e.hint() {\n                eprintln!(\"\\n  Cause: {hint}\");\n            }\n            if let Some(fix) = e.fix() {\n                eprintln!(\"  Fix:   {fix}\\n\");\n            }\n            anyhow::anyhow!(\"execution failed: {e}\")\n        })?;\n\n    if result.success {\n        println!(\"{}\", result.content);\n    } else {\n        output::print_error(\u0026result.content);\n    }\n\n    tracing::debug!(\n        duration_ms = result.duration_ms,\n        fuel_consumed = result.fuel_consumed,\n        success = result.success,\n        \"Execution complete\"\n    );\n\n    Ok(())\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","init.rs"],"content":"//! `kami init` command.\n//!\n//! Scaffolds a new KAMI tool project with Cargo.toml, tool.toml,\n//! and a minimal src/lib.rs handler.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse crate::commands::templates;\nuse crate::output;\n\n/// Scaffold a new KAMI tool project.\n#[derive(Debug, Args)]\npub struct InitArgs {\n    /// Tool name (e.g. \"my-tool\"). Used for directory and crate name.\n    pub name: String,\n    /// Reverse-domain prefix for the tool ID (e.g. \"dev.example\").\n    #[arg(short, long, default_value = \"dev.example\")]\n    pub prefix: String,\n}\n\n/// Executes the init command in the current working directory.\npub fn execute(args: \u0026InitArgs) -\u003e anyhow::Result\u003c()\u003e {\n    execute_at(args, Path::new(\".\"))\n}\n\n/// Executes the init command with an explicit base directory (testable).\npub(crate) fn execute_at(args: \u0026InitArgs, base_dir: \u0026Path) -\u003e anyhow::Result\u003c()\u003e {\n    let dir = base_dir.join(\u0026args.name);\n    if dir.exists() {\n        anyhow::bail!(\"directory already exists: {}\", dir.display());\n    }\n\n    let tool_id = format!(\"{}.{}\", args.prefix, args.name);\n    let crate_name = args.name.replace('-', \"_\");\n\n    std::fs::create_dir_all(dir.join(\"src\"))?;\n\n    write_cargo_toml(\u0026dir, \u0026args.name)?;\n    write_tool_toml(\u0026dir, \u0026tool_id, \u0026args.name, \u0026crate_name)?;\n    write_lib_rs(\u0026dir, \u0026tool_id)?;\n    std::fs::write(dir.join(\".gitignore\"), templates::GITIGNORE)?;\n\n    print_success(\u0026args.name, \u0026crate_name);\n    Ok(())\n}\n\nfn write_cargo_toml(dir: \u0026Path, name: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    let content = templates::apply(templates::CARGO_TOML, \u0026[(\"__TOOL_NAME__\", name)]);\n    std::fs::write(dir.join(\"Cargo.toml\"), content)?;\n    Ok(())\n}\n\nfn write_tool_toml(dir: \u0026Path, tool_id: \u0026str, name: \u0026str, crate_name: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    let content = templates::apply(\n        templates::TOOL_TOML,\n        \u0026[\n            (\"__TOOL_ID__\", tool_id),\n            (\"__TOOL_NAME__\", name),\n            (\"__CRATE_NAME__\", crate_name),\n        ],\n    );\n    std::fs::write(dir.join(\"tool.toml\"), content)?;\n    Ok(())\n}\n\nfn write_lib_rs(dir: \u0026Path, tool_id: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    let content = templates::apply(templates::LIB_RS, \u0026[(\"__TOOL_ID__\", tool_id)]);\n    std::fs::write(dir.join(\"src\").join(\"lib.rs\"), content)?;\n    Ok(())\n}\n\nfn print_success(name: \u0026str, crate_name: \u0026str) {\n    output::print_success(\u0026format!(\"Created tool project: {name}/\"));\n    println!();\n    println!(\"  {name}/\");\n    println!(\"  ├── Cargo.toml\");\n    println!(\"  ├── tool.toml\");\n    println!(\"  ├── .gitignore\");\n    println!(\"  └── src/\");\n    println!(\"      └── lib.rs\");\n    println!();\n    println!(\"Next steps:\");\n    println!(\"  cd {name}\");\n    println!(\"  cargo build --target wasm32-wasip2 --release\");\n    println!(\"  cp target/wasm32-wasip2/release/{crate_name}.wasm .\");\n    println!(\"  kami validate .\");\n    println!(\"  kami install .\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn init_creates_expected_files() {\n        let tmp = tempfile::tempdir().expect(\"tempdir\");\n        let args = InitArgs {\n            name: \"test-tool\".to_string(),\n            prefix: \"dev.test\".to_string(),\n        };\n        execute_at(\u0026args, tmp.path()).expect(\"init\");\n\n        let base = tmp.path().join(\"test-tool\");\n        assert!(base.join(\"Cargo.toml\").exists());\n        assert!(base.join(\"tool.toml\").exists());\n        assert!(base.join(\"src/lib.rs\").exists());\n        assert!(base.join(\".gitignore\").exists());\n\n        let cargo = std::fs::read_to_string(base.join(\"Cargo.toml\")).expect(\"read Cargo.toml\");\n        assert!(cargo.contains(\"name = \\\"test-tool\\\"\"));\n        assert!(cargo.contains(\"path = \\\"../crates/kami-guest\\\"\"));\n\n        let tool = std::fs::read_to_string(base.join(\"tool.toml\")).expect(\"read tool.toml\");\n        assert!(tool.contains(\"id = \\\"dev.test.test-tool\\\"\"));\n\n        let lib = std::fs::read_to_string(base.join(\"src/lib.rs\")).expect(\"read lib.rs\");\n        assert!(lib.contains(\"name: \\\"dev.test.test-tool\\\"\"));\n    }\n\n    #[test]\n    fn init_fails_if_dir_exists() {\n        let tmp = tempfile::tempdir().expect(\"tempdir\");\n        std::fs::create_dir_all(tmp.path().join(\"existing\")).expect(\"mkdir\");\n        let args = InitArgs {\n            name: \"existing\".to_string(),\n            prefix: \"dev.test\".to_string(),\n        };\n        assert!(execute_at(\u0026args, tmp.path()).is_err());\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":45,"coverable":47},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","inspect.rs"],"content":"//! `kami inspect` command.\n//!\n//! Displays detailed information about an installed tool.\n\nuse clap::Args;\n\nuse kami_types::ToolId;\n\nuse crate::{output, shared};\n\n/// Inspect a tool's manifest and capabilities.\n#[derive(Debug, Args)]\npub struct InspectArgs {\n    /// Tool ID (reverse-domain notation).\n    pub tool: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the inspect command.\npub async fn execute(args: \u0026InspectArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    let id = ToolId::new(\u0026args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let tool = repo\n        .find_by_id(\u0026id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"query error: {e}\"))?;\n\n    let tool = match tool {\n        Some(t) =\u003e t,\n        None =\u003e {\n            output::print_error(\u0026format!(\"tool not found: {}\", args.tool));\n            return Ok(());\n        }\n    };\n\n    let m = \u0026tool.manifest;\n    let sec = \u0026m.security;\n\n    println!(\"Tool: {} v{}\", m.id, m.version);\n    println!(\"Name: {}\", m.name);\n    println!(\"Description: {}\", m.description);\n    println!(\"WASM: {}\", m.wasm);\n    println!(\"Install path: {}\", tool.install_path);\n    println!(\n        \"Status: {}\",\n        if tool.enabled { \"enabled\" } else { \"disabled\" }\n    );\n\n    println!(\"\\nSecurity:\");\n    println!(\"  Filesystem: {:?}\", sec.fs_access);\n    if sec.net_allow_list.is_empty() {\n        println!(\"  Network: deny-all\");\n    } else {\n        println!(\"  Network: {}\", sec.net_allow_list.join(\", \"));\n    }\n    if sec.env_allow_list.is_empty() {\n        println!(\"  Env vars: deny-all\");\n    } else {\n        println!(\"  Env vars: {}\", sec.env_allow_list.join(\", \"));\n    }\n\n    println!(\"\\nResource limits:\");\n    println!(\"  Memory: {} MB\", sec.limits.max_memory_mb);\n    println!(\"  Timeout: {} ms\", sec.limits.max_execution_ms);\n    println!(\"  Fuel: {}\", sec.limits.max_fuel);\n\n    if !m.arguments.is_empty() {\n        println!(\"\\nArguments:\");\n        for arg in \u0026m.arguments {\n            let req = if arg.required { \"required\" } else { \"optional\" };\n            println!(\n                \"  {} ({}, {}): {}\",\n                arg.name, arg.arg_type, req, arg.description\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","install.rs"],"content":"//! `kami install` command.\n//!\n//! Parses a tool.toml manifest, validates it, and registers the tool\n//! in the SQLite registry.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_runtime::compute_file_hash;\nuse kami_types::Tool;\n\nuse crate::{output, shared};\n\n/// Install a WASM tool into the registry.\n#[derive(Debug, Args)]\npub struct InstallArgs {\n    /// Path to the tool directory containing tool.toml.\n    pub path: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the install command.\npub async fn execute(args: \u0026InstallArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let tool_path = Path::new(\u0026args.path);\n\n    // Resolve tool.toml location\n    let manifest_path = if tool_path.is_dir() {\n        tool_path.join(\"tool.toml\")\n    } else if tool_path.extension().is_some_and(|e| e == \"toml\") {\n        tool_path.to_path_buf()\n    } else {\n        anyhow::bail!(\"expected a directory containing tool.toml or a .toml file\");\n    };\n\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found: {}\", manifest_path.display());\n    }\n\n    tracing::info!(\n        path = %manifest_path.display(),\n        \"Parsing tool manifest\"\n    );\n\n    // 1. Parse manifest\n    let mut manifest = parse_tool_manifest_file(\u0026manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    // 2. Verify WASM file exists and compute integrity hash\n    let tool_dir = manifest_path.parent().unwrap_or_else(|| Path::new(\".\"));\n    let wasm_path = tool_dir.join(\u0026manifest.wasm);\n    if !wasm_path.exists() {\n        anyhow::bail!(\n            \"WASM file not found: {} (referenced in tool.toml)\",\n            wasm_path.display()\n        );\n    }\n\n    let wasm_hash = compute_file_hash(\u0026wasm_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to hash WASM file: {e}\"))?;\n\n    tracing::info!(\n        hash = %wasm_hash,\n        \"SHA-256 computed for WASM file\"\n    );\n\n    manifest.wasm_sha256 = Some(wasm_hash);\n\n    // 3. Open registry\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    // 4. Check for duplicates\n    if let Some(existing) = repo\n        .find_by_id(\u0026manifest.id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?\n    {\n        anyhow::bail!(\n            \"tool {} v{} is already installed\",\n            existing.manifest.id,\n            existing.manifest.version,\n        );\n    }\n\n    // 5. Register the tool\n    let install_path = tool_dir\n        .canonicalize()\n        .unwrap_or_else(|_| tool_dir.to_path_buf())\n        .display()\n        .to_string();\n\n    let tool = Tool {\n        manifest,\n        install_path,\n        enabled: true,\n        pinned_version: None,\n        updated_at: None,\n    };\n\n    repo.insert(\u0026tool)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"insert error: {e}\"))?;\n\n    output::print_success(\u0026format!(\n        \"Installed {} v{}\",\n        tool.manifest.id, tool.manifest.version\n    ));\n\n    Ok(())\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","list.rs"],"content":"//! `kami list` command.\n//!\n//! Lists installed tools from the SQLite registry.\n\nuse clap::Args;\n\nuse kami_registry::ToolQuery;\n\nuse crate::shared;\n\n/// List installed tools.\n#[derive(Debug, Args)]\npub struct ListArgs {\n    /// Filter by name (substring match).\n    #[arg(short, long)]\n    pub filter: Option\u003cString\u003e,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the list command.\npub async fn execute(args: \u0026ListArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    let mut query = ToolQuery::all();\n    if let Some(ref name) = args.filter {\n        query = query.with_name(name);\n    }\n\n    let tools = repo\n        .find_all(query)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"query error: {e}\"))?;\n\n    if tools.is_empty() {\n        println!(\"No tools installed.\");\n        return Ok(());\n    }\n\n    println!(\"{:\u003c35} {:\u003c10} {:\u003c8} DESCRIPTION\", \"ID\", \"VERSION\", \"STATUS\");\n    println!(\"{}\", \"-\".repeat(80));\n\n    for tool in \u0026tools {\n        let status = if tool.enabled { \"enabled\" } else { \"disabled\" };\n        println!(\n            \"{:\u003c35} {:\u003c10} {:\u003c8} {}\",\n            tool.manifest.id, tool.manifest.version, status, tool.manifest.description,\n        );\n    }\n\n    println!(\"\\n{} tool(s) installed.\", tools.len());\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","mod.rs"],"content":"//! CLI command definitions.\n\npub mod dev;\npub mod exec;\npub mod init;\npub mod inspect;\npub mod install;\npub mod list;\npub mod pin;\npub mod run;\npub mod serve;\npub mod status;\npub mod templates;\npub mod uninstall;\npub mod update;\npub mod validate;\npub mod verify;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","pin.rs"],"content":"//! `kami pin` command.\n//!\n//! Pins a tool to its current version (or a specified version),\n//! preventing `kami update` from changing it. Use `--unpin` to remove.\n\nuse clap::Args;\n\nuse crate::{output, shared};\n\n/// Pin or unpin a tool version.\n#[derive(Debug, Args)]\npub struct PinArgs {\n    /// Tool ID to pin/unpin.\n    pub tool_id: String,\n    /// Version to pin to (defaults to the currently installed version).\n    pub version: Option\u003cString\u003e,\n    /// Remove the version pin.\n    #[arg(long)]\n    pub unpin: bool,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the pin command.\npub async fn execute(args: \u0026PinArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n    let id: kami_types::ToolId = args.tool_id.parse().map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n\n    let mut tool = repo\n        .find_by_id(\u0026id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool not found: {id}\"))?;\n\n    if args.unpin {\n        tool.pinned_version = None;\n        repo.update(\u0026tool)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n        output::print_success(\u0026format!(\"Unpinned {id}\"));\n        return Ok(());\n    }\n\n    let pin_ver = args\n        .version\n        .clone()\n        .unwrap_or_else(|| tool.manifest.version.to_string());\n\n    tool.pinned_version = Some(pin_ver.clone());\n    repo.update(\u0026tool)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    output::print_success(\u0026format!(\"Pinned {id} to v{pin_ver}\"));\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pin_args_default_unpin_is_false() {\n        let args = PinArgs {\n            tool_id: \"dev.test.x\".to_string(),\n            version: None,\n            unpin: false,\n            db: None,\n        };\n        assert!(!args.unpin);\n        assert!(args.version.is_none());\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","run.rs"],"content":"//! `kami run` command.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_engine::{create_engine, create_linker, load_component_from_file, InstanceConfig};\nuse kami_runtime::{ToolExecutor, WasmToolExecutor};\nuse kami_types::{ResourceLimits, SecurityConfig};\n\nuse crate::input;\n\n/// Run a WASM component directly from a file.\n#[derive(Debug, Args)]\npub struct RunArgs {\n    /// Path to the .wasm component file.\n    pub wasm_file: String,\n    /// JSON input string to pass to the tool's `run` function.\n    #[arg(short, long, default_value = \"{}\")]\n    pub input: String,\n    /// Read JSON input from a file (use \"-\" for stdin).\n    #[arg(short = 'f', long)]\n    pub input_file: Option\u003cString\u003e,\n    /// Fuel limit for execution.\n    #[arg(short, long, default_value = \"1000000\")]\n    pub fuel: u64,\n    /// Maximum memory in MB.\n    #[arg(short, long, default_value = \"64\")]\n    pub max_memory_mb: u32,\n    /// Execution timeout in milliseconds.\n    #[arg(short, long, default_value = \"5000\")]\n    pub timeout_ms: u64,\n}\n\n/// Executes the run command using the async runtime.\npub async fn execute(args: \u0026RunArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let wasm_path = Path::new(\u0026args.wasm_file);\n    if !wasm_path.exists() {\n        anyhow::bail!(\"WASM file not found: {}\", args.wasm_file);\n    }\n\n    let resolved_input = input::resolve_input(\u0026args.input, args.input_file.as_deref())?;\n\n    tracing::info!(path = %args.wasm_file, \"Loading WASM component\");\n\n    // 1. Create engine and linker (epoch interruption for timeout)\n    let config = InstanceConfig {\n        epoch_interruption: true,\n        ..InstanceConfig::default()\n    };\n    let engine = create_engine(\u0026config)?;\n    let linker = create_linker(\u0026engine)?;\n\n    // 2. Load the component\n    let component = load_component_from_file(\u0026engine, wasm_path)?;\n\n    // 3. Build security config from CLI args\n    let security = SecurityConfig {\n        limits: ResourceLimits {\n            max_fuel: args.fuel,\n            max_memory_mb: args.max_memory_mb,\n            max_execution_ms: args.timeout_ms,\n        },\n        ..SecurityConfig::default()\n    };\n\n    // 4. Execute with full isolation\n    let executor = WasmToolExecutor::new(engine, linker);\n\n    tracing::info!(\n        input = %resolved_input,\n        fuel = args.fuel,\n        max_memory_mb = args.max_memory_mb,\n        timeout_ms = args.timeout_ms,\n        \"Executing tool\"\n    );\n\n    let result = executor\n        .execute(\u0026component, \u0026resolved_input, \u0026security)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"execution failed: {e}\"))?;\n\n    // 5. Output result\n    if result.success {\n        println!(\"{}\", result.content);\n    } else {\n        eprintln!(\"[ERROR] {}\", result.content);\n    }\n    tracing::debug!(\n        duration_ms = result.duration_ms,\n        fuel_consumed = result.fuel_consumed,\n        success = result.success,\n        \"Execution complete\"\n    );\n\n    Ok(())\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","serve.rs"],"content":"//! `kami serve` command.\n//!\n//! Starts the MCP server over stdio or HTTP, exposing registered tools\n//! via JSON-RPC 2.0.\n\nuse std::sync::Arc;\n\nuse clap::Args;\n\nuse kami_transport_http::HttpServer;\nuse kami_transport_stdio::{McpHandler, McpServer, StdioTransport};\n\nuse crate::shared;\n\n/// Start the MCP server (stdio or HTTP).\n#[derive(Debug, Args)]\npub struct ServeArgs {\n    /// Transport mode: stdio (default) or http.\n    #[arg(long, default_value = \"stdio\", value_parser = [\"stdio\", \"http\"])]\n    pub transport: String,\n    /// TCP port for HTTP transport.\n    #[arg(long, default_value = \"3000\")]\n    pub port: u16,\n    /// Bearer token for HTTP transport authentication (optional).\n    #[arg(long)]\n    pub token: Option\u003cString\u003e,\n    /// Maximum concurrent tool executions.\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size.\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the serve command.\npub async fn execute(args: \u0026ServeArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n    let runtime = Arc::new(shared::create_runtime(\n        repo.clone(),\n        args.concurrency,\n        args.cache_size,\n    )?);\n\n    match args.transport.as_str() {\n        \"http\" =\u003e {\n            let handler = Arc::new(McpHandler::new(runtime.clone(), repo));\n            let server = HttpServer::new(handler, args.port, args.token.clone());\n            tokio::select! {\n                result = server.run() =\u003e {\n                    result.map_err(|e| anyhow::anyhow!(\"server error: {e}\"))?;\n                }\n                _ = tokio::signal::ctrl_c() =\u003e {\n                    tracing::info!(\"shutdown signal received\");\n                    runtime.shutdown().await;\n                }\n            }\n        }\n        _ =\u003e {\n            let handler = McpHandler::new(runtime.clone(), repo);\n            let transport = StdioTransport::new(tokio::io::stdin(), tokio::io::stdout());\n            let mut server = McpServer::new(transport, handler);\n            tracing::info!(\"KAMI MCP server ready on stdio\");\n            tokio::select! {\n                result = server.run() =\u003e {\n                    result.map_err(|e| anyhow::anyhow!(\"server error: {e}\"))?;\n                }\n                _ = tokio::signal::ctrl_c() =\u003e {\n                    tracing::info!(\"shutdown signal received\");\n                    runtime.shutdown().await;\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","status.rs"],"content":"//! `kami status` command.\n//!\n//! Displays tool registry statistics and runtime configuration.\n\nuse clap::Args;\n\nuse kami_registry::ToolQuery;\n\nuse crate::output;\nuse crate::shared;\n\n/// Show KAMI runtime status and installed tool statistics.\n#[derive(Debug, Args)]\npub struct StatusArgs {\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n    /// Maximum concurrent tool executions (for display).\n    #[arg(long, default_value = \"4\")]\n    pub concurrency: usize,\n    /// Component cache size in slots (for display).\n    #[arg(long, default_value = \"32\")]\n    pub cache_size: usize,\n}\n\n/// Executes the status command.\npub async fn execute(args: \u0026StatusArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n    let tools = repo\n        .find_all(ToolQuery::all())\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry query: {e}\"))?;\n\n    let enabled = tools.iter().filter(|t| t.enabled).count();\n    let disabled = tools.len() - enabled;\n    let db_path = args.db.clone().unwrap_or_else(output::default_db_path);\n\n    println!(\"KAMI Runtime Status\");\n    println!(\"{}\", \"─\".repeat(40));\n    println!(\"  Version    : {}\", env!(\"CARGO_PKG_VERSION\"));\n    println!(\"  Database   : {db_path}\");\n    println!();\n    println!(\"Tool Registry\");\n    println!(\"  Total    : {}\", tools.len());\n    println!(\"  Enabled  : {enabled}\");\n    println!(\"  Disabled : {disabled}\");\n    println!();\n    println!(\"Runtime Configuration\");\n    println!(\n        \"  Concurrency : {} max parallel executions\",\n        args.concurrency\n    );\n    println!(\"  Cache       : {} component slots\", args.cache_size);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn status_args_defaults() {\n        let args = StatusArgs {\n            db: None,\n            concurrency: 4,\n            cache_size: 32,\n        };\n        assert_eq!(args.concurrency, 4);\n        assert_eq!(args.cache_size, 32);\n        assert!(args.db.is_none());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","templates.rs"],"content":"//! Source code templates for `kami init` scaffolding.\n//! Uses `__PLACEHOLDER__` substitution to avoid brace escaping in generated Rust.\n\n/// Cargo.toml template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_NAME__`\npub const CARGO_TOML: \u0026str = r#\"[package]\nname = \"__TOOL_NAME__\"\nversion = \"1.0.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nkami-guest = { path = \"../crates/kami-guest\" }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\n\"#;\n\n/// tool.toml template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_ID__`, `__TOOL_NAME__`, `__CRATE_NAME__`\npub const TOOL_TOML: \u0026str = r#\"[tool]\nid = \"__TOOL_ID__\"\nname = \"__TOOL_NAME__\"\nversion = \"1.0.0\"\nwasm = \"__CRATE_NAME__.wasm\"\n\n[mcp]\ndescription = \"TODO: Describe what this tool does\"\n\n[[mcp.arguments]]\nname = \"input\"\ntype = \"string\"\ndescription = \"TODO: Describe this argument\"\nrequired = true\n\n[security]\nnet_allow_list = []\nfs_access = \"none\"\nmax_memory_mb = 32\nmax_execution_ms = 5000\nmax_fuel = 1000000\n\"#;\n\n/// src/lib.rs template for a new KAMI tool project.\n///\n/// Placeholders: `__TOOL_ID__`\n/// Uses `r##\"...\"##` delimiter so the template can contain `\"#` sequences.\npub const LIB_RS: \u0026str = r##\"use kami_guest::kami_tool;\n\nkami_tool! {\n    name: \"__TOOL_ID__\",\n    version: \"1.0.0\",\n    description: \"TODO: Describe what this tool does\",\n    handler: handle,\n}\n\nfn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\n    let args: serde_json::Value = serde_json::from_str(input)\n        .map_err(|e| format!(\"invalid JSON: {e}\"))?;\n\n    let response = serde_json::json!({\n        \"result\": args,\n        \"tool\": \"__TOOL_ID__\"\n    });\n\n    Ok(response.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_input() {\n        let result = handle(r#\"{\"input\":\"hello\"}\"#);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn invalid_input() {\n        let result = handle(\"not json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn empty_input() {\n        let result = handle(\"{}\");\n        assert!(result.is_ok());\n    }\n}\n\"##;\n\n/// .gitignore template.\npub const GITIGNORE: \u0026str = \"target/\\n*.wasm\\n\";\n\n/// Applies placeholder substitutions to a template string.\n///\n/// `substitutions` is a slice of `(placeholder, value)` pairs.\npub fn apply(template: \u0026str, substitutions: \u0026[(\u0026str, \u0026str)]) -\u003e String {\n    substitutions\n        .iter()\n        .fold(template.to_string(), |acc, (key, val)| {\n            acc.replace(key, val)\n        })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn apply_single_substitution() {\n        let result = apply(\"Hello __NAME__!\", \u0026[(\"__NAME__\", \"KAMI\")]);\n        assert_eq!(result, \"Hello KAMI!\");\n    }\n\n    #[test]\n    fn apply_multiple_substitutions() {\n        let result = apply(\"__A__ and __B__\", \u0026[(\"__A__\", \"foo\"), (\"__B__\", \"bar\")]);\n        assert_eq!(result, \"foo and bar\");\n    }\n\n    #[test]\n    fn apply_repeated_placeholder() {\n        let result = apply(\"__X__ + __X__\", \u0026[(\"__X__\", \"hello\")]);\n        assert_eq!(result, \"hello + hello\");\n    }\n\n    #[test]\n    fn cargo_toml_substitution() {\n        let result = apply(CARGO_TOML, \u0026[(\"__TOOL_NAME__\", \"my-tool\")]);\n        assert!(result.contains(\"name = \\\"my-tool\\\"\"));\n    }\n\n    #[test]\n    fn lib_rs_substitution() {\n        let result = apply(LIB_RS, \u0026[(\"__TOOL_ID__\", \"dev.test.tool\")]);\n        assert!(result.contains(\"name: \\\"dev.test.tool\\\"\"));\n        assert!(result.contains(\"\\\"tool\\\": \\\"dev.test.tool\\\"\"));\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":105,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":106,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":4,"coverable":4},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","uninstall.rs"],"content":"//! `kami uninstall` command.\n//!\n//! Removes a tool from the registry by its ID.\n\nuse clap::Args;\n\nuse kami_types::ToolId;\n\nuse crate::{output, shared};\n\n/// Uninstall a tool from the registry.\n#[derive(Debug, Args)]\npub struct UninstallArgs {\n    /// Tool ID to remove (e.g. dev.example.fetch-url).\n    pub tool: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the uninstall command.\npub async fn execute(args: \u0026UninstallArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let tool_id = ToolId::new(\u0026args.tool).map_err(|e| anyhow::anyhow!(\"invalid tool ID: {e}\"))?;\n\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    // Check if tool exists before deleting\n    let existing = repo\n        .find_by_id(\u0026tool_id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?;\n\n    match existing {\n        Some(tool) =\u003e {\n            repo.delete(\u0026tool_id)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"delete error: {e}\"))?;\n\n            output::print_success(\u0026format!(\n                \"Uninstalled {} v{}\",\n                tool.manifest.id, tool.manifest.version\n            ));\n        }\n        None =\u003e {\n            anyhow::bail!(\"tool not found: {}\", args.tool);\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","update.rs"],"content":"//! `kami update` command.\n//!\n//! Re-reads tool.toml from the install path and updates the registry\n//! entry with new manifest data and a fresh WASM hash.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_registry::ToolRepository;\nuse kami_runtime::compute_file_hash;\nuse kami_types::Tool;\n\nuse crate::{output, shared};\n\n/// Update one or all installed tools from their source directories.\n#[derive(Debug, Args)]\npub struct UpdateArgs {\n    /// Tool ID to update (omit for --all).\n    pub tool_id: Option\u003cString\u003e,\n    /// Update all installed tools.\n    #[arg(long)]\n    pub all: bool,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the update command.\npub async fn execute(args: \u0026UpdateArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    if args.all {\n        return update_all(\u0026*repo).await;\n    }\n    let id_str = args\n        .tool_id\n        .as_deref()\n        .ok_or_else(|| anyhow::anyhow!(\"provide a tool ID or use --all\"))?;\n    let id = id_str.parse().map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    update_one(\u0026*repo, \u0026id).await\n}\n\n/// Updates a single tool by re-reading its source manifest.\nasync fn update_one(repo: \u0026dyn ToolRepository, id: \u0026kami_types::ToolId) -\u003e anyhow::Result\u003c()\u003e {\n    let existing = repo\n        .find_by_id(id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool not found: {id}\"))?;\n\n    if existing.pinned_version.is_some() {\n        anyhow::bail!(\n            \"tool {} is pinned to v{}; unpin first with `kami pin --unpin {}`\",\n            id,\n            existing.pinned_version.as_deref().unwrap_or(\"?\"),\n            id,\n        );\n    }\n\n    let updated = rebuild_tool(\u0026existing)?;\n    repo.update(\u0026updated)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    output::print_success(\u0026format!(\n        \"Updated {} → v{}\",\n        updated.manifest.id, updated.manifest.version\n    ));\n    Ok(())\n}\n\n/// Re-reads tool.toml and recomputes the WASM hash.\nfn rebuild_tool(existing: \u0026Tool) -\u003e anyhow::Result\u003cTool\u003e {\n    let install = Path::new(\u0026existing.install_path);\n    let manifest_path = install.join(\"tool.toml\");\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found at {}\", manifest_path.display());\n    }\n    let mut manifest = parse_tool_manifest_file(\u0026manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    let wasm_path = install.join(\u0026manifest.wasm);\n    if wasm_path.exists() {\n        let hash = compute_file_hash(\u0026wasm_path).map_err(|e| anyhow::anyhow!(\"hash error: {e}\"))?;\n        manifest.wasm_sha256 = Some(hash);\n    }\n\n    let now = chrono_now();\n    Ok(Tool {\n        manifest,\n        install_path: existing.install_path.clone(),\n        enabled: existing.enabled,\n        pinned_version: existing.pinned_version.clone(),\n        updated_at: Some(now),\n    })\n}\n\n/// Returns the current UTC time in ISO 8601 format (no chrono dep).\nfn chrono_now() -\u003e String {\n    let dur = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap_or_default();\n    let secs = dur.as_secs();\n    format!(\"{secs}\")\n}\n\n/// Updates every installed tool that is not pinned.\nasync fn update_all(repo: \u0026dyn ToolRepository) -\u003e anyhow::Result\u003c()\u003e {\n    let tools = repo\n        .find_all(kami_registry::ToolQuery::all())\n        .await\n        .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n    if tools.is_empty() {\n        output::print_info(\"No tools installed.\");\n        return Ok(());\n    }\n    let mut updated = 0u32;\n    let mut skipped = 0u32;\n    for tool in \u0026tools {\n        if tool.pinned_version.is_some() {\n            skipped += 1;\n            continue;\n        }\n        match rebuild_tool(tool) {\n            Ok(new_tool) =\u003e {\n                repo.update(\u0026new_tool)\n                    .await\n                    .map_err(|e| anyhow::anyhow!(\"{e}\"))?;\n                updated += 1;\n            }\n            Err(e) =\u003e {\n                tracing::warn!(tool = %tool.manifest.id, \"skip: {e}\");\n                skipped += 1;\n            }\n        }\n    }\n    output::print_success(\u0026format!(\"Updated {updated} tool(s), skipped {skipped}\"));\n    Ok(())\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":74},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","validate.rs"],"content":"//! `kami validate` command.\n//!\n//! Validates a tool.toml manifest and checks that the referenced\n//! WASM file exists. Useful before `kami install`.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_config::parse_tool_manifest_file;\nuse kami_sandbox::validate_security_config;\n\nuse crate::output;\n\n/// Validate a tool.toml manifest without installing.\n#[derive(Debug, Args)]\npub struct ValidateArgs {\n    /// Path to tool directory or tool.toml file.\n    pub path: String,\n}\n\n/// Executes the validate command.\npub fn execute(args: \u0026ValidateArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let tool_path = Path::new(\u0026args.path);\n\n    // Resolve tool.toml location\n    let manifest_path = if tool_path.is_dir() {\n        tool_path.join(\"tool.toml\")\n    } else if tool_path.extension().is_some_and(|e| e == \"toml\") {\n        tool_path.to_path_buf()\n    } else {\n        anyhow::bail!(\"expected a directory containing tool.toml or a .toml file\");\n    };\n\n    if !manifest_path.exists() {\n        anyhow::bail!(\"tool.toml not found: {}\", manifest_path.display());\n    }\n\n    // 1. Parse manifest\n    println!(\"Checking manifest...\");\n    let manifest = parse_tool_manifest_file(\u0026manifest_path)\n        .map_err(|e| anyhow::anyhow!(\"manifest error: {e}\"))?;\n\n    println!(\"  ID:          {}\", manifest.id);\n    println!(\"  Name:        {}\", manifest.name);\n    println!(\"  Version:     {}\", manifest.version);\n    println!(\"  Description: {}\", manifest.description);\n\n    // 2. Validate security config\n    println!(\"Checking security config...\");\n    validate_security_config(\u0026manifest.security)\n        .map_err(|e| anyhow::anyhow!(\"security config error: {e}\"))?;\n\n    println!(\n        \"  Network:     {} host(s) allowed\",\n        manifest.security.net_allow_list.len()\n    );\n    println!(\"  Filesystem:  {:?}\", manifest.security.fs_access);\n    println!(\"  Fuel:        {}\", manifest.security.limits.max_fuel);\n    println!(\n        \"  Memory:      {} MB\",\n        manifest.security.limits.max_memory_mb\n    );\n    println!(\n        \"  Timeout:     {} ms\",\n        manifest.security.limits.max_execution_ms\n    );\n\n    // 3. Check WASM file\n    println!(\"Checking WASM file...\");\n    let tool_dir = manifest_path.parent().unwrap_or_else(|| Path::new(\".\"));\n    let wasm_path = tool_dir.join(\u0026manifest.wasm);\n\n    if wasm_path.exists() {\n        let metadata = std::fs::metadata(\u0026wasm_path)?;\n        println!(\n            \"  WASM:        {} ({} bytes)\",\n            manifest.wasm,\n            metadata.len()\n        );\n    } else {\n        anyhow::bail!(\n            \"WASM file not found: {} (referenced in tool.toml)\",\n            wasm_path.display()\n        );\n    }\n\n    // 4. Check arguments\n    println!(\n        \"Checking arguments... ({} defined)\",\n        manifest.arguments.len()\n    );\n    for arg in \u0026manifest.arguments {\n        let req = if arg.required { \"required\" } else { \"optional\" };\n        println!(\"  {}: {} ({})\", arg.name, arg.arg_type, req);\n    }\n\n    output::print_success(\u0026format!(\n        \"Tool {} v{} is valid\",\n        manifest.id, manifest.version\n    ));\n\n    Ok(())\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","commands","verify.rs"],"content":"//! `kami verify` command.\n//!\n//! Verifies the SHA-256 integrity of an installed tool's WASM file.\n//! Compares the stored hash (recorded at install time) with the\n//! current hash of the file on disk.\n\nuse std::path::Path;\n\nuse clap::Args;\n\nuse kami_runtime::compute_file_hash;\n\nuse crate::{output, shared};\n\n/// Verify the integrity of an installed tool's WASM file.\n#[derive(Debug, Args)]\npub struct VerifyArgs {\n    /// Tool ID to verify (e.g. dev.example.fetch-url).\n    pub tool_id: String,\n    /// Database path (defaults to .kami/registry.db).\n    #[arg(long)]\n    pub db: Option\u003cString\u003e,\n}\n\n/// Executes the verify command.\n///\n/// # Errors\n///\n/// Returns an error if the tool is not found, the WASM file is missing,\n/// or the hash does not match the stored digest.\npub async fn execute(args: \u0026VerifyArgs) -\u003e anyhow::Result\u003c()\u003e {\n    let tool_id: kami_types::ToolId = args\n        .tool_id\n        .parse()\n        .map_err(|e| anyhow::anyhow!(\"invalid tool id: {e}\"))?;\n\n    let repo = shared::open_repository(\u0026args.db)?;\n\n    let tool = repo\n        .find_by_id(\u0026tool_id)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?\n        .ok_or_else(|| anyhow::anyhow!(\"tool '{}' not found\", args.tool_id))?;\n\n    let wasm_path = Path::new(\u0026tool.install_path).join(\u0026tool.manifest.wasm);\n\n    if !wasm_path.exists() {\n        anyhow::bail!(\"WASM file missing: {}\", wasm_path.display());\n    }\n\n    let actual_hash = compute_file_hash(\u0026wasm_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to hash WASM file: {e}\"))?;\n\n    match \u0026tool.manifest.wasm_sha256 {\n        None =\u003e {\n            output::print_warning(\u0026format!(\n                \"{}: no stored hash (installed before integrity support)\",\n                args.tool_id\n            ));\n        }\n        Some(expected) if expected == \u0026actual_hash =\u003e {\n            output::print_success(\u0026format!(\n                \"{}: OK (sha256={})\",\n                args.tool_id,\n                \u0026actual_hash[..16]\n            ));\n        }\n        Some(expected) =\u003e {\n            anyhow::bail!(\n                \"{}: INTEGRITY VIOLATION\\n  expected: {}\\n  actual:   {}\",\n                args.tool_id,\n                expected,\n                actual_hash\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","input.rs"],"content":"//! Input resolution for CLI commands.\n//!\n//! Supports three input sources:\n//! - Inline JSON string via `--input` / `-i`\n//! - JSON file via `--input-file` / `-f`\n//! - Stdin via `--input-file -`\n\nuse std::io::Read;\nuse std::path::Path;\n\n/// Resolves the final JSON input string from CLI arguments.\n///\n/// Priority: `--input-file` takes precedence over `--input`.\n/// If `input_file` is `Some(\"-\")`, reads from stdin.\n/// If `input_file` is `Some(path)`, reads from that file.\n/// Otherwise, returns the `input` string as-is.\npub fn resolve_input(input: \u0026str, input_file: Option\u003c\u0026str\u003e) -\u003e anyhow::Result\u003cString\u003e {\n    match input_file {\n        Some(\"-\") =\u003e read_from_stdin(),\n        Some(path) =\u003e read_from_file(path),\n        None =\u003e Ok(input.to_string()),\n    }\n}\n\n/// Reads JSON content from a file path.\nfn read_from_file(path: \u0026str) -\u003e anyhow::Result\u003cString\u003e {\n    let file_path = Path::new(path);\n    if !file_path.exists() {\n        anyhow::bail!(\"input file not found: {path}\");\n    }\n    let content = std::fs::read_to_string(file_path)\n        .map_err(|e| anyhow::anyhow!(\"failed to read input file: {e}\"))?;\n    let trimmed = content.trim().to_string();\n    validate_json(\u0026trimmed)?;\n    Ok(trimmed)\n}\n\n/// Reads JSON content from stdin.\nfn read_from_stdin() -\u003e anyhow::Result\u003cString\u003e {\n    let mut buffer = String::new();\n    std::io::stdin()\n        .read_to_string(\u0026mut buffer)\n        .map_err(|e| anyhow::anyhow!(\"failed to read stdin: {e}\"))?;\n    let trimmed = buffer.trim().to_string();\n    validate_json(\u0026trimmed)?;\n    Ok(trimmed)\n}\n\n/// Validates that the input is valid JSON.\nfn validate_json(input: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    serde_json::from_str::\u003cserde_json::Value\u003e(input)\n        .map_err(|e| anyhow::anyhow!(\"invalid JSON input: {e}\"))?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resolve_inline_input() {\n        let result = resolve_input(\"{\\\"key\\\":\\\"value\\\"}\", None);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"key\\\":\\\"value\\\"}\");\n    }\n\n    #[test]\n    fn resolve_from_file() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"input.json\");\n        std::fs::write(\u0026file_path, r#\"{\"hello\": \"world\"}\"#).unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), r#\"{\"hello\": \"world\"}\"#);\n    }\n\n    #[test]\n    fn resolve_file_not_found() {\n        let result = resolve_input(\"{}\", Some(\"/nonexistent/file.json\"));\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"not found\"));\n    }\n\n    #[test]\n    fn resolve_invalid_json_in_file() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"bad.json\");\n        std::fs::write(\u0026file_path, \"not valid json\").unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"invalid JSON\"));\n    }\n\n    #[test]\n    fn resolve_file_with_whitespace() {\n        let dir = tempfile::tempdir().unwrap();\n        let file_path = dir.path().join(\"spaced.json\");\n        std::fs::write(\u0026file_path, \"  {\\\"a\\\": 1}  \\n\").unwrap();\n\n        let result = resolve_input(\"{}\", Some(file_path.to_str().unwrap()));\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"a\\\": 1}\");\n    }\n\n    #[test]\n    fn resolve_inline_fallback_when_no_file() {\n        let result = resolve_input(\"{\\\"default\\\":true}\", None);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"{\\\"default\\\":true}\");\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":34,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":18,"coverable":26},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","main.rs"],"content":"//! KAMI CLI - Orchestrateur WASM/MCP.\n\nuse clap::{Parser, Subcommand};\nuse tracing_subscriber::fmt::format::FmtSpan;\n\nmod commands;\nmod input;\nmod output;\npub(crate) mod shared;\n\n/// KAMI - Secure WASM tool orchestrator for AI agents.\n#[derive(Debug, Parser)]\n#[command(name = \"kami\", version, about)]\nstruct Cli {\n    /// Configuration file path.\n    #[arg(short, long, global = true)]\n    config: Option\u003cString\u003e,\n\n    /// Verbosity level (-v, -vv, -vvv).\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    /// Log output format: plain (default) or json (for log aggregation).\n    #[arg(long, global = true, default_value = \"plain\", value_parser = [\"plain\", \"json\"])]\n    log_format: String,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Scaffold a new tool project.\n    Init(commands::init::InitArgs),\n    /// Validate a tool.toml manifest without installing.\n    Validate(commands::validate::ValidateArgs),\n    /// Install a WASM tool into the registry.\n    Install(commands::install::InstallArgs),\n    /// Uninstall a tool from the registry.\n    Uninstall(commands::uninstall::UninstallArgs),\n    /// Update a tool (or all) from their source directories.\n    Update(commands::update::UpdateArgs),\n    /// Pin a tool to a specific version (prevents update).\n    Pin(commands::pin::PinArgs),\n    /// List installed tools.\n    List(commands::list::ListArgs),\n    /// Inspect a tool's manifest.\n    Inspect(commands::inspect::InspectArgs),\n    /// Run a WASM component file directly (dev mode).\n    Run(commands::run::RunArgs),\n    /// Execute a registered tool by ID.\n    Exec(commands::exec::ExecArgs),\n    /// Start MCP server over stdio or HTTP.\n    Serve(commands::serve::ServeArgs),\n    /// Show runtime status and tool registry statistics.\n    Status(commands::status::StatusArgs),\n    /// Verify the integrity of an installed tool's WASM file.\n    Verify(commands::verify::VerifyArgs),\n    /// Developer experience commands (watch, etc.).\n    Dev(commands::dev::DevArgs),\n}\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    // Initialize tracing.\n    let filter = match cli.verbose {\n        0 =\u003e \"info\",\n        1 =\u003e \"debug\",\n        _ =\u003e \"trace\",\n    };\n    match cli.log_format.as_str() {\n        \"json\" =\u003e tracing_subscriber::fmt()\n            .with_env_filter(filter)\n            .json()\n            .with_target(true)\n            .with_span_events(FmtSpan::CLOSE)\n            .init(),\n        _ =\u003e tracing_subscriber::fmt().with_env_filter(filter).init(),\n    };\n\n    tracing::debug!(\"KAMI starting with config: {:?}\", cli.config);\n\n    match \u0026cli.command {\n        Commands::Init(args) =\u003e commands::init::execute(args),\n        Commands::Validate(args) =\u003e commands::validate::execute(args),\n        Commands::Install(args) =\u003e commands::install::execute(args).await,\n        Commands::Uninstall(args) =\u003e commands::uninstall::execute(args).await,\n        Commands::Update(args) =\u003e commands::update::execute(args).await,\n        Commands::Pin(args) =\u003e commands::pin::execute(args).await,\n        Commands::List(args) =\u003e commands::list::execute(args).await,\n        Commands::Inspect(args) =\u003e commands::inspect::execute(args).await,\n        Commands::Run(args) =\u003e commands::run::execute(args).await,\n        Commands::Exec(args) =\u003e commands::exec::execute(args).await,\n        Commands::Serve(args) =\u003e commands::serve::execute(args).await,\n        Commands::Status(args) =\u003e commands::status::execute(args).await,\n        Commands::Verify(args) =\u003e commands::verify::execute(args).await,\n        Commands::Dev(args) =\u003e commands::dev::execute(args).await,\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","output.rs"],"content":"//! Output formatting for CLI responses.\n\n/// Prints a success message.\npub fn print_success(message: \u0026str) {\n    println!(\"[OK] {message}\");\n}\n\n/// Prints a warning message.\npub fn print_warning(message: \u0026str) {\n    println!(\"[WARN] {message}\");\n}\n\n/// Prints an error message.\npub fn print_error(message: \u0026str) {\n    eprintln!(\"[ERROR] {message}\");\n}\n\n/// Prints an informational message.\npub fn print_info(message: \u0026str) {\n    println!(\"[INFO] {message}\");\n}\n\n/// Default database path for the tool registry.\npub fn default_db_path() -\u003e String {\n    let home = std::env::var(\"KAMI_DATA_DIR\").unwrap_or_else(|_| \".kami\".to_string());\n    format!(\"{home}/registry.db\")\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":5,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":11},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-cli","src","shared.rs"],"content":"//! Shared helpers used across CLI commands.\n//!\n//! Centralises the repetitive pattern of opening the SQLite registry\n//! and creating a `KamiRuntime`, ensuring consistent defaults everywhere.\n\nuse std::sync::Arc;\n\nuse kami_registry::ToolRepository;\nuse kami_runtime::{KamiRuntime, RuntimeConfig};\nuse kami_store_sqlite::SqliteToolRepository;\n\nuse crate::output;\n\n/// Opens the SQLite tool registry.\n///\n/// Uses `$KAMI_DATA_DIR/registry.db` or `.kami/registry.db` by default.\n///\n/// # Errors\n///\n/// Returns an error if the database file cannot be created or opened.\npub fn open_repository(db: \u0026Option\u003cString\u003e) -\u003e anyhow::Result\u003cArc\u003cdyn ToolRepository\u003e\u003e {\n    let path = db.clone().unwrap_or_else(output::default_db_path);\n    if let Some(parent) = std::path::Path::new(\u0026path).parent() {\n        std::fs::create_dir_all(parent)?;\n    }\n    let repo =\n        SqliteToolRepository::open(\u0026path).map_err(|e| anyhow::anyhow!(\"registry error: {e}\"))?;\n    Ok(Arc::new(repo))\n}\n\n/// Creates a `KamiRuntime` with the given concurrency and cache settings.\n///\n/// # Errors\n///\n/// Returns an error if the runtime cannot be initialised.\npub fn create_runtime(\n    repo: Arc\u003cdyn ToolRepository\u003e,\n    concurrency: usize,\n    cache_size: usize,\n) -\u003e anyhow::Result\u003cKamiRuntime\u003e {\n    let config = RuntimeConfig {\n        cache_size,\n        max_concurrent: concurrency,\n        epoch_interruption: true,\n    };\n    KamiRuntime::new(config, repo).map_err(|e| anyhow::anyhow!(\"runtime init error: {e}\"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn open_repository_in_memory_equivalent() {\n        // We test via SqliteToolRepository directly; shared helper tested\n        // indirectly through CLI command integration.\n        let repo = SqliteToolRepository::open_in_memory();\n        assert!(repo.is_ok());\n    }\n\n    #[test]\n    fn create_runtime_with_defaults() {\n        let repo = Arc::new(SqliteToolRepository::open_in_memory().expect(\"open\"));\n        let runtime = create_runtime(repo, 4, 32);\n        assert!(runtime.is_ok());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":2,"coverable":9},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","lib.rs"],"content":"//! # kami-config\n//!\n//! Configuration management for KAMI.\n//! Supports layered config: defaults -\u003e file -\u003e env vars.\n\npub mod loader;\npub mod manifest_loader;\npub mod schema;\n\npub use loader::{load_config, ConfigError};\npub use manifest_loader::{parse_tool_manifest, parse_tool_manifest_file, ManifestError};\npub use schema::KamiConfig;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","loader.rs"],"content":"//! Configuration loader (file + env + CLI merge).\n\nuse figment::providers::{Env, Format, Serialized, Toml};\nuse figment::Figment;\nuse thiserror::Error;\n\nuse crate::schema::KamiConfig;\n\n/// Errors from configuration loading.\n#[derive(Debug, Error)]\npub enum ConfigError {\n    /// Failed to load or merge configuration.\n    #[error(\"configuration error: {0}\")]\n    Load(String),\n}\n\n/// Loads configuration by merging layers:\n/// 1. Default values\n/// 2. Config file (if exists)\n/// 3. Environment variables (KAMI_ prefix)\npub fn load_config(config_path: Option\u003c\u0026str\u003e) -\u003e Result\u003cKamiConfig, ConfigError\u003e {\n    let mut figment = Figment::from(Serialized::defaults(KamiConfig::default()));\n\n    if let Some(path) = config_path {\n        figment = figment.merge(Toml::file(path));\n    }\n\n    figment = figment.merge(Env::prefixed(\"KAMI_\").split(\"_\"));\n\n    figment\n        .extract()\n        .map_err(|e| ConfigError::Load(e.to_string()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn load_config_no_path_succeeds() {\n        let config = load_config(None);\n        assert!(config.is_ok(), \"default config should load without error\");\n    }\n\n    #[test]\n    fn load_config_default_values() {\n        let config = load_config(None).expect(\"should load\");\n        assert_eq!(config.runtime.max_concurrent, 10);\n        assert_eq!(config.runtime.pool_size, 5);\n        assert_eq!(config.runtime.default_timeout_secs, 30);\n        assert_eq!(config.sandbox.default_max_memory_mb, 64);\n        assert_eq!(config.sandbox.default_max_fuel, 1_000_000);\n        assert_eq!(config.registry.database_path, \"kami.db\");\n        assert_eq!(config.logging.level, \"info\");\n    }\n\n    #[test]\n    fn load_config_nonexistent_file_falls_back_to_defaults() {\n        // figment::Toml::file ignores missing files (optional by default)\n        let config = load_config(Some(\"/nonexistent/path/kami.toml\"));\n        assert!(\n            config.is_ok(),\n            \"missing config file should fall back to defaults\"\n        );\n    }\n\n    #[test]\n    fn runtime_timeout_returns_duration() {\n        let config = load_config(None).expect(\"should load\");\n        assert_eq!(config.runtime.timeout().as_secs(), 30);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":24,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":7,"coverable":7},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","manifest_loader.rs"],"content":"//! Tool manifest loader — reads and parses `tool.toml` files.\n//!\n//! Lives in `kami-config` (Adapter layer) because it performs filesystem I/O.\n//! Pure string-to-manifest conversion is also here to keep `toml` out of the\n//! domain layer (`kami-types`).\n\nuse std::path::Path;\n\nuse kami_types::{SecurityConfig, ToolArgument, ToolId, ToolManifest, ToolVersion};\n\n/// Error type for manifest parsing failures.\n#[derive(Debug, thiserror::Error)]\npub enum ManifestError {\n    /// The file could not be read.\n    #[error(\"cannot read manifest at '{path}': {source}\")]\n    Io {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n    /// The TOML content is invalid or missing required fields.\n    #[error(\"invalid tool.toml: {0}\")]\n    Parse(String),\n}\n\n/// Parses a `tool.toml` string into a `ToolManifest`.\n///\n/// This is a pure transformation — no filesystem access.\n///\n/// # Errors\n///\n/// Returns `ManifestError::Parse` if the TOML is malformed or missing\n/// required sections.\npub fn parse_tool_manifest(content: \u0026str) -\u003e Result\u003cToolManifest, ManifestError\u003e {\n    let raw: RawToolToml =\n        toml::from_str(content).map_err(|e| ManifestError::Parse(e.to_string()))?;\n\n    let id = ToolId::new(\u0026raw.tool.id).map_err(|e| ManifestError::Parse(e.to_string()))?;\n\n    let version: ToolVersion = raw\n        .tool\n        .version\n        .parse()\n        .map_err(|e: kami_types::KamiError| ManifestError::Parse(e.to_string()))?;\n\n    Ok(ToolManifest {\n        id,\n        name: raw.tool.name,\n        version,\n        wasm: raw.tool.wasm,\n        description: raw.mcp.description,\n        arguments: raw.mcp.arguments,\n        security: raw.security,\n        // Populated at install time by hashing the WASM file on disk;\n        // not present in the tool.toml source file itself.\n        wasm_sha256: None,\n    })\n}\n\n/// Reads a `tool.toml` file from disk and parses it into a `ToolManifest`.\n///\n/// # Errors\n///\n/// Returns `ManifestError::Io` if the file cannot be read.\n/// Returns `ManifestError::Parse` if the content is invalid.\npub fn parse_tool_manifest_file(path: \u0026Path) -\u003e Result\u003cToolManifest, ManifestError\u003e {\n    let content = std::fs::read_to_string(path).map_err(|e| ManifestError::Io {\n        path: path.display().to_string(),\n        source: e,\n    })?;\n    parse_tool_manifest(\u0026content)\n}\n\n// ---------------------------------------------------------------------------\n// Private TOML deserialization types\n// ---------------------------------------------------------------------------\n\n/// Raw TOML structure mirroring the `tool.toml` file format.\n///\n/// `SecurityConfig` already derives `Deserialize` with `#[serde(flatten)]`\n/// on `ResourceLimits`, so it maps directly to the `[security]` section.\n#[derive(Debug, serde::Deserialize)]\nstruct RawToolToml {\n    tool: RawToolSection,\n    mcp: RawMcpSection,\n    #[serde(default)]\n    security: SecurityConfig,\n}\n\n/// `[tool]` section of tool.toml.\n#[derive(Debug, serde::Deserialize)]\nstruct RawToolSection {\n    id: String,\n    name: String,\n    version: String,\n    wasm: String,\n}\n\n/// `[mcp]` section of tool.toml.\n#[derive(Debug, serde::Deserialize)]\nstruct RawMcpSection {\n    description: String,\n    #[serde(default)]\n    arguments: Vec\u003cToolArgument\u003e,\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567608}},{"line":36,"address":[],"length":0,"stats":{"Line":1080863910568919044}},{"line":38,"address":[],"length":0,"stats":{"Line":1008806316530991088}},{"line":40,"address":[],"length":0,"stats":{"Line":432345564227567595}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":52,"address":[],"length":0,"stats":{"Line":288230376151711730}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":22},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-config","src","schema.rs"],"content":"//! Configuration schema types.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Top-level KAMI configuration.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\npub struct KamiConfig {\n    /// Runtime settings.\n    #[serde(default)]\n    pub runtime: RuntimeConfig,\n    /// Sandbox settings.\n    #[serde(default)]\n    pub sandbox: SandboxConfig,\n    /// Registry settings.\n    #[serde(default)]\n    pub registry: RegistryConfig,\n    /// Logging settings.\n    #[serde(default)]\n    pub logging: LoggingConfig,\n}\n\n/// Runtime configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RuntimeConfig {\n    /// Maximum concurrent tool executions.\n    #[serde(default = \"default_max_concurrent\")]\n    pub max_concurrent: usize,\n    /// Instance pool size.\n    #[serde(default = \"default_pool_size\")]\n    pub pool_size: usize,\n    /// Default execution timeout in seconds.\n    #[serde(default = \"default_timeout_secs\")]\n    pub default_timeout_secs: u64,\n}\n\nimpl RuntimeConfig {\n    /// Returns the timeout as a `Duration`.\n    pub fn timeout(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.default_timeout_secs)\n    }\n}\n\nimpl Default for RuntimeConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_concurrent: default_max_concurrent(),\n            pool_size: default_pool_size(),\n            default_timeout_secs: default_timeout_secs(),\n        }\n    }\n}\n\nfn default_max_concurrent() -\u003e usize {\n    10\n}\nfn default_pool_size() -\u003e usize {\n    5\n}\nfn default_timeout_secs() -\u003e u64 {\n    30\n}\n\n/// Sandbox default settings.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SandboxConfig {\n    /// Default maximum memory per tool (MB).\n    #[serde(default = \"default_max_memory\")]\n    pub default_max_memory_mb: u32,\n    /// Default maximum fuel per tool.\n    #[serde(default = \"default_max_fuel\")]\n    pub default_max_fuel: u64,\n}\n\nimpl Default for SandboxConfig {\n    fn default() -\u003e Self {\n        Self {\n            default_max_memory_mb: default_max_memory(),\n            default_max_fuel: default_max_fuel(),\n        }\n    }\n}\n\nfn default_max_memory() -\u003e u32 {\n    64\n}\nfn default_max_fuel() -\u003e u64 {\n    1_000_000\n}\n\n/// Registry storage settings.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RegistryConfig {\n    /// Path to the SQLite database.\n    #[serde(default = \"default_db_path\")]\n    pub database_path: String,\n}\n\nimpl Default for RegistryConfig {\n    fn default() -\u003e Self {\n        Self {\n            database_path: default_db_path(),\n        }\n    }\n}\n\nfn default_db_path() -\u003e String {\n    \"kami.db\".to_string()\n}\n\n/// Logging configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    /// Log level filter (e.g. \"info\", \"debug\", \"kami=trace\").\n    #[serde(default = \"default_log_level\")]\n    pub level: String,\n}\n\nimpl Default for LoggingConfig {\n    fn default() -\u003e Self {\n        Self {\n            level: default_log_level(),\n        }\n    }\n}\n\nfn default_log_level() -\u003e String {\n    \"info\".to_string()\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":48,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":55,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":89,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":123,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":128,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":129,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":27,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","component.rs"],"content":"//! WebAssembly Component Model loading, linking, and execution.\n\nuse std::path::Path;\n\nuse wasmtime::component::{Component, ComponentNamedList, Instance, Lift, Linker, Lower};\nuse wasmtime::{Engine, Store};\n\nuse crate::error::EngineError;\nuse crate::state::HostState;\n\n/// Loads a WASM component from raw bytes.\npub fn load_component(engine: \u0026Engine, bytes: \u0026[u8]) -\u003e Result\u003cComponent, EngineError\u003e {\n    Component::new(engine, bytes).map_err(|e| EngineError::Compilation {\n        reason: \"failed to load component from bytes\".to_string(),\n        source: e,\n    })\n}\n\n/// Loads a WASM component from a file path.\npub fn load_component_from_file(engine: \u0026Engine, path: \u0026Path) -\u003e Result\u003cComponent, EngineError\u003e {\n    Component::from_file(engine, path).map_err(|e| EngineError::Compilation {\n        reason: format!(\"failed to load component from {}\", path.display()),\n        source: e,\n    })\n}\n\n/// Creates a `Linker\u003cHostState\u003e` with WASI async bindings registered.\n///\n/// This linker is reusable across multiple instantiations.\npub fn create_linker(engine: \u0026Engine) -\u003e Result\u003cLinker\u003cHostState\u003e, EngineError\u003e {\n    let mut linker = Linker::new(engine);\n    wasmtime_wasi::add_to_linker_async(\u0026mut linker)\n        .map_err(|e| EngineError::Config(format!(\"failed to add WASI to linker: {e}\")))?;\n    Ok(linker)\n}\n\n/// Instantiates a component asynchronously.\npub async fn instantiate_component(\n    linker: \u0026Linker\u003cHostState\u003e,\n    store: \u0026mut Store\u003cHostState\u003e,\n    component: \u0026Component,\n) -\u003e Result\u003cInstance, EngineError\u003e {\n    linker\n        .instantiate_async(store, component)\n        .await\n        .map_err(|e| EngineError::Instantiation {\n            reason: \"failed to instantiate component\".to_string(),\n            source: e,\n        })\n}\n\n/// Calls an exported `run(input: string) -\u003e result\u003cstring, string\u003e` function.\n///\n/// This is the standard KAMI tool interface: takes JSON input, returns JSON output.\npub async fn call_tool_run(\n    store: \u0026mut Store\u003cHostState\u003e,\n    instance: \u0026Instance,\n    input: \u0026str,\n) -\u003e Result\u003cResult\u003cString, String\u003e, EngineError\u003e {\n    let run_func =\n        find_typed_func::\u003c(String,), (Result\u003cString, String\u003e,)\u003e(\u0026mut *store, instance, \"run\")?;\n\n    let (result,) = run_func\n        .call_async(\u0026mut *store, (input.to_string(),))\n        .await\n        .map_err(|e| EngineError::Trap {\n            message: e.to_string(),\n        })?;\n\n    run_func\n        .post_return_async(\u0026mut *store)\n        .await\n        .map_err(|e| EngineError::Trap {\n            message: format!(\"post_return failed: {e}\"),\n        })?;\n\n    Ok(result)\n}\n\n/// Looks up a typed export function by name.\nfn find_typed_func\u003cParams, Results\u003e(\n    store: \u0026mut Store\u003cHostState\u003e,\n    instance: \u0026Instance,\n    name: \u0026str,\n) -\u003e Result\u003cwasmtime::component::TypedFunc\u003cParams, Results\u003e, EngineError\u003e\nwhere\n    Params: ComponentNamedList + Lower + Send + Sync,\n    Results: ComponentNamedList + Lift + Send + Sync,\n{\n    instance\n        .get_typed_func::\u003cParams, Results\u003e(store, name)\n        .map_err(|_| EngineError::ExportNotFound {\n            name: name.to_string(),\n        })\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":13,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":31,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":32,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":33,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":34,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":38,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":43,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":60,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":63,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":64,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":65,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":66,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":71,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":73,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":81,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":90,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":92,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":28,"coverable":39},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","error.rs"],"content":"//! Engine-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the WASM engine.\n#[derive(Debug, Error)]\npub enum EngineError {\n    /// Failed to compile a WASM component.\n    #[error(\"failed to compile WASM component: {reason}\")]\n    Compilation {\n        reason: String,\n        #[source]\n        source: wasmtime::Error,\n    },\n    /// Failed to instantiate a component.\n    #[error(\"failed to instantiate component: {reason}\")]\n    Instantiation {\n        reason: String,\n        #[source]\n        source: wasmtime::Error,\n    },\n    /// WASM instance trapped during execution.\n    #[error(\"instance trapped: {message}\")]\n    Trap { message: String },\n    /// Exported function not found.\n    #[error(\"export not found: {name}\")]\n    ExportNotFound { name: String },\n    /// Resource limit exceeded.\n    #[error(\"resource limit exceeded: {limit}\")]\n    ResourceExceeded { limit: String },\n    /// Configuration error.\n    #[error(\"engine configuration error: {0}\")]\n    Config(String),\n}\n\nimpl From\u003cEngineError\u003e for KamiError {\n    fn from(e: EngineError) -\u003e Self {\n        let kind = match \u0026e {\n            EngineError::ResourceExceeded { .. } =\u003e ErrorKind::ResourceExhausted,\n            EngineError::ExportNotFound { .. } =\u003e ErrorKind::NotFound,\n            _ =\u003e ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for EngineError {\n    fn hint(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::Compilation { reason, .. } =\u003e {\n                if reason.contains(\"unknown import\") {\n                    Some(\n                        \"The WASM component imports an interface that KAMI does not provide.\"\n                            .into(),\n                    )\n                } else {\n                    Some(\"The WASM binary could not be compiled by the engine.\".into())\n                }\n            }\n            Self::ExportNotFound { name } =\u003e Some(format!(\n                \"The component does not export '{name}'. It must export 'run' and 'describe'.\"\n            )),\n            Self::ResourceExceeded { .. } =\u003e {\n                Some(\"The component exceeded its allocated resource budget.\".into())\n            }\n            Self::Trap { .. } =\u003e Some(\"The WASM instance trapped during execution.\".into()),\n            _ =\u003e None,\n        }\n    }\n\n    fn fix(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::Compilation { reason, .. } if reason.contains(\"unknown import\") =\u003e Some(\n                \"Check that your tool.toml [security] section grants the required capabilities.\\n\\\n                 Example: net_allow_list = [\\\"api.example.com\\\"]\"\n                    .into(),\n            ),\n            Self::ExportNotFound { .. } =\u003e Some(\n                \"Use the kami_tool! macro from kami-guest to generate the required exports.\".into(),\n            ),\n            Self::ResourceExceeded { limit } =\u003e Some(format!(\n                \"Increase the limit in tool.toml:\\n  [security]\\n  {limit}\"\n            )),\n            _ =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resource_exceeded_maps_to_exhausted() {\n        let err: KamiError =\n            EngineError::ResourceExceeded { limit: \"memory\".into() }.into();\n        assert_eq!(err.kind, ErrorKind::ResourceExhausted);\n    }\n\n    #[test]\n    fn export_not_found_maps_to_not_found() {\n        let err: KamiError =\n            EngineError::ExportNotFound { name: \"run\".into() }.into();\n        assert_eq!(err.kind, ErrorKind::NotFound);\n    }\n\n    #[test]\n    fn compilation_hint_mentions_unknown_import() {\n        let e = EngineError::Compilation {\n            reason: \"unknown import: wasi:http\".into(),\n            source: wasmtime::Error::msg(\"test\"),\n        };\n        let hint = e.hint().expect(\"should have hint\");\n        assert!(hint.contains(\"does not provide\"));\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":49,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":27},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","instance.rs"],"content":"//! WASM Component instance lifecycle management.\n\nuse wasmtime::{Config, Engine, Store};\n\nuse crate::error::EngineError;\nuse crate::state::HostState;\n\n/// Configuration for creating WASM instances.\n#[derive(Debug, Clone)]\npub struct InstanceConfig {\n    /// Maximum memory in bytes per linear memory.\n    pub max_memory_bytes: u64,\n    /// Fuel limit for execution.\n    pub max_fuel: u64,\n    /// Enable async support (required for tokio).\n    pub async_support: bool,\n    /// Enable epoch-based interruption for timeout enforcement.\n    pub epoch_interruption: bool,\n}\n\nimpl Default for InstanceConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_memory_bytes: 64 * 1024 * 1024, // 64 MB\n            max_fuel: 1_000_000,\n            async_support: true,\n            epoch_interruption: false,\n        }\n    }\n}\n\n/// Creates a Wasmtime `Engine` configured for KAMI.\n///\n/// The engine is reusable across all component compilations and\n/// should be created once at startup. Enables fuel metering,\n/// Component Model, and epoch interruption.\npub fn create_engine(config: \u0026InstanceConfig) -\u003e Result\u003cEngine, EngineError\u003e {\n    let mut wasm_config = Config::new();\n    wasm_config.async_support(config.async_support);\n    wasm_config.consume_fuel(true);\n    wasm_config.wasm_component_model(true);\n    if config.epoch_interruption {\n        wasm_config.epoch_interruption(true);\n    }\n\n    Engine::new(\u0026wasm_config).map_err(|e| EngineError::Config(e.to_string()))\n}\n\n/// Creates a new `Store\u003cHostState\u003e` with fuel metering and resource limits.\n///\n/// Connects `StoreLimits` from `HostState` via `store.limiter()` and sets\n/// the fuel budget for instruction-level metering.\npub fn create_store(\n    engine: \u0026Engine,\n    host_state: HostState,\n    fuel: u64,\n) -\u003e Result\u003cStore\u003cHostState\u003e, EngineError\u003e {\n    let mut store = Store::new(engine, host_state);\n\n    // Connect resource limiter (memory, tables)\n    store.limiter(|state| \u0026mut state.store_limits);\n\n    // Set fuel budget\n    store\n        .set_fuel(fuel)\n        .map_err(|e| EngineError::Config(e.to_string()))?;\n\n    Ok(store)\n}\n\n/// Sets an epoch deadline on a store for timeout enforcement.\n///\n/// The store will trap when the engine's epoch counter exceeds\n/// `ticks_beyond_current`. Use `Engine::increment_epoch()` from\n/// a separate tokio task to trigger the deadline after a timeout.\npub fn set_epoch_deadline(store: \u0026mut Store\u003cHostState\u003e, ticks: u64) {\n    store.epoch_deadline_trap();\n    store.set_epoch_deadline(ticks);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wasmtime_wasi::WasiCtxBuilder;\n\n    #[test]\n    fn create_engine_with_defaults() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(\u0026config);\n        assert!(engine.is_ok());\n    }\n\n    #[test]\n    fn create_store_with_fuel() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(\u0026config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        let store = create_store(\u0026engine, state, 500_000);\n        assert!(store.is_ok());\n    }\n\n    #[test]\n    fn store_with_memory_limits() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(\u0026config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::with_limits(ctx, 16 * 1024 * 1024);\n        let store = create_store(\u0026engine, state, 500_000);\n        assert!(store.is_ok());\n    }\n\n    #[test]\n    fn epoch_deadline_can_be_set() {\n        let config = InstanceConfig::default();\n        let engine = create_engine(\u0026config).expect(\"engine creation\");\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        let mut store = create_store(\u0026engine, state, 500_000).expect(\"store creation\");\n        set_epoch_deadline(\u0026mut store, 1);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":24,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":37,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":38,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":39,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":40,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":41,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":42,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":43,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":46,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":53,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":58,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":61,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":64,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":65,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":66,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":68,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":78,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":20,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","lib.rs"],"content":"//! # kami-engine\n//!\n//! WASM engine powered by Wasmtime with Component Model support.\n//! Handles component compilation, instance creation, WASI linking,\n//! and async execution.\n\npub mod component;\npub mod error;\npub mod instance;\npub mod linker;\npub mod memory;\npub mod state;\n\npub use component::{\n    call_tool_run, create_linker, instantiate_component, load_component, load_component_from_file,\n};\npub use error::EngineError;\npub use instance::{create_engine, create_store, set_epoch_deadline, InstanceConfig};\npub use memory::MemoryStats;\npub use state::HostState;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","linker.rs"],"content":"//! Host function linking for WASM Component instances.\n//!\n//! Custom host functions beyond WASI will be registered here\n//! in future phases (logging, capability checks, metrics, etc.).\n\npub use crate::component::create_linker;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","memory.rs"],"content":"//! Memory management and limits for WASM instances.\n\n/// Memory usage statistics for a WASM instance.\n#[derive(Debug, Clone, Default)]\npub struct MemoryStats {\n    /// Current memory usage in bytes.\n    pub current_bytes: u64,\n    /// Peak memory usage in bytes.\n    pub peak_bytes: u64,\n    /// Memory limit in bytes.\n    pub limit_bytes: u64,\n}\n\nimpl MemoryStats {\n    /// Returns the usage as a percentage of the limit.\n    pub fn usage_percent(\u0026self) -\u003e f64 {\n        if self.limit_bytes == 0 {\n            return 0.0;\n        }\n        (self.current_bytes as f64 / self.limit_bytes as f64) * 100.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn usage_percent_zero_limit_returns_zero() {\n        let stats = MemoryStats {\n            current_bytes: 1024,\n            peak_bytes: 2048,\n            limit_bytes: 0,\n        };\n        assert!((stats.usage_percent() - 0.0).abs() \u003c f64::EPSILON);\n    }\n\n    #[test]\n    fn usage_percent_computes_correctly() {\n        let stats = MemoryStats {\n            current_bytes: 50,\n            peak_bytes: 75,\n            limit_bytes: 100,\n        };\n        assert!((stats.usage_percent() - 50.0).abs() \u003c f64::EPSILON);\n    }\n\n    #[test]\n    fn default_stats_are_zeroed() {\n        let stats = MemoryStats::default();\n        assert_eq!(stats.current_bytes, 0);\n        assert_eq!(stats.limit_bytes, 0);\n        assert!((stats.usage_percent() - 0.0).abs() \u003c f64::EPSILON);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":4,"coverable":4},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-engine","src","state.rs"],"content":"//! Host state for WASM component instances.\n//!\n//! `HostState` is the `T` in `Store\u003cT\u003e` and must implement `WasiView`.\n//! It holds the WASI context, resource table, store limits, and\n//! per-instance metadata.\n\nuse wasmtime::component::ResourceTable;\nuse wasmtime::{StoreLimits, StoreLimitsBuilder};\nuse wasmtime_wasi::{WasiCtx, WasiView};\n\n/// Per-instance host state passed to `Store\u003cHostState\u003e`.\n///\n/// Contains the `StoreLimits` so that `Store::limiter()` can reference it.\n/// Extensible: future phases will add fields for capability tracking,\n/// metrics, and host function state.\npub struct HostState {\n    /// WASI context controlling I/O permissions.\n    wasi_ctx: WasiCtx,\n    /// Resource table for Component Model resources.\n    resource_table: ResourceTable,\n    /// Wasmtime resource limiter (memory, tables, instances).\n    pub(crate) store_limits: StoreLimits,\n    /// Fuel consumed so far (for reporting).\n    fuel_consumed: u64,\n}\n\nimpl HostState {\n    /// Creates a new host state from a pre-built `WasiCtx` with default\n    /// resource limits (no memory cap).\n    pub fn new(wasi_ctx: WasiCtx) -\u003e Self {\n        Self {\n            wasi_ctx,\n            resource_table: ResourceTable::new(),\n            store_limits: StoreLimitsBuilder::new().build(),\n            fuel_consumed: 0,\n        }\n    }\n\n    /// Creates a new host state with explicit memory limits.\n    ///\n    /// `max_memory_bytes` caps each linear memory allocation.\n    pub fn with_limits(wasi_ctx: WasiCtx, max_memory_bytes: usize) -\u003e Self {\n        let store_limits = StoreLimitsBuilder::new()\n            .memory_size(max_memory_bytes)\n            .trap_on_grow_failure(true)\n            .build();\n        Self {\n            wasi_ctx,\n            resource_table: ResourceTable::new(),\n            store_limits,\n            fuel_consumed: 0,\n        }\n    }\n\n    /// Returns fuel consumed so far.\n    pub fn fuel_consumed(\u0026self) -\u003e u64 {\n        self.fuel_consumed\n    }\n\n    /// Records fuel consumption.\n    pub fn record_fuel(\u0026mut self, consumed: u64) {\n        self.fuel_consumed = consumed;\n    }\n}\n\nimpl WasiView for HostState {\n    fn ctx(\u0026mut self) -\u003e \u0026mut WasiCtx {\n        \u0026mut self.wasi_ctx\n    }\n\n    fn table(\u0026mut self) -\u003e \u0026mut ResourceTable {\n        \u0026mut self.resource_table\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wasmtime_wasi::WasiCtxBuilder;\n\n    #[test]\n    fn host_state_creation() {\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::new(ctx);\n        assert_eq!(state.fuel_consumed(), 0);\n    }\n\n    #[test]\n    fn host_state_with_memory_limits() {\n        let ctx = WasiCtxBuilder::new().build();\n        let state = HostState::with_limits(ctx, 32 * 1024 * 1024);\n        assert_eq!(state.fuel_consumed(), 0);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":33,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":34,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":43,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":49,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","abi.rs"],"content":"//! ABI helpers for guest WASM modules.\n//!\n//! Provides the low-level interface between guest tool code and the\n//! KAMI host. Guest tools use these helpers to parse input, build\n//! results, and interact with host functions.\n\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\n/// Parses JSON input string into a typed struct.\n///\n/// Returns `Err(String)` with a human-readable message on failure.\n///\n/// # Example\n/// ```ignore\n/// #[derive(serde::Deserialize)]\n/// struct MyInput { url: String }\n///\n/// let input: MyInput = kami_guest::abi::parse_input(raw_json)?;\n/// ```\npub fn parse_input\u003cT: DeserializeOwned\u003e(input: \u0026str) -\u003e Result\u003cT, String\u003e {\n    serde_json::from_str(input).map_err(|e| format!(\"invalid input: {e}\"))\n}\n\n/// Serializes a value into a JSON result string.\n///\n/// Returns `Err(String)` if serialization fails.\npub fn to_output\u003cT: Serialize\u003e(value: \u0026T) -\u003e Result\u003cString, String\u003e {\n    serde_json::to_string(value).map_err(|e| format!(\"serialization error: {e}\"))\n}\n\n/// Builds a simple text result.\npub fn text_result(text: \u0026str) -\u003e Result\u003cString, String\u003e {\n    Ok(serde_json::json!({ \"text\": text }).to_string())\n}\n\n/// Builds an error result.\npub fn error_result(message: \u0026str) -\u003e String {\n    serde_json::json!({ \"error\": message }).to_string()\n}\n\n/// Tool metadata for the `describe` export.\n#[derive(Debug, Clone, Serialize)]\npub struct ToolMetadata {\n    /// Tool name.\n    pub name: String,\n    /// Tool description.\n    pub description: String,\n    /// Tool version.\n    pub version: String,\n}\n\nimpl ToolMetadata {\n    /// Serializes metadata to JSON for the `describe` ABI call.\n    pub fn to_json(\u0026self) -\u003e String {\n        serde_json::to_string(self).unwrap_or_else(|_| \"{}\".to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::Deserialize;\n\n    #[derive(Debug, Deserialize, PartialEq)]\n    struct TestInput {\n        url: String,\n        count: u32,\n    }\n\n    #[test]\n    fn parse_valid_input() {\n        let json = r#\"{\"url\":\"https://example.com\",\"count\":5}\"#;\n        let input: TestInput = parse_input(json).expect(\"parse\");\n        assert_eq!(input.url, \"https://example.com\");\n        assert_eq!(input.count, 5);\n    }\n\n    #[test]\n    fn parse_invalid_input_returns_error() {\n        let result = parse_input::\u003cTestInput\u003e(\"not json\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"invalid input\"));\n    }\n\n    #[test]\n    fn to_output_serializes() {\n        let data = serde_json::json!({\"result\": 42});\n        let json = to_output(\u0026data).expect(\"serialize\");\n        assert!(json.contains(\"42\"));\n    }\n\n    #[test]\n    fn text_result_wraps_string() {\n        let result = text_result(\"hello\").expect(\"ok\");\n        let parsed: serde_json::Value = serde_json::from_str(\u0026result).expect(\"parse\");\n        assert_eq!(parsed[\"text\"], \"hello\");\n    }\n\n    #[test]\n    fn error_result_wraps_message() {\n        let result = error_result(\"something failed\");\n        let parsed: serde_json::Value = serde_json::from_str(\u0026result).expect(\"parse\");\n        assert_eq!(parsed[\"error\"], \"something failed\");\n    }\n\n    #[test]\n    fn tool_metadata_to_json() {\n        let meta = ToolMetadata {\n            name: \"test-tool\".to_string(),\n            description: \"A test\".to_string(),\n            version: \"1.0.0\".to_string(),\n        };\n        let json = meta.to_json();\n        assert!(json.contains(\"test-tool\"));\n        assert!(json.contains(\"1.0.0\"));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","bindings.rs"],"content":"//! Auto-generated Component Model bindings from WIT interfaces.\r\n//!\r\n//! Gated behind the `component-model` feature flag. When enabled,\r\n//! `wit-bindgen` generates the `Guest` trait and host import functions\r\n//! from the WIT definitions in `wit/`.\r\n//!\r\n//! # For Tool Authors\r\n//!\r\n//! To build a real WASM component (not just a test binary):\r\n//!\r\n//! ```toml\r\n//! # your-tool/Cargo.toml\r\n//! [dependencies]\r\n//! kami-guest = { path = \"../../crates/kami-guest\", features = [\"component-model\"] }\r\n//! ```\r\n//!\r\n//! ```ignore\r\n//! // your-tool/src/lib.rs\r\n//! use kami_guest::bindings;\r\n//!\r\n//! struct MyTool;\r\n//!\r\n//! impl bindings::Guest for MyTool {\r\n//!     fn run(input: String) -\u003e Result\u003cString, String\u003e {\r\n//!         // your logic\r\n//!         Ok(format!(\"result: {input}\"))\r\n//!     }\r\n//!     fn describe() -\u003e String {\r\n//!         r#\"{\"name\":\"my-tool\",\"version\":\"1.0.0\"}\"#.into()\r\n//!     }\r\n//! }\r\n//!\r\n//! bindings::export!(MyTool with_types_in bindings);\r\n//! ```\r\n//!\r\n//! Build with: `cargo build --target wasm32-wasip2 --release`\r\n//!\r\n//! # Native Testing\r\n//!\r\n//! For native tests (no WASM), use `kami_tool!` macro instead:\r\n//!\r\n//! ```ignore\r\n//! kami_guest::kami_tool! {\r\n//!     name: \"my-tool\",\r\n//!     version: \"1.0.0\",\r\n//!     description: \"My tool\",\r\n//!     handler: my_handler,\r\n//! }\r\n//! ```\r\n\r\n#[cfg(feature = \"component-model\")]\r\nwit_bindgen::generate!({\r\n    world: \"kami-tool\",\r\n    path: \"../../wit\",\r\n});\r\n\r\n#[cfg(feature = \"component-model\")]\r\npub use exports::kami::tool::tool::Guest;\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","lib.rs"],"content":"//! # kami-guest\n//!\n//! SDK for building WASM tools that run inside KAMI.\n//!\n//! This crate provides:\n//! - **ABI helpers**: Parse input, serialize output, build results\n//! - **`kami_tool!` macro**: Generate Component Model exports from a handler function\n//!\n//! # Quick Start\n//!\n//! ```ignore\n//! use kami_guest::kami_tool;\n//!\n//! kami_tool! {\n//!     name: \"dev.example.echo\",\n//!     version: \"1.0.0\",\n//!     description: \"Echoes back the input\",\n//!     handler: handle,\n//! }\n//!\n//! fn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\n//!     Ok(format!(\"echo: {input}\"))\n//! }\n//! ```\n\npub mod abi;\npub mod macros;\n\n#[cfg(feature = \"component-model\")]\npub mod bindings;\n\npub use abi::{error_result, parse_input, text_result, to_output, ToolMetadata};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-guest","src","macros.rs"],"content":"//! Declarative macros for KAMI guest tools.\n//!\n//! Provides `kami_tool!` to generate the handler wiring and metadata\n//! for tools targeting the KAMI runtime.\n//!\n//! Two compilation modes are supported:\n//! - **Native** (default): generates test-friendly `__kami_run` / `__kami_describe`\n//! - **Component Model** (`component-model` feature + wasm32 target):\n//!   additionally generates `impl Guest` + `export!()` from WIT bindings\n\n/// Generates the KAMI tool entry points from a handler function.\n///\n/// This macro creates:\n/// - A `__kami_run` function that delegates to your handler\n/// - A `__kami_describe` function that returns tool metadata JSON\n///\n/// When the `component-model` feature is active and targeting wasm32,\n/// it also generates the Component Model `impl Guest` and `export!` glue\n/// from the WIT interface definitions.\n///\n/// # Usage\n///\n/// ```ignore\n/// use kami_guest::kami_tool;\n///\n/// kami_tool! {\n///     name: \"dev.example.my-tool\",\n///     version: \"1.0.0\",\n///     description: \"Does something useful\",\n///     handler: my_handler,\n/// }\n///\n/// fn my_handler(input: \u0026str) -\u003e Result\u003cString, String\u003e {\n///     let args: serde_json::Value = serde_json::from_str(input)\n///         .map_err(|e| e.to_string())?;\n///     Ok(format!(\"processed: {}\", args))\n/// }\n/// ```\n#[macro_export]\nmacro_rules! kami_tool {\n    (\n        name: $name:expr,\n        version: $version:expr,\n        description: $desc:expr,\n        handler: $handler:ident $(,)?\n    ) =\u003e {\n        /// Entry point: execute the tool with JSON input.\n        pub fn __kami_run(input: \u0026str) -\u003e Result\u003cString, String\u003e {\n            $handler(input)\n        }\n\n        /// Entry point: return tool metadata as JSON.\n        pub fn __kami_describe() -\u003e String {\n            let meta = $crate::abi::ToolMetadata {\n                name: $name.to_string(),\n                description: $desc.to_string(),\n                version: $version.to_string(),\n            };\n            meta.to_json()\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    fn sample_handler(input: \u0026str) -\u003e Result\u003cString, String\u003e {\n        Ok(format!(\"echo: {input}\"))\n    }\n\n    kami_tool! {\n        name: \"dev.test.sample\",\n        version: \"0.1.0\",\n        description: \"Test tool\",\n        handler: sample_handler,\n    }\n\n    #[test]\n    fn macro_generates_run() {\n        let result = __kami_run(\"hello\");\n        assert_eq!(result, Ok(\"echo: hello\".to_string()));\n    }\n\n    #[test]\n    fn macro_generates_describe() {\n        let json = __kami_describe();\n        assert!(json.contains(\"dev.test.sample\"));\n        assert!(json.contains(\"0.1.0\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","jsonrpc.rs"],"content":"//! JSON-RPC 2.0 types for MCP transport.\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// JSON-RPC 2.0 request.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcRequest {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID.\n    pub id: RequestId,\n    /// Method name.\n    pub method: String,\n    /// Optional parameters.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub params: Option\u003cValue\u003e,\n}\n\n/// JSON-RPC 2.0 success response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcResponse {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID (matches the request).\n    pub id: RequestId,\n    /// Result value.\n    pub result: Value,\n}\n\n/// JSON-RPC 2.0 error response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcErrorResponse {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Request ID (matches the request).\n    pub id: RequestId,\n    /// Error details.\n    pub error: JsonRpcError,\n}\n\n/// JSON-RPC 2.0 error object.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcError {\n    /// Error code.\n    pub code: i32,\n    /// Human-readable message.\n    pub message: String,\n    /// Optional structured data.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cValue\u003e,\n}\n\n/// Request ID can be a number or string.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RequestId {\n    /// Numeric ID.\n    Number(i64),\n    /// String ID.\n    String(String),\n}\n\n/// JSON-RPC 2.0 notification (no id).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcNotification {\n    /// Protocol version, always \"2.0\".\n    pub jsonrpc: String,\n    /// Method name.\n    pub method: String,\n    /// Optional parameters.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub params: Option\u003cValue\u003e,\n}\n\n/// Standard JSON-RPC error codes.\npub mod error_codes {\n    /// Invalid JSON was received.\n    pub const PARSE_ERROR: i32 = -32700;\n    /// The JSON sent is not a valid Request object.\n    pub const INVALID_REQUEST: i32 = -32600;\n    /// The method does not exist.\n    pub const METHOD_NOT_FOUND: i32 = -32601;\n    /// Invalid method parameter(s).\n    pub const INVALID_PARAMS: i32 = -32602;\n    /// Internal JSON-RPC error.\n    pub const INTERNAL_ERROR: i32 = -32603;\n}\n\nimpl JsonRpcRequest {\n    /// Creates a new JSON-RPC 2.0 request.\n    pub fn new(id: RequestId, method: impl Into\u003cString\u003e, params: Option\u003cValue\u003e) -\u003e Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            method: method.into(),\n            params,\n        }\n    }\n}\n\nimpl JsonRpcResponse {\n    /// Creates a success response.\n    pub fn success(id: RequestId, result: Value) -\u003e Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            result,\n        }\n    }\n}\n\nimpl JsonRpcErrorResponse {\n    /// Creates an error response.\n    pub fn error(id: RequestId, code: i32, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            error: JsonRpcError {\n                code,\n                message: message.into(),\n                data: None,\n            },\n        }\n    }\n}\n","traces":[{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":117,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","lib.rs"],"content":"//! # kami-protocol\n//!\n//! MCP protocol and JSON-RPC 2.0 type definitions.\n//! This crate defines the wire format for communication between\n//! AI agents and the KAMI orchestrator.\n\npub mod jsonrpc;\npub mod mcp;\npub mod schema;\n\npub use jsonrpc::*;\npub use mcp::methods;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","initialize.rs"],"content":"//! MCP initialize method types.\n//!\n//! The initialize handshake is the first message exchanged between\n//! client and server to negotiate capabilities and protocol version.\n\nuse serde::{Deserialize, Serialize};\n\n/// Client capabilities declared during initialization.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ClientCapabilities {\n    /// Whether the client supports tool execution.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option\u003cToolCapability\u003e,\n}\n\n/// Tool-related capability.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolCapability {}\n\n/// Server capabilities returned during initialization.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ServerCapabilities {\n    /// Tools capability (present if server exposes tools).\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option\u003cToolCapability\u003e,\n}\n\n/// Client info sent during initialization.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClientInfo {\n    /// Client name.\n    pub name: String,\n    /// Client version.\n    pub version: String,\n}\n\n/// Server info returned during initialization.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerInfo {\n    /// Server name.\n    pub name: String,\n    /// Server version.\n    pub version: String,\n}\n\n/// Request params for `initialize`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InitializeParams {\n    /// Protocol version requested by client.\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    /// Client capabilities.\n    pub capabilities: ClientCapabilities,\n    /// Client info.\n    #[serde(rename = \"clientInfo\")]\n    pub client_info: ClientInfo,\n}\n\n/// Response for `initialize`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InitializeResult {\n    /// Protocol version agreed by server.\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    /// Server capabilities.\n    pub capabilities: ServerCapabilities,\n    /// Server info.\n    #[serde(rename = \"serverInfo\")]\n    pub server_info: ServerInfo,\n}\n\n/// MCP protocol version supported by this implementation.\npub const PROTOCOL_VERSION: \u0026str = \"2024-11-05\";\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn initialize_params_roundtrip() {\n        let params = InitializeParams {\n            protocol_version: PROTOCOL_VERSION.to_string(),\n            capabilities: ClientCapabilities {\n                tools: Some(ToolCapability {}),\n            },\n            client_info: ClientInfo {\n                name: \"test-client\".to_string(),\n                version: \"1.0.0\".to_string(),\n            },\n        };\n        let json = serde_json::to_string(\u0026params).expect(\"serialize\");\n        let back: InitializeParams = serde_json::from_str(\u0026json).expect(\"deserialize\");\n        assert_eq!(back.protocol_version, PROTOCOL_VERSION);\n        assert_eq!(back.client_info.name, \"test-client\");\n    }\n\n    #[test]\n    fn initialize_result_roundtrip() {\n        let result = InitializeResult {\n            protocol_version: PROTOCOL_VERSION.to_string(),\n            capabilities: ServerCapabilities {\n                tools: Some(ToolCapability {}),\n            },\n            server_info: ServerInfo {\n                name: \"kami\".to_string(),\n                version: \"0.1.0\".to_string(),\n            },\n        };\n        let json = serde_json::to_string(\u0026result).expect(\"serialize\");\n        let back: InitializeResult = serde_json::from_str(\u0026json).expect(\"deserialize\");\n        assert_eq!(back.server_info.name, \"kami\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","mod.rs"],"content":"//! MCP (Model Context Protocol) type definitions.\n\npub mod initialize;\npub mod prompts;\npub mod resources;\npub mod tools;\n\npub use initialize::*;\npub use prompts::*;\npub use resources::*;\npub use tools::*;\n\n/// MCP protocol method names.\npub mod methods {\n    /// Handshake request.\n    pub const INITIALIZE: \u0026str = \"initialize\";\n    /// Client notification after successful initialization.\n    pub const NOTIFICATIONS_INITIALIZED: \u0026str = \"notifications/initialized\";\n    /// List available tools.\n    pub const TOOLS_LIST: \u0026str = \"tools/list\";\n    /// Execute a tool.\n    pub const TOOLS_CALL: \u0026str = \"tools/call\";\n    /// List available prompts.\n    pub const PROMPTS_LIST: \u0026str = \"prompts/list\";\n    /// List available resources.\n    pub const RESOURCES_LIST: \u0026str = \"resources/list\";\n    /// Read a resource.\n    pub const RESOURCES_READ: \u0026str = \"resources/read\";\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","prompts.rs"],"content":"//! MCP prompts/* method types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Request params for `prompts/list`.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct PromptsListParams {\n    /// Optional cursor for pagination.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub cursor: Option\u003cString\u003e,\n}\n\n/// A prompt definition.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpPromptDefinition {\n    /// Prompt name.\n    pub name: String,\n    /// Prompt description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n}\n\n/// Response for `prompts/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PromptsListResult {\n    /// Available prompts.\n    pub prompts: Vec\u003cMcpPromptDefinition\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","resources.rs"],"content":"//! MCP resources/* method types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Request params for `resources/read`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourcesReadParams {\n    /// URI of the resource to read.\n    pub uri: String,\n}\n\n/// A resource definition.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpResourceDefinition {\n    /// Resource URI.\n    pub uri: String,\n    /// Resource name.\n    pub name: String,\n    /// Resource description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// MIME type.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option\u003cString\u003e,\n}\n\n/// Response for `resources/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourcesListResult {\n    /// Available resources.\n    pub resources: Vec\u003cMcpResourceDefinition\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","mcp","tools.rs"],"content":"//! MCP tools/* method types.\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// Request params for `tools/list`.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolsListParams {\n    /// Optional cursor for pagination.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub cursor: Option\u003cString\u003e,\n}\n\n/// A single tool definition in the MCP response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpToolDefinition {\n    /// Tool name.\n    pub name: String,\n    /// Tool description.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    /// JSON Schema for input parameters.\n    #[serde(rename = \"inputSchema\")]\n    pub input_schema: Value,\n}\n\n/// Response for `tools/list`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsListResult {\n    /// Available tools.\n    pub tools: Vec\u003cMcpToolDefinition\u003e,\n    /// Pagination cursor for next page.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n/// Request params for `tools/call`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsCallParams {\n    /// Name of the tool to invoke.\n    pub name: String,\n    /// Arguments to pass.\n    #[serde(default)]\n    pub arguments: Value,\n}\n\n/// Content item in a tool call response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"lowercase\")]\npub enum ToolContent {\n    /// Text content.\n    Text { text: String },\n    /// Image content (base64).\n    Image { data: String, mime_type: String },\n}\n\n/// Response for `tools/call`.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsCallResult {\n    /// Content items returned by the tool.\n    pub content: Vec\u003cToolContent\u003e,\n    /// Whether the tool call resulted in an error.\n    #[serde(default, rename = \"isError\")]\n    pub is_error: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-protocol","src","schema.rs"],"content":"//! JSON Schema helpers for MCP tool input validation.\n\nuse serde_json::Value;\nuse thiserror::Error;\n\n/// Schema validation errors.\n#[derive(Debug, Error)]\npub enum SchemaError {\n    /// The input does not match the expected schema.\n    #[error(\"schema validation failed: {message}\")]\n    ValidationFailed { message: String },\n    /// The schema itself is malformed.\n    #[error(\"invalid schema: {message}\")]\n    InvalidSchema { message: String },\n}\n\n/// Checks that a JSON value contains required properties from a schema.\n///\n/// This is a minimal validator - checks required fields and basic types.\npub fn validate_required_fields(schema: \u0026Value, input: \u0026Value) -\u003e Result\u003c(), SchemaError\u003e {\n    let required = match schema.get(\"required\") {\n        Some(Value::Array(arr)) =\u003e arr,\n        _ =\u003e return Ok(()),\n    };\n\n    let input_obj = input\n        .as_object()\n        .ok_or_else(|| SchemaError::ValidationFailed {\n            message: \"input must be an object\".to_string(),\n        })?;\n\n    for field in required {\n        let field_name = field.as_str().ok_or_else(|| SchemaError::InvalidSchema {\n            message: \"required field names must be strings\".to_string(),\n        })?;\n        if !input_obj.contains_key(field_name) {\n            return Err(SchemaError::ValidationFailed {\n                message: format!(\"missing required field: {field_name}\"),\n            });\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn validates_required_fields() {\n        let schema = json!({\n            \"required\": [\"url\"],\n            \"properties\": {\n                \"url\": {\"type\": \"string\"}\n            }\n        });\n        let input = json!({\"url\": \"https://example.com\"});\n        assert!(validate_required_fields(\u0026schema, \u0026input).is_ok());\n    }\n\n    #[test]\n    fn rejects_missing_required_field() {\n        let schema = json!({\"required\": [\"url\"]});\n        let input = json!({});\n        assert!(validate_required_fields(\u0026schema, \u0026input).is_err());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":11,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","lib.rs"],"content":"//! # kami-registry\n//!\n//! Port definitions (abstract traits) for the tool registry.\n//! Adapter crates implement these traits.\n\npub mod query;\npub mod repository;\n\npub use query::ToolQuery;\npub use repository::{RepositoryError, ToolRepository};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","query.rs"],"content":"//! Query types for tool repository lookups.\n\nuse serde::{Deserialize, Serialize};\n\n/// Filtering and pagination for tool queries.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolQuery {\n    /// Filter by name (substring match).\n    pub name_filter: Option\u003cString\u003e,\n    /// Filter by keyword.\n    pub keyword: Option\u003cString\u003e,\n    /// Only enabled tools.\n    pub enabled_only: bool,\n    /// Maximum results to return.\n    pub limit: Option\u003cu32\u003e,\n    /// Offset for pagination.\n    pub offset: Option\u003cu32\u003e,\n}\n\nimpl ToolQuery {\n    /// Creates a query that matches all tools.\n    pub fn all() -\u003e Self {\n        Self::default()\n    }\n\n    /// Sets the name filter.\n    pub fn with_name(mut self, name: impl Into\u003cString\u003e) -\u003e Self {\n        self.name_filter = Some(name.into());\n        self\n    }\n\n    /// Sets the limit.\n    pub fn with_limit(mut self, limit: u32) -\u003e Self {\n        self.limit = Some(limit);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_returns_default_query() {\n        let q = ToolQuery::all();\n        assert!(q.name_filter.is_none());\n        assert!(q.keyword.is_none());\n        assert!(!q.enabled_only);\n        assert!(q.limit.is_none());\n        assert!(q.offset.is_none());\n    }\n\n    #[test]\n    fn with_name_sets_filter() {\n        let q = ToolQuery::all().with_name(\"fetch\");\n        assert_eq!(q.name_filter.as_deref(), Some(\"fetch\"));\n    }\n\n    #[test]\n    fn builder_chaining_sets_all_fields() {\n        let q = ToolQuery::all().with_name(\"echo\").with_limit(10);\n        assert_eq!(q.name_filter.as_deref(), Some(\"echo\"));\n        assert_eq!(q.limit, Some(10));\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":23,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":29,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-registry","src","repository.rs"],"content":"//! Abstract repository trait (port) for tool storage.\n\nuse async_trait::async_trait;\nuse thiserror::Error;\n\nuse kami_types::{Tool, ToolId};\n\nuse crate::query::ToolQuery;\n\n/// Errors returned by repository implementations.\n#[derive(Debug, Error)]\n#[non_exhaustive]\npub enum RepositoryError {\n    /// The requested tool was not found.\n    #[error(\"tool not found: {id}\")]\n    NotFound { id: String },\n    /// A database or I/O error occurred.\n    #[error(\"storage error: {message}\")]\n    Storage { message: String },\n    /// A conflict (duplicate id, etc.).\n    #[error(\"conflict: {message}\")]\n    Conflict { message: String },\n    /// Stored data is corrupt or cannot be deserialized.\n    #[error(\"data corruption for tool '{tool_id}': {message}\")]\n    DataCorruption { tool_id: String, message: String },\n}\n\n/// Abstract trait for tool persistence.\n///\n/// Implementations live in adapter crates (e.g., `kami-store-sqlite`).\n#[async_trait]\npub trait ToolRepository: Send + Sync {\n    /// Finds a tool by its unique ID.\n    async fn find_by_id(\u0026self, id: \u0026ToolId) -\u003e Result\u003cOption\u003cTool\u003e, RepositoryError\u003e;\n\n    /// Finds tools matching a query.\n    async fn find_all(\u0026self, query: ToolQuery) -\u003e Result\u003cVec\u003cTool\u003e, RepositoryError\u003e;\n\n    /// Inserts a new tool.\n    async fn insert(\u0026self, tool: \u0026Tool) -\u003e Result\u003c(), RepositoryError\u003e;\n\n    /// Updates an existing tool. Returns `NotFound` if absent.\n    async fn update(\u0026self, tool: \u0026Tool) -\u003e Result\u003c(), RepositoryError\u003e;\n\n    /// Deletes a tool by ID. Returns true if it existed.\n    async fn delete(\u0026self, id: \u0026ToolId) -\u003e Result\u003cbool, RepositoryError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","benches","cache_bench.rs"],"content":"//! Benchmark for `ComponentCache` LRU operations.\n//!\n//! Measures insert, get (hit/miss), and eviction under load using a real\n//! (minimal) WASM component for realistic cache entry sizes.\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse kami_runtime::cache::{CachedComponent, ComponentCache};\nuse kami_types::{SecurityConfig, ToolId};\nuse wasmtime::{component::Component, Config, Engine};\n\n/// Minimal valid WASM component (empty component, ~8 bytes).\nconst MINIMAL_WAT: \u0026str = \"(component)\";\n\n/// Creates a `CachedComponent` wrapping a real compiled component.\nfn make_entry(engine: \u0026Engine, path: \u0026str) -\u003e CachedComponent {\n    let component = Component::new(engine, MINIMAL_WAT).expect(\"bench: compile minimal\");\n    CachedComponent {\n        component,\n        security: SecurityConfig::default(),\n        wasm_path: path.to_string(),\n    }\n}\n\n/// Shared engine (component model enabled).\nfn bench_engine() -\u003e Engine {\n    let mut config = Config::new();\n    config.wasm_component_model(true);\n    Engine::new(\u0026config).expect(\"bench: engine\")\n}\n\nfn bench_cache_insert(c: \u0026mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n\n    c.bench_function(\"cache_insert_100\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let cache = ComponentCache::new(100);\n                for i in 0..100u32 {\n                    let id_str = format!(\"dev.test.tool-{i}\");\n                    let id = ToolId::new(\u0026id_str).expect(\"bench: id\");\n                    cache\n                        .insert(\u0026id, make_entry(\u0026engine, \u0026format!(\"t{i}.wasm\")))\n                        .await;\n                }\n                black_box(cache.len().await);\n            });\n        });\n    });\n}\n\nfn bench_cache_get_hit(c: \u0026mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n    let cache = rt.block_on(async {\n        let c = ComponentCache::new(100);\n        for i in 0..100u32 {\n            let id_str = format!(\"dev.test.tool-{i}\");\n            let id = ToolId::new(\u0026id_str).expect(\"bench: id\");\n            c.insert(\u0026id, make_entry(\u0026engine, \u0026format!(\"t{i}.wasm\")))\n                .await;\n        }\n        c\n    });\n\n    c.bench_function(\"cache_get_hit\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let id = ToolId::new(\"dev.test.tool-50\").expect(\"bench: id\");\n                black_box(cache.get(\u0026id).await);\n            });\n        });\n    });\n}\n\nfn bench_cache_get_miss(c: \u0026mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let cache = ComponentCache::new(100);\n\n    c.bench_function(\"cache_get_miss\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let id = ToolId::new(\"dev.test.none\").expect(\"bench: id\");\n                black_box(cache.get(\u0026id).await);\n            });\n        });\n    });\n}\n\nfn bench_cache_eviction(c: \u0026mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().expect(\"bench: tokio\");\n    let engine = bench_engine();\n\n    c.bench_function(\"cache_evict_lru_10\", |b| {\n        b.iter(|| {\n            rt.block_on(async {\n                let cache = ComponentCache::new(10);\n                for i in 0..20u32 {\n                    let id_str = format!(\"dev.test.tool-{i}\");\n                    let id = ToolId::new(\u0026id_str).expect(\"bench: id\");\n                    cache\n                        .insert(\u0026id, make_entry(\u0026engine, \u0026format!(\"t{i}.wasm\")))\n                        .await;\n                }\n                black_box(cache.len().await);\n            });\n        });\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_cache_insert,\n    bench_cache_get_hit,\n    bench_cache_get_miss,\n    bench_cache_eviction,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","cache.rs"],"content":"//! Compiled component cache with LRU eviction.\n//!\n//! Caches pre-compiled `wasmtime::component::Component` instances keyed\n//! by `ToolId`. Compilation is expensive; instantiation is cheap.\n//! Uses a `Mutex` since LRU tracking requires mutable access on reads.\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse tokio::sync::Mutex;\nuse wasmtime::component::Component;\n\nuse kami_types::{SecurityConfig, ToolId};\n\n/// A cached compiled component with its security config.\n#[derive(Clone)]\npub struct CachedComponent {\n    /// Pre-compiled wasmtime component.\n    pub component: Component,\n    /// Security config from the tool manifest.\n    pub security: SecurityConfig,\n    /// WASM file path for cache invalidation.\n    pub wasm_path: String,\n}\n\n/// Thread-safe LRU cache for compiled WASM components.\n///\n/// Components are keyed by `ToolId` and can be shared across\n/// concurrent executions. Uses LRU eviction when the cache\n/// reaches its maximum capacity.\n#[derive(Clone)]\npub struct ComponentCache {\n    inner: Arc\u003cMutex\u003cLruInner\u003e\u003e,\n}\n\n/// Internal LRU state: `order` front = least recently used.\nstruct LruInner {\n    entries: HashMap\u003cString, CachedComponent\u003e,\n    order: Vec\u003cString\u003e,\n    max_size: usize,\n}\n\nimpl ComponentCache {\n    /// Creates a new cache with the given maximum size.\n    pub fn new(max_size: usize) -\u003e Self {\n        Self {\n            inner: Arc::new(Mutex::new(LruInner {\n                entries: HashMap::new(),\n                order: Vec::with_capacity(max_size),\n                max_size,\n            })),\n        }\n    }\n\n    /// Gets a cached component by tool ID, marking it as recently used.\n    pub async fn get(\u0026self, id: \u0026ToolId) -\u003e Option\u003cCachedComponent\u003e {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str();\n        if inner.entries.contains_key(key) {\n            inner.touch(key);\n            inner.entries.get(key).cloned()\n        } else {\n            None\n        }\n    }\n\n    /// Inserts a compiled component into the cache.\n    ///\n    /// If the cache is full, the least recently used entry is evicted.\n    pub async fn insert(\u0026self, id: \u0026ToolId, entry: CachedComponent) {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str().to_string();\n        if inner.entries.contains_key(\u0026key) {\n            inner.touch(\u0026key);\n        } else {\n            if inner.entries.len() \u003e= inner.max_size {\n                inner.evict_lru();\n            }\n            inner.order.push(key.clone());\n        }\n        inner.entries.insert(key, entry);\n    }\n\n    /// Removes a cached component.\n    pub async fn invalidate(\u0026self, id: \u0026ToolId) {\n        let mut inner = self.inner.lock().await;\n        let key = id.as_str();\n        inner.entries.remove(key);\n        inner.order.retain(|k| k != key);\n    }\n\n    /// Clears the entire cache.\n    pub async fn clear(\u0026self) {\n        let mut inner = self.inner.lock().await;\n        inner.entries.clear();\n        inner.order.clear();\n    }\n\n    /// Returns the number of cached components.\n    pub async fn len(\u0026self) -\u003e usize {\n        let inner = self.inner.lock().await;\n        inner.entries.len()\n    }\n\n    /// Returns true if the cache is empty.\n    pub async fn is_empty(\u0026self) -\u003e bool {\n        self.len().await == 0\n    }\n}\n\nimpl LruInner {\n    /// Moves `key` to the back (most recently used).\n    fn touch(\u0026mut self, key: \u0026str) {\n        self.order.retain(|k| k != key);\n        self.order.push(key.to_string());\n    }\n\n    /// Evicts the least recently used entry (front of the order vec).\n    fn evict_lru(\u0026mut self) {\n        if let Some(lru_key) = self.order.first().cloned() {\n            self.order.remove(0);\n            self.entries.remove(\u0026lru_key);\n        }\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":47,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":56,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":57,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":58,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":59,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":60,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":61,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":63,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":70,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":71,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":72,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":73,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":81,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":115,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":32,"coverable":39},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","context.rs"],"content":"//! Execution context for tool invocations.\n\nuse std::collections::HashMap;\nuse std::time::Duration;\n\nuse kami_types::ToolId;\n\n/// Context passed to a tool execution.\n#[derive(Debug, Clone)]\npub struct ExecutionContext {\n    /// The tool being executed.\n    pub tool_id: ToolId,\n    /// Arguments for the tool.\n    pub arguments: HashMap\u003cString, serde_json::Value\u003e,\n    /// Execution timeout.\n    pub timeout: Duration,\n    /// Unique execution ID for tracing.\n    pub execution_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","error.rs"],"content":"//! Runtime-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the runtime orchestrator.\n#[derive(Debug, Error)]\npub enum RuntimeError {\n    /// Tool not found in registry.\n    #[error(\"tool not found: {name}\")]\n    ToolNotFound { name: String },\n    /// Engine error during execution.\n    #[error(\"engine error: {0}\")]\n    Engine(#[from] kami_engine::EngineError),\n    /// Sandbox policy violation.\n    #[error(\"sandbox error: {0}\")]\n    Sandbox(#[from] kami_sandbox::SandboxError),\n    /// Execution timed out.\n    #[error(\"execution timed out after {timeout_ms}ms\")]\n    Timeout { timeout_ms: u64 },\n    /// Pool exhausted (no available instances).\n    #[error(\"instance pool exhausted\")]\n    PoolExhausted,\n    /// WASM file hash does not match the stored SHA-256 digest.\n    #[error(\"integrity violation for tool '{tool_id}': {detail}\")]\n    IntegrityViolation { tool_id: String, detail: String },\n    /// Request rejected by rate limiter.\n    #[error(\"rate limited: tool '{tool_id}' exceeded {limit} req/{window_secs}s\")]\n    RateLimited {\n        tool_id: String,\n        limit: u64,\n        window_secs: u64,\n    },\n}\n\nimpl From\u003cRuntimeError\u003e for KamiError {\n    fn from(e: RuntimeError) -\u003e Self {\n        let kind = match \u0026e {\n            RuntimeError::ToolNotFound { .. } =\u003e ErrorKind::NotFound,\n            RuntimeError::Sandbox(kami_sandbox::SandboxError::InvalidConfig { .. }) =\u003e {\n                ErrorKind::InvalidInput\n            }\n            RuntimeError::Sandbox(_) =\u003e ErrorKind::PermissionDenied,\n            RuntimeError::Timeout { .. } =\u003e ErrorKind::Timeout,\n            RuntimeError::PoolExhausted =\u003e ErrorKind::ResourceExhausted,\n            RuntimeError::IntegrityViolation { .. } =\u003e ErrorKind::PermissionDenied,\n            RuntimeError::RateLimited { .. } =\u003e ErrorKind::ResourceExhausted,\n            RuntimeError::Engine(_) =\u003e ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for RuntimeError {\n    fn hint(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::ToolNotFound { name } =\u003e Some(format!(\n                \"No tool with id '{name}' is registered in the local database.\"\n            )),\n            Self::Timeout { timeout_ms } =\u003e {\n                Some(format!(\"Execution exceeded the {timeout_ms}ms time limit.\"))\n            }\n            Self::PoolExhausted =\u003e {\n                Some(\"All execution slots are busy. The system is under heavy load.\".into())\n            }\n            Self::IntegrityViolation { .. } =\u003e Some(\n                \"The WASM file on disk does not match the SHA-256 hash recorded at install time.\"\n                    .into(),\n            ),\n            Self::RateLimited { .. } =\u003e {\n                Some(\"Too many requests for this tool in the current time window.\".into())\n            }\n            Self::Engine(e) =\u003e e.hint(),\n            Self::Sandbox(e) =\u003e e.hint(),\n        }\n    }\n\n    fn fix(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::ToolNotFound { .. } =\u003e {\n                Some(\"Install the tool first: kami install \u003cpath-to-tool\u003e\".into())\n            }\n            Self::Timeout { .. } =\u003e Some(\n                \"Increase the timeout in tool.toml:\\n  [security]\\n  max_execution_ms = 10000\"\n                    .into(),\n            ),\n            Self::PoolExhausted =\u003e {\n                Some(\"Increase runtime concurrency: kami serve --concurrency 16\".into())\n            }\n            Self::IntegrityViolation { .. } =\u003e {\n                Some(\"Re-install the tool: kami uninstall \u003cid\u003e \u0026\u0026 kami install \u003cpath\u003e\".into())\n            }\n            Self::RateLimited { .. } =\u003e {\n                Some(\"Wait before retrying, or increase rate_limit_per_tool in config.\".into())\n            }\n            Self::Engine(e) =\u003e e.fix(),\n            Self::Sandbox(e) =\u003e e.fix(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn tool_not_found_maps_to_not_found() {\n        let err: KamiError =\n            RuntimeError::ToolNotFound { name: \"x\".into() }.into();\n        assert_eq!(err.kind, ErrorKind::NotFound);\n    }\n\n    #[test]\n    fn timeout_maps_to_timeout_kind() {\n        let err: KamiError =\n            RuntimeError::Timeout { timeout_ms: 5000 }.into();\n        assert_eq!(err.kind, ErrorKind::Timeout);\n    }\n\n    #[test]\n    fn rate_limited_has_fix_suggestion() {\n        let e = RuntimeError::RateLimited {\n            tool_id: \"t\".into(),\n            limit: 10,\n            window_secs: 60,\n        };\n        assert!(e.fix().expect(\"has fix\").contains(\"rate_limit\"));\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":33},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","executor.rs"],"content":"//! Async tool executor with full isolation pipeline.\n//!\n//! Pipeline: validate config → build sandbox → apply limits → execute with timeout.\n\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse tracing::{debug, warn};\nuse wasmtime::component::{Component, Linker};\nuse wasmtime::Engine;\n\nuse kami_engine::{\n    call_tool_run, create_store, instantiate_component, set_epoch_deadline, HostState,\n};\nuse kami_sandbox::{build_wasi_ctx, validate_security_config, WasiConfig};\nuse kami_types::SecurityConfig;\n\nuse crate::error::RuntimeError;\nuse crate::types::{ExecutionResult, ToolExecutor};\n\n/// Concrete executor that runs WASM components through the\n/// engine + sandbox pipeline with full isolation enforcement.\npub struct WasmToolExecutor {\n    engine: Engine,\n    linker: Linker\u003cHostState\u003e,\n}\n\nimpl WasmToolExecutor {\n    /// Creates a new executor with a pre-configured engine and linker.\n    pub fn new(engine: Engine, linker: Linker\u003cHostState\u003e) -\u003e Self {\n        Self { engine, linker }\n    }\n}\n\n#[async_trait]\nimpl ToolExecutor for WasmToolExecutor {\n    /// Executes a component with full isolation pipeline.\n    ///\n    /// # Errors\n    ///\n    /// Returns `RuntimeError::Sandbox` if security config is invalid.\n    /// Returns `RuntimeError::Engine` if the component fails to execute.\n    /// Returns `RuntimeError::Timeout` if execution exceeds the deadline.\n    #[tracing::instrument(skip_all, fields(\n        max_fuel = security.limits.max_fuel,\n        timeout_ms = security.limits.max_execution_ms,\n    ))]\n    async fn execute(\n        \u0026self,\n        component: \u0026Component,\n        input: \u0026str,\n        security: \u0026SecurityConfig,\n    ) -\u003e Result\u003cExecutionResult, RuntimeError\u003e {\n        let start = Instant::now();\n\n        // 1. Validate security config\n        validate_security_config(security)?;\n\n        let fuel = security.limits.max_fuel;\n        let max_memory = security.limits.max_memory_mb as usize * 1024 * 1024;\n        let timeout_duration = Duration::from_millis(security.limits.max_execution_ms);\n\n        debug!(\n            fuel,\n            max_memory_mb = security.limits.max_memory_mb,\n            timeout_ms = security.limits.max_execution_ms,\n            \"starting isolated execution\"\n        );\n\n        // 2. Build sandboxed WASI context\n        let wasi_config = WasiConfig {\n            inherit_stdout: true,\n            inherit_stderr: true,\n            ..WasiConfig::default()\n        };\n        let wasi_ctx = build_wasi_ctx(security, \u0026wasi_config, None)?;\n\n        // 3. Create store with memory limits + fuel\n        let host_state = HostState::with_limits(wasi_ctx, max_memory);\n        let mut store = create_store(\u0026self.engine, host_state, fuel)?;\n\n        // 4. Set epoch deadline (1 tick = timeout reached)\n        set_epoch_deadline(\u0026mut store, 1);\n\n        // 5. Spawn epoch ticker that increments epoch after timeout\n        let engine_clone = self.engine.clone();\n        let tick_handle = tokio::spawn(async move {\n            tokio::time::sleep(timeout_duration).await;\n            engine_clone.increment_epoch();\n        });\n\n        // 6. Instantiate and call (store is borrowed, not moved)\n        let outer_timeout = timeout_duration + Duration::from_millis(500);\n        let call_result = tokio::time::timeout(outer_timeout, async {\n            let instance = instantiate_component(\u0026self.linker, \u0026mut store, component).await?;\n            call_tool_run(\u0026mut store, \u0026instance, input).await\n        })\n        .await;\n\n        tick_handle.abort();\n\n        let duration_ms = start.elapsed().as_millis() as u64;\n        let fuel_remaining = store.get_fuel().unwrap_or(0);\n        let fuel_consumed = fuel.saturating_sub(fuel_remaining);\n\n        match call_result {\n            Ok(Ok(Ok(output))) =\u003e Ok(ExecutionResult {\n                content: output,\n                duration_ms,\n                success: true,\n                fuel_consumed,\n            }),\n            Ok(Ok(Err(error))) =\u003e Ok(ExecutionResult {\n                content: error,\n                duration_ms,\n                success: false,\n                fuel_consumed,\n            }),\n            Ok(Err(engine_err)) =\u003e {\n                warn!(?engine_err, \"engine error during execution\");\n                Err(engine_err.into())\n            }\n            Err(_elapsed) =\u003e {\n                warn!(\n                    timeout_ms = security.limits.max_execution_ms,\n                    \"execution timed out\"\n                );\n                Err(RuntimeError::Timeout {\n                    timeout_ms: security.limits.max_execution_ms,\n                })\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":95,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":96,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":4,"coverable":7},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","integrity.rs"],"content":"//! WASM component integrity verification.\n//!\n//! Computes and verifies SHA-256 hashes of WASM files to detect\n//! tampering between install time and execution time.\n\nuse std::io;\nuse std::path::Path;\n\nuse hex::ToHex;\nuse sha2::{Digest, Sha256};\n\n/// Computes the SHA-256 hash of a file and returns it as a hex string.\n///\n/// # Errors\n///\n/// Returns `io::Error` if the file cannot be read.\npub fn compute_file_hash(path: \u0026Path) -\u003e Result\u003cString, io::Error\u003e {\n    let bytes = std::fs::read(path)?;\n    let mut hasher = Sha256::new();\n    hasher.update(\u0026bytes);\n    Ok(hasher.finalize().encode_hex::\u003cString\u003e())\n}\n\n/// Verifies that a file matches an expected SHA-256 hex digest.\n///\n/// Returns `Ok(())` if the hash matches or if `expected` is `None`\n/// (no stored hash = verification skipped for backwards compatibility).\n///\n/// # Errors\n///\n/// Returns `Err(actual_hash)` if the computed hash differs from `expected`.\npub fn verify_hash(path: \u0026Path, expected: \u0026Option\u003cString\u003e) -\u003e Result\u003c(), io::Error\u003e {\n    let Some(expected_hash) = expected else {\n        // No stored hash — skip verification (pre-integrity install).\n        return Ok(());\n    };\n\n    let actual = compute_file_hash(path)?;\n    if actual != *expected_hash {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\"integrity violation: expected {expected_hash}, got {actual}\"),\n        ));\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn hash_deterministic() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"hello\").unwrap();\n        let h1 = compute_file_hash(f.path()).unwrap();\n        let h2 = compute_file_hash(f.path()).unwrap();\n        assert_eq!(h1, h2);\n    }\n\n    #[test]\n    fn hash_known_value() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"\").unwrap();\n        let h = compute_file_hash(f.path()).unwrap();\n        // SHA-256 of empty input\n        assert_eq!(\n            h,\n            \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n        );\n    }\n\n    #[test]\n    fn verify_passes_when_no_expected() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        assert!(verify_hash(f.path(), \u0026None).is_ok());\n    }\n\n    #[test]\n    fn verify_passes_with_correct_hash() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        let hash = compute_file_hash(f.path()).unwrap();\n        assert!(verify_hash(f.path(), \u0026Some(hash)).is_ok());\n    }\n\n    #[test]\n    fn verify_fails_with_wrong_hash() {\n        let mut f = NamedTempFile::new().unwrap();\n        f.write_all(b\"data\").unwrap();\n        let wrong = \"0\".repeat(64);\n        assert!(verify_hash(f.path(), \u0026Some(wrong)).is_err());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":18,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":19,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":20,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":21,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":39,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":14,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","lib.rs"],"content":"//! # kami-runtime\n//!\n//! Runtime orchestrator for KAMI.\n//! Manages tool execution, scheduling, component caching, and\n//! tool resolution from the registry.\n//!\n//! Use `KamiRuntime` for high-level tool execution by ID, or\n//! `WasmToolExecutor` directly for low-level component execution.\n\npub mod cache;\npub mod context;\npub mod error;\npub mod executor;\npub mod integrity;\npub mod metrics;\npub mod orchestrator;\npub mod pipeline;\npub mod rate_limiter;\npub mod resolver;\npub mod runtime_config;\npub mod scheduler;\npub mod types;\n\npub use cache::{CachedComponent, ComponentCache};\npub use context::ExecutionContext;\npub use error::RuntimeError;\npub use executor::WasmToolExecutor;\npub use integrity::{compute_file_hash, verify_hash};\npub use metrics::{ExecutionMetrics, MetricsSnapshot};\npub use orchestrator::KamiRuntime;\npub use pipeline::{\n    execute_pipeline, PipelineDefinition, PipelineError, PipelineResult, PipelineStep, StepResult,\n};\npub use rate_limiter::{RateLimitConfig, RateLimiter};\npub use resolver::ToolResolver;\npub use runtime_config::RuntimeConfig;\npub use scheduler::{Priority, Scheduler, SchedulerConfig};\npub use types::{ExecutionResult, ToolExecutor};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","metrics.rs"],"content":"//! Execution metrics for the KAMI runtime.\n//!\n//! Tracks key counters using lock-free atomics for zero-overhead recording\n//! from concurrent async tasks. Use [`MetricsSnapshot`] for human-readable output.\n\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\n/// Shared, thread-safe execution metrics collected by [`super::KamiRuntime`].\n///\n/// All fields are `AtomicU64` — incrementing from any async task is safe and fast.\n#[derive(Debug, Default)]\npub struct ExecutionMetrics {\n    /// Total number of tool executions attempted.\n    pub total_executions: AtomicU64,\n    /// Number of executions that completed successfully.\n    pub successful_executions: AtomicU64,\n    /// Number of executions that returned an error.\n    pub failed_executions: AtomicU64,\n    /// Cumulative fuel consumed across all successful executions.\n    pub total_fuel_consumed: AtomicU64,\n    /// Number of times a compiled component was found in the cache.\n    pub cache_hits: AtomicU64,\n    /// Number of times a component had to be compiled from scratch.\n    pub cache_misses: AtomicU64,\n}\n\n/// A point-in-time snapshot of [`ExecutionMetrics`].\n///\n/// Use [`ExecutionMetrics::snapshot`] to obtain a copyable view.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MetricsSnapshot {\n    /// Total executions attempted.\n    pub total_executions: u64,\n    /// Successful executions.\n    pub successful_executions: u64,\n    /// Failed executions.\n    pub failed_executions: u64,\n    /// Cumulative fuel consumed.\n    pub total_fuel_consumed: u64,\n    /// Cache hits (compiled component reused).\n    pub cache_hits: u64,\n    /// Cache misses (component compiled fresh).\n    pub cache_misses: u64,\n}\n\nimpl ExecutionMetrics {\n    /// Creates a new zeroed metrics instance wrapped in an [`Arc`].\n    pub fn new_shared() -\u003e Arc\u003cSelf\u003e {\n        Arc::new(Self::default())\n    }\n\n    /// Records one attempted execution.\n    pub fn record_attempt(\u0026self) {\n        self.total_executions.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a successful execution with the given fuel consumed.\n    pub fn record_success(\u0026self, fuel_consumed: u64) {\n        self.successful_executions.fetch_add(1, Ordering::Relaxed);\n        self.total_fuel_consumed\n            .fetch_add(fuel_consumed, Ordering::Relaxed);\n    }\n\n    /// Records a failed execution.\n    pub fn record_failure(\u0026self) {\n        self.failed_executions.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a cache hit (component was reused from the cache).\n    pub fn record_cache_hit(\u0026self) {\n        self.cache_hits.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Records a cache miss (component was compiled and stored).\n    pub fn record_cache_miss(\u0026self) {\n        self.cache_misses.fetch_add(1, Ordering::Relaxed);\n    }\n\n    /// Returns a point-in-time snapshot of all counters.\n    pub fn snapshot(\u0026self) -\u003e MetricsSnapshot {\n        MetricsSnapshot {\n            total_executions: self.total_executions.load(Ordering::Relaxed),\n            successful_executions: self.successful_executions.load(Ordering::Relaxed),\n            failed_executions: self.failed_executions.load(Ordering::Relaxed),\n            total_fuel_consumed: self.total_fuel_consumed.load(Ordering::Relaxed),\n            cache_hits: self.cache_hits.load(Ordering::Relaxed),\n            cache_misses: self.cache_misses.load(Ordering::Relaxed),\n        }\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":50,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":54,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":55,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":60,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":77,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":81,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":83,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":84,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":85,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":86,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":87,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":88,"address":[],"length":0,"stats":{"Line":1008806316530991104}}],"covered":21,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","orchestrator.rs"],"content":"//! Top-level runtime orchestrator — combines resolution, scheduling, and WASM execution.\n\nuse std::sync::Arc;\n\nuse kami_engine::{create_engine, create_linker, HostState, InstanceConfig};\nuse kami_registry::ToolRepository;\nuse kami_types::ToolId;\nuse tracing::{info, warn};\nuse wasmtime::{component::Linker, Engine};\n\nuse crate::scheduler::{Scheduler, SchedulerConfig};\nuse crate::types::{ExecutionResult, ToolExecutor};\nuse crate::{cache::ComponentCache, error::RuntimeError, executor::WasmToolExecutor};\nuse crate::{metrics::ExecutionMetrics, resolver::ToolResolver, runtime_config::RuntimeConfig};\n\n/// Top-level runtime orchestrator.\n///\n/// Combines tool resolution, scheduling, and sandboxed WASM execution.\n/// Use `metrics()` to read live atomic counters.\npub struct KamiRuntime {\n    executor: WasmToolExecutor,\n    resolver: ToolResolver,\n    scheduler: Scheduler,\n    metrics: Arc\u003cExecutionMetrics\u003e,\n}\n\nimpl KamiRuntime {\n    /// Creates a new runtime with the given configuration and repository.\n    ///\n    /// # Errors\n    /// Returns `RuntimeError` if the engine or linker cannot be created.\n    pub fn new(\n        config: RuntimeConfig,\n        repository: Arc\u003cdyn ToolRepository\u003e,\n    ) -\u003e Result\u003cSelf, RuntimeError\u003e {\n        let instance_config = InstanceConfig {\n            epoch_interruption: config.epoch_interruption,\n            ..InstanceConfig::default()\n        };\n        let engine = create_engine(\u0026instance_config)?;\n        let linker = create_linker(\u0026engine)?;\n        let cache = ComponentCache::new(config.cache_size);\n        let scheduler = Scheduler::new(\u0026SchedulerConfig {\n            max_concurrent: config.max_concurrent,\n        });\n        let metrics = ExecutionMetrics::new_shared();\n        Ok(Self {\n            executor: WasmToolExecutor::new(engine.clone(), linker),\n            resolver: ToolResolver::new(engine, cache, repository),\n            scheduler,\n            metrics,\n        })\n    }\n\n    /// Creates a runtime from an existing engine and linker.\n    pub fn with_engine(\n        engine: Engine,\n        linker: Linker\u003cHostState\u003e,\n        config: RuntimeConfig,\n        repository: Arc\u003cdyn ToolRepository\u003e,\n    ) -\u003e Self {\n        let cache = ComponentCache::new(config.cache_size);\n        let scheduler_config = SchedulerConfig {\n            max_concurrent: config.max_concurrent,\n        };\n        let metrics = ExecutionMetrics::new_shared();\n        Self {\n            executor: WasmToolExecutor::new(engine.clone(), linker),\n            resolver: ToolResolver::new(engine, cache, repository),\n            scheduler: Scheduler::new(\u0026scheduler_config),\n            metrics,\n        }\n    }\n\n    /// Executes a tool by its ID with the given JSON input.\n    ///\n    /// # Errors\n    /// Returns `RuntimeError::ToolNotFound` or `RuntimeError::PoolExhausted`.\n    #[tracing::instrument(skip(self, input), fields(tool_id = %tool_id))]\n    pub async fn execute(\n        \u0026self,\n        tool_id: \u0026ToolId,\n        input: \u0026str,\n    ) -\u003e Result\u003cExecutionResult, RuntimeError\u003e {\n        info!(%tool_id, \"executing tool\");\n        self.metrics.record_attempt();\n\n        if self.resolver.cache().get(tool_id).await.is_some() {\n            self.metrics.record_cache_hit();\n        } else {\n            self.metrics.record_cache_miss();\n        }\n\n        let _permit = self\n            .scheduler\n            .acquire()\n            .await\n            .inspect_err(|_| self.metrics.record_failure())?;\n        let cached = self\n            .resolver\n            .resolve(tool_id)\n            .await\n            .inspect_err(|_| self.metrics.record_failure())?;\n\n        let result = self\n            .executor\n            .execute(\u0026cached.component, input, \u0026cached.security)\n            .await;\n\n        match \u0026result {\n            Ok(r) =\u003e {\n                self.metrics.record_success(r.fuel_consumed);\n                info!(%tool_id, success = r.success, duration_ms = r.duration_ms,\n                    fuel = r.fuel_consumed, \"execution complete\");\n            }\n            Err(e) =\u003e {\n                self.metrics.record_failure();\n                warn!(%tool_id, error = %e, \"execution failed\");\n            }\n        }\n        result\n    }\n\n    /// Gracefully shuts down the runtime by draining all in-flight executions.\n    pub async fn shutdown(\u0026self) {\n        self.scheduler.drain().await;\n        info!(\"runtime shutdown complete\");\n    }\n\n    /// Invalidates the component cache for a specific tool.\n    pub async fn invalidate_cache(\u0026self, tool_id: \u0026ToolId) {\n        self.resolver.invalidate(tool_id).await;\n    }\n\n    /// Returns a shared handle to the runtime execution metrics.\n    pub fn metrics(\u0026self) -\u003e Arc\u003cExecutionMetrics\u003e {\n        self.metrics.clone()\n    }\n\n    pub fn resolver(\u0026self) -\u003e \u0026ToolResolver {\n        \u0026self.resolver\n    }\n\n    pub fn scheduler(\u0026self) -\u003e \u0026Scheduler {\n        \u0026self.scheduler\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":41,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":42,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":43,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":44,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":46,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":47,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":48,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":49,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":50,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":51,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":137,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":21,"coverable":34},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","pipeline.rs"],"content":"//! Multi-tool pipeline execution — chains tool outputs as inputs.\n//!\n//! A pipeline is an ordered sequence of steps where each step's output\n//! can feed into the next step's input via `input_from: \"previous\"`.\n\nuse serde::{Deserialize, Serialize};\n\nuse kami_types::ToolId;\n\n/// A single step in a pipeline.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineStep {\n    /// Tool to execute.\n    pub tool: ToolId,\n    /// Explicit JSON input (used if `input_from` is `None`).\n    #[serde(default)]\n    pub input: Option\u003cserde_json::Value\u003e,\n    /// Source of input: `\"previous\"` uses the prior step's output.\n    #[serde(default)]\n    pub input_from: Option\u003cString\u003e,\n}\n\n/// Definition of a multi-step pipeline.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineDefinition {\n    /// Ordered list of execution steps.\n    pub steps: Vec\u003cPipelineStep\u003e,\n}\n\n/// Result of a single pipeline step.\n#[derive(Debug, Clone)]\npub struct StepResult {\n    /// The tool that was executed.\n    pub tool: ToolId,\n    /// JSON output string.\n    pub output: String,\n    /// Whether execution succeeded.\n    pub success: bool,\n    /// Execution time in milliseconds.\n    pub duration_ms: u64,\n}\n\n/// Result of a complete pipeline execution.\n#[derive(Debug, Clone)]\npub struct PipelineResult {\n    /// Results for each step, in order.\n    pub steps: Vec\u003cStepResult\u003e,\n    /// Whether all steps completed successfully.\n    pub success: bool,\n}\n\n/// Errors specific to pipeline execution.\n#[derive(Debug, thiserror::Error)]\npub enum PipelineError {\n    /// The pipeline has no steps.\n    #[error(\"pipeline has no steps\")]\n    Empty,\n    /// A step references `input_from` but has no previous step.\n    #[error(\"step {index} uses input_from but is the first step\")]\n    NoPreviousStep { index: usize },\n    /// A step failed, halting the pipeline.\n    #[error(\"step {index} (tool '{tool}') failed: {reason}\")]\n    StepFailed {\n        index: usize,\n        tool: String,\n        reason: String,\n    },\n    /// Runtime error during execution.\n    #[error(\"runtime error at step {index}: {source}\")]\n    Runtime {\n        index: usize,\n        #[source]\n        source: crate::error::RuntimeError,\n    },\n}\n\n/// Executes a pipeline against the given runtime.\n///\n/// Runs steps sequentially. If a step sets `input_from: \"previous\"`,\n/// it receives the output of the prior step as its input.\n///\n/// # Errors\n/// Returns `PipelineError` if any step fails or the definition is invalid.\npub async fn execute_pipeline(\n    runtime: \u0026crate::orchestrator::KamiRuntime,\n    definition: \u0026PipelineDefinition,\n) -\u003e Result\u003cPipelineResult, PipelineError\u003e {\n    if definition.steps.is_empty() {\n        return Err(PipelineError::Empty);\n    }\n    let mut results: Vec\u003cStepResult\u003e = Vec::with_capacity(definition.steps.len());\n\n    for (index, step) in definition.steps.iter().enumerate() {\n        let input = resolve_step_input(step, index, results.last())?;\n        let exec = runtime\n            .execute(\u0026step.tool, \u0026input)\n            .await\n            .map_err(|e| PipelineError::Runtime { index, source: e })?;\n        if !exec.success {\n            return Err(PipelineError::StepFailed {\n                index,\n                tool: step.tool.to_string(),\n                reason: exec.content.clone(),\n            });\n        }\n        results.push(StepResult {\n            tool: step.tool.clone(),\n            output: exec.content,\n            success: exec.success,\n            duration_ms: exec.duration_ms,\n        });\n    }\n\n    Ok(PipelineResult {\n        success: true,\n        steps: results,\n    })\n}\n\n/// Resolves the input for a step, either explicit or from previous output.\npub fn resolve_step_input(\n    step: \u0026PipelineStep,\n    index: usize,\n    previous: Option\u003c\u0026StepResult\u003e,\n) -\u003e Result\u003cString, PipelineError\u003e {\n    if let Some(ref source) = step.input_from {\n        if source == \"previous\" {\n            let prev = previous.ok_or(PipelineError::NoPreviousStep { index })?;\n            return Ok(prev.output.clone());\n        }\n    }\n    match \u0026step.input {\n        Some(v) =\u003e Ok(v.to_string()),\n        None =\u003e Ok(\"{}\".to_string()),\n    }\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":126,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":129,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":31},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","pool.rs"],"content":"//! Instance pool for warm-start optimization.\n\n/// Configuration for the instance pool.\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    /// Maximum number of cached instances.\n    pub max_size: usize,\n}\n\nimpl Default for PoolConfig {\n    fn default() -\u003e Self {\n        Self { max_size: 5 }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","rate_limiter.rs"],"content":"//! Token-bucket rate limiter for tool execution.\n//!\n//! Provides per-tool and global rate limits to prevent abuse.\n//! Uses an atomic token bucket that refills over a configurable window.\n\nuse std::collections::HashMap;\nuse std::sync::Mutex;\nuse std::time::{Duration, Instant};\n\nuse kami_types::ToolId;\n\n/// Configuration for the rate limiter.\n#[derive(Debug, Clone)]\npub struct RateLimitConfig {\n    /// Maximum requests per window per tool (0 = unlimited).\n    pub per_tool: u64,\n    /// Maximum global requests per window (0 = unlimited).\n    pub global: u64,\n    /// Sliding window duration.\n    pub window: Duration,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            per_tool: 100,\n            global: 1000,\n            window: Duration::from_secs(60),\n        }\n    }\n}\n\n/// Token bucket for a single rate-limit counter.\n#[derive(Debug)]\nstruct TokenBucket {\n    tokens: u64,\n    capacity: u64,\n    last_refill: Instant,\n    window: Duration,\n}\n\nimpl TokenBucket {\n    fn new(capacity: u64, window: Duration) -\u003e Self {\n        Self {\n            tokens: capacity,\n            capacity,\n            last_refill: Instant::now(),\n            window,\n        }\n    }\n\n    /// Tries to consume one token. Returns `true` if allowed.\n    fn try_acquire(\u0026mut self) -\u003e bool {\n        self.refill();\n        if self.tokens \u003e 0 {\n            self.tokens -= 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    fn refill(\u0026mut self) {\n        let elapsed = self.last_refill.elapsed();\n        if elapsed \u003e= self.window {\n            self.tokens = self.capacity;\n            self.last_refill = Instant::now();\n        }\n    }\n}\n\n/// Rate limiter with per-tool and global limits.\n#[derive(Debug)]\npub struct RateLimiter {\n    config: RateLimitConfig,\n    global: Mutex\u003cTokenBucket\u003e,\n    per_tool: Mutex\u003cHashMap\u003cToolId, TokenBucket\u003e\u003e,\n}\n\nimpl RateLimiter {\n    /// Creates a new rate limiter with the given configuration.\n    pub fn new(config: \u0026RateLimitConfig) -\u003e Self {\n        Self {\n            config: config.clone(),\n            global: Mutex::new(TokenBucket::new(config.global, config.window)),\n            per_tool: Mutex::new(HashMap::new()),\n        }\n    }\n\n    /// Checks if a request for the given tool is allowed.\n    ///\n    /// Returns `true` if the request is within both the per-tool and\n    /// global rate limits.\n    pub fn check(\u0026self, tool_id: \u0026ToolId) -\u003e bool {\n        if self.config.global == 0 \u0026\u0026 self.config.per_tool == 0 {\n            return true;\n        }\n        if self.config.global \u003e 0 {\n            let mut global = self.global.lock().unwrap_or_else(|e| e.into_inner());\n            if !global.try_acquire() {\n                return false;\n            }\n        }\n        if self.config.per_tool \u003e 0 {\n            let mut map = self.per_tool.lock().unwrap_or_else(|e| e.into_inner());\n            let bucket = map\n                .entry(tool_id.clone())\n                .or_insert_with(|| TokenBucket::new(self.config.per_tool, self.config.window));\n            if !bucket.try_acquire() {\n                return false;\n            }\n        }\n        true\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":47,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":53,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":54,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":55,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":56,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":57,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":64,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":65,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":84,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":85,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":94,"address":[],"length":0,"stats":{"Line":17221764975064776704}},{"line":95,"address":[],"length":0,"stats":{"Line":15492382718154506243}},{"line":96,"address":[],"length":0,"stats":{"Line":16717361816799281155}},{"line":98,"address":[],"length":0,"stats":{"Line":504403158265495549}},{"line":99,"address":[],"length":0,"stats":{"Line":2017612633061982220}},{"line":100,"address":[],"length":0,"stats":{"Line":504403158265495555}},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927939}},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567610}},{"line":105,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":106,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":107,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":108,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":360287970189639674}}],"covered":32,"coverable":34},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","resolver.rs"],"content":"//! Tool resolution from registry to compiled component.\n//!\n//! Resolves a `ToolId` by looking it up in the registry, loading the\n//! WASM file, compiling it, and caching the result.\n\nuse std::path::Path;\nuse std::sync::Arc;\n\nuse tracing::{debug, info};\nuse wasmtime::Engine;\n\nuse kami_engine::load_component_from_file;\nuse kami_registry::ToolRepository;\nuse kami_types::ToolId;\n\nuse crate::cache::{CachedComponent, ComponentCache};\nuse crate::error::RuntimeError;\nuse crate::integrity;\n\n/// Resolves tools from the registry and compiles their WASM components.\n///\n/// Uses `ComponentCache` to avoid recompilation on subsequent calls.\npub struct ToolResolver {\n    engine: Engine,\n    cache: ComponentCache,\n    repository: Arc\u003cdyn ToolRepository\u003e,\n}\n\nimpl ToolResolver {\n    /// Creates a new resolver with the given engine, cache, and repository.\n    pub fn new(engine: Engine, cache: ComponentCache, repository: Arc\u003cdyn ToolRepository\u003e) -\u003e Self {\n        Self {\n            engine,\n            cache,\n            repository,\n        }\n    }\n\n    /// Resolves a tool ID to a compiled component.\n    ///\n    /// Returns the cached component if available, otherwise loads from\n    /// the registry, compiles, and caches.\n    #[tracing::instrument(skip(self), fields(tool_id = %id))]\n    pub async fn resolve(\u0026self, id: \u0026ToolId) -\u003e Result\u003cCachedComponent, RuntimeError\u003e {\n        // 1. Check cache first\n        if let Some(cached) = self.cache.get(id).await {\n            debug!(%id, \"cache hit\");\n            return Ok(cached);\n        }\n\n        // 2. Look up in registry\n        let tool = self\n            .repository\n            .find_by_id(id)\n            .await\n            .map_err(|e| RuntimeError::ToolNotFound {\n                name: format!(\"{id}: {e}\"),\n            })?\n            .ok_or_else(|| RuntimeError::ToolNotFound {\n                name: id.to_string(),\n            })?;\n\n        // 3. Resolve WASM file path\n        let wasm_path = Path::new(\u0026tool.install_path).join(\u0026tool.manifest.wasm);\n\n        if !wasm_path.exists() {\n            return Err(RuntimeError::ToolNotFound {\n                name: format!(\"WASM file missing: {}\", wasm_path.display()),\n            });\n        }\n\n        // 4. Verify WASM integrity (skipped if no hash stored at install time)\n        integrity::verify_hash(\u0026wasm_path, \u0026tool.manifest.wasm_sha256).map_err(|e| {\n            RuntimeError::IntegrityViolation {\n                tool_id: id.to_string(),\n                detail: e.to_string(),\n            }\n        })?;\n\n        info!(%id, path = %wasm_path.display(), \"compiling component\");\n\n        // 5. Compile the component\n        let component = load_component_from_file(\u0026self.engine, \u0026wasm_path)?;\n\n        // 6. Cache it\n        let cached = CachedComponent {\n            component,\n            security: tool.manifest.security.clone(),\n            wasm_path: wasm_path.display().to_string(),\n        };\n        self.cache.insert(id, cached.clone()).await;\n\n        Ok(cached)\n    }\n\n    /// Invalidates the cache for a specific tool.\n    pub async fn invalidate(\u0026self, id: \u0026ToolId) {\n        self.cache.invalidate(id).await;\n    }\n\n    /// Returns a reference to the component cache.\n    pub fn cache(\u0026self) -\u003e \u0026ComponentCache {\n        \u0026self.cache\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":11,"coverable":12},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","runtime_config.rs"],"content":"//! Configuration for the KAMI runtime.\n\n/// Configuration for the KAMI runtime.\n#[derive(Debug, Clone)]\npub struct RuntimeConfig {\n    /// Component cache size.\n    pub cache_size: usize,\n    /// Scheduler concurrency limit.\n    pub max_concurrent: usize,\n    /// Enable epoch interruption for timeout.\n    pub epoch_interruption: bool,\n}\n\nimpl Default for RuntimeConfig {\n    fn default() -\u003e Self {\n        Self {\n            cache_size: 32,\n            max_concurrent: 4,\n            epoch_interruption: true,\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":1,"coverable":1},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","scheduler.rs"],"content":"//! Task scheduling with concurrency control and priorities.\n//!\n//! Uses a `tokio::sync::Semaphore` to limit concurrent WASM executions,\n//! preventing resource exhaustion on the host.\n\nuse std::sync::Arc;\n\nuse tokio::sync::Semaphore;\nuse tracing::debug;\n\n/// Task priority levels.\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord)]\npub enum Priority {\n    /// Low priority (background tasks).\n    Low = 0,\n    /// Normal priority (default).\n    #[default]\n    Normal = 1,\n    /// High priority (interactive).\n    High = 2,\n}\n\n/// Configuration for the task scheduler.\n#[derive(Debug, Clone)]\npub struct SchedulerConfig {\n    /// Maximum concurrent WASM executions.\n    pub max_concurrent: usize,\n}\n\nimpl Default for SchedulerConfig {\n    fn default() -\u003e Self {\n        Self { max_concurrent: 4 }\n    }\n}\n\n/// Concurrency-limited task scheduler.\n///\n/// Wraps a semaphore to ensure at most `max_concurrent` WASM\n/// executions run simultaneously.\n#[derive(Clone)]\npub struct Scheduler {\n    semaphore: Arc\u003cSemaphore\u003e,\n    max_concurrent: usize,\n}\n\nimpl Scheduler {\n    /// Creates a new scheduler with the given config.\n    pub fn new(config: \u0026SchedulerConfig) -\u003e Self {\n        Self {\n            semaphore: Arc::new(Semaphore::new(config.max_concurrent)),\n            max_concurrent: config.max_concurrent,\n        }\n    }\n\n    /// Acquires a permit to execute a task.\n    ///\n    /// Blocks until a slot is available. Returns a guard that\n    /// releases the permit when dropped.\n    pub async fn acquire(\u0026self) -\u003e Result\u003cSchedulerPermit, crate::error::RuntimeError\u003e {\n        debug!(\n            available = self.semaphore.available_permits(),\n            max = self.max_concurrent,\n            \"acquiring scheduler permit\"\n        );\n\n        let permit = self\n            .semaphore\n            .clone()\n            .acquire_owned()\n            .await\n            .map_err(|_| crate::error::RuntimeError::PoolExhausted)?;\n\n        Ok(SchedulerPermit { _permit: permit })\n    }\n\n    /// Returns the number of available execution slots.\n    pub fn available_permits(\u0026self) -\u003e usize {\n        self.semaphore.available_permits()\n    }\n\n    /// Returns the maximum concurrency level.\n    pub fn max_concurrent(\u0026self) -\u003e usize {\n        self.max_concurrent\n    }\n\n    /// Drains the scheduler by waiting until all in-flight tasks finish.\n    ///\n    /// Acquires every permit — once all are held simultaneously, every\n    /// previously-issued permit has been released, meaning all executing\n    /// tasks have completed. Permits are dropped immediately after.\n    pub async fn drain(\u0026self) {\n        let mut permits = Vec::with_capacity(self.max_concurrent);\n        for _ in 0..self.max_concurrent {\n            if let Ok(p) = self.semaphore.clone().acquire_owned().await {\n                permits.push(p);\n            }\n        }\n        // All in-flight executions are done; permits dropped here.\n    }\n}\n\n/// RAII guard that releases a scheduler permit when dropped.\npub struct SchedulerPermit {\n    _permit: tokio::sync::OwnedSemaphorePermit,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn scheduler_acquire_and_release() {\n        let scheduler = Scheduler::new(\u0026SchedulerConfig { max_concurrent: 2 });\n\n        assert_eq!(scheduler.available_permits(), 2);\n\n        let _p1 = scheduler.acquire().await.expect(\"permit 1\");\n        assert_eq!(scheduler.available_permits(), 1);\n\n        let _p2 = scheduler.acquire().await.expect(\"permit 2\");\n        assert_eq!(scheduler.available_permits(), 0);\n\n        drop(_p1);\n        assert_eq!(scheduler.available_permits(), 1);\n    }\n\n    #[tokio::test]\n    async fn scheduler_blocks_at_capacity() {\n        let scheduler = Scheduler::new(\u0026SchedulerConfig { max_concurrent: 1 });\n\n        let _p1 = scheduler.acquire().await.expect(\"permit\");\n        assert_eq!(scheduler.available_permits(), 0);\n\n        // Second acquire should block; use try_acquire to test\n        let try_result = scheduler.semaphore.clone().try_acquire_owned();\n        assert!(try_result.is_err(), \"should be at capacity\");\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":50,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":51,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":59,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":60,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":70,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":71,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":73,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":78,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-runtime","src","types.rs"],"content":"//! Shared types for tool execution results and the executor trait.\n\nuse async_trait::async_trait;\nuse wasmtime::component::Component;\n\nuse kami_types::SecurityConfig;\n\nuse crate::error::RuntimeError;\n\n/// Result of a tool execution.\n#[derive(Debug, Clone)]\npub struct ExecutionResult {\n    /// Output content from the tool.\n    pub content: String,\n    /// Execution duration in milliseconds.\n    pub duration_ms: u64,\n    /// Whether execution succeeded.\n    pub success: bool,\n    /// Fuel consumed during execution.\n    pub fuel_consumed: u64,\n}\n\n/// Trait for executing compiled WASM components.\n///\n/// Implementations apply the full isolation pipeline:\n/// sandbox, resource limits, epoch timeout.\n#[async_trait]\npub trait ToolExecutor: Send + Sync {\n    /// Executes a compiled component with the given input and security policy.\n    async fn execute(\n        \u0026self,\n        component: \u0026Component,\n        input: \u0026str,\n        security: \u0026SecurityConfig,\n    ) -\u003e Result\u003cExecutionResult, RuntimeError\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn execution_result_clone_preserves_fields() {\n        let r = ExecutionResult {\n            content: \"ok\".into(),\n            duration_ms: 42,\n            success: true,\n            fuel_consumed: 1000,\n        };\n        let c = r.clone();\n        assert_eq!(c.content, \"ok\");\n        assert_eq!(c.duration_ms, 42);\n        assert!(c.success);\n        assert_eq!(c.fuel_consumed, 1000);\n    }\n\n    #[test]\n    fn execution_result_debug_format() {\n        let r = ExecutionResult {\n            content: \"x\".into(),\n            duration_ms: 0,\n            success: false,\n            fuel_consumed: 0,\n        };\n        let dbg = format!(\"{r:?}\");\n        assert!(dbg.contains(\"ExecutionResult\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","capability.rs"],"content":"//! Capability checking trait and types.\n\nuse kami_types::{Capability, FsAccess, SecurityConfig};\n\nuse crate::error::SandboxError;\nuse crate::network::is_host_allowed;\n\n/// Trait for checking capabilities against a security config.\npub trait CapabilityChecker: Send + Sync {\n    /// Checks whether a capability is allowed by the security config.\n    fn check(\u0026self, capability: \u0026Capability, config: \u0026SecurityConfig) -\u003e Result\u003c(), SandboxError\u003e;\n}\n\n/// Default capability checker enforcing deny-all by default.\npub struct DefaultCapabilityChecker;\n\nimpl CapabilityChecker for DefaultCapabilityChecker {\n    fn check(\u0026self, capability: \u0026Capability, config: \u0026SecurityConfig) -\u003e Result\u003c(), SandboxError\u003e {\n        match capability {\n            Capability::Network(host) =\u003e {\n                if !is_host_allowed(host, \u0026config.net_allow_list) {\n                    return Err(SandboxError::NetworkDenied { host: host.clone() });\n                }\n            }\n            Capability::FsRead(path) =\u003e {\n                if config.fs_access == FsAccess::None {\n                    return Err(SandboxError::FsDenied { path: path.clone() });\n                }\n            }\n            Capability::FsWrite(path) =\u003e {\n                if config.fs_access != FsAccess::Sandbox {\n                    return Err(SandboxError::FsDenied { path: path.clone() });\n                }\n            }\n            Capability::EnvVar(var) =\u003e {\n                if !config.env_allow_list.iter().any(|v| v == var) {\n                    return Err(SandboxError::CapabilityDenied {\n                        capability: format!(\"env:{var}\"),\n                    });\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n/// Validates a `SecurityConfig` for well-formedness before use.\n///\n/// Catches misconfigurations early rather than at execution time.\npub fn validate_security_config(config: \u0026SecurityConfig) -\u003e Result\u003c(), SandboxError\u003e {\n    // Validate network patterns\n    crate::network::validate_allow_list(\u0026config.net_allow_list)\n        .map_err(|reason| SandboxError::InvalidConfig { reason })?;\n\n    // Validate resource limits\n    if config.limits.max_fuel == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_fuel must be \u003e 0\".to_string(),\n        });\n    }\n    if config.limits.max_memory_mb == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_memory_mb must be \u003e 0\".to_string(),\n        });\n    }\n    if config.limits.max_execution_ms == 0 {\n        return Err(SandboxError::InvalidConfig {\n            reason: \"max_execution_ms must be \u003e 0\".to_string(),\n        });\n    }\n\n    Ok(())\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":19,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":20,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":36,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":38,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":50,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":52,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":53,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":56,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":29,"coverable":29},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","error.rs"],"content":"//! Sandbox-specific error types.\n\nuse kami_types::{DiagnosticError, ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the sandbox layer.\n#[derive(Debug, Error)]\npub enum SandboxError {\n    /// A required capability was not granted.\n    #[error(\"capability denied: {capability}\")]\n    CapabilityDenied { capability: String },\n    /// Network access denied.\n    #[error(\"network access denied for host: {host}\")]\n    NetworkDenied { host: String },\n    /// Filesystem access denied.\n    #[error(\"filesystem access denied: {path}\")]\n    FsDenied { path: String },\n    /// WASI context build failure.\n    #[error(\"failed to build WASI context: {reason}\")]\n    WasiBuild { reason: String },\n    /// Invalid security configuration.\n    #[error(\"invalid security config: {reason}\")]\n    InvalidConfig { reason: String },\n}\n\nimpl From\u003cSandboxError\u003e for KamiError {\n    fn from(e: SandboxError) -\u003e Self {\n        let kind = match \u0026e {\n            SandboxError::CapabilityDenied { .. }\n            | SandboxError::NetworkDenied { .. }\n            | SandboxError::FsDenied { .. } =\u003e ErrorKind::PermissionDenied,\n            SandboxError::WasiBuild { .. } =\u003e ErrorKind::Internal,\n            SandboxError::InvalidConfig { .. } =\u003e ErrorKind::InvalidInput,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\nimpl DiagnosticError for SandboxError {\n    fn hint(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::CapabilityDenied { capability } =\u003e Some(format!(\n                \"The tool requires the '{capability}' capability but it was not granted.\"\n            )),\n            Self::NetworkDenied { host } =\u003e Some(format!(\n                \"The tool tried to connect to '{host}' but network access is denied.\"\n            )),\n            Self::FsDenied { path } =\u003e Some(format!(\n                \"The tool tried to access '{path}' outside its sandbox.\"\n            )),\n            Self::InvalidConfig { .. } =\u003e {\n                Some(\"The security configuration in tool.toml has invalid values.\".into())\n            }\n            Self::WasiBuild { .. } =\u003e None,\n        }\n    }\n\n    fn fix(\u0026self) -\u003e Option\u003cString\u003e {\n        match self {\n            Self::NetworkDenied { host } =\u003e Some(format!(\n                \"Add to tool.toml:\\n  [security]\\n  net_allow_list = [\\\"{host}\\\"]\"\n            )),\n            Self::FsDenied { .. } =\u003e Some(\n                \"Set fs_access in tool.toml:\\n  [security]\\n  fs_access = \\\"read-only\\\"\".into(),\n            ),\n            Self::CapabilityDenied { .. } =\u003e {\n                Some(\"Grant the required capability in tool.toml [security] section.\".into())\n            }\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","filesystem.rs"],"content":"//! Filesystem jail for sandboxed tool execution.\n//!\n//! Three-layer defence: reject absolute paths, reject `..` components,\n//! then verify via canonicalization that the resolved path stays within the\n//! jail root (anti-symlink).\n\nuse std::path::{Component, Path, PathBuf};\n\nuse crate::error::SandboxError;\n\n/// Filesystem jail constraining tool access to a specific directory.\n#[derive(Debug, Clone)]\npub struct FsJail {\n    /// Root directory of the jail (NOT pre-canonicalized — done lazily).\n    root: PathBuf,\n}\n\nimpl FsJail {\n    /// Creates a new filesystem jail rooted at the given path.\n    pub fn new(root: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        Self { root: root.into() }\n    }\n\n    /// Validates that `path` is safe and lies within the jail.\n    ///\n    /// # Errors\n    ///\n    /// Returns `SandboxError::FsDenied` if:\n    /// - `path` is absolute\n    /// - `path` contains `..` components (traversal attempt)\n    /// - The resolved path escapes the jail root (symlink escape)\n    pub fn validate_path(\u0026self, path: \u0026Path) -\u003e Result\u003cPathBuf, SandboxError\u003e {\n        // 1. Reject absolute/rooted paths — only relative paths allowed.\n        //    `has_root()` catches Unix-style `/foo` on Windows where\n        //    `is_absolute()` requires a drive-letter prefix (e.g. `C:\\`).\n        if path.has_root() || path.is_absolute() {\n            return Err(SandboxError::FsDenied {\n                path: path.display().to_string(),\n            });\n        }\n\n        // 2. Reject any \"..\" component — no parent-dir traversal\n        for component in path.components() {\n            if matches!(component, Component::ParentDir) {\n                return Err(SandboxError::FsDenied {\n                    path: path.display().to_string(),\n                });\n            }\n        }\n\n        // 3. Build the full path within the jail\n        let full_path = self.root.join(path);\n\n        // 4. If the path exists, canonicalize both sides and verify containment\n        //    (protects against symlinks pointing outside the jail)\n        if full_path.exists() {\n            let canonical_root = self\n                .root\n                .canonicalize()\n                .map_err(|e| SandboxError::FsDenied {\n                    path: format!(\"cannot canonicalize root '{}': {e}\", self.root.display()),\n                })?;\n\n            let real_path = full_path\n                .canonicalize()\n                .map_err(|e| SandboxError::FsDenied {\n                    path: format!(\"cannot canonicalize '{}': {e}\", full_path.display()),\n                })?;\n\n            if !real_path.starts_with(\u0026canonical_root) {\n                return Err(SandboxError::FsDenied {\n                    path: path.display().to_string(),\n                });\n            }\n        }\n\n        Ok(full_path)\n    }\n\n    /// Returns the jail root.\n    pub fn root(\u0026self) -\u003e \u0026Path {\n        \u0026self.root\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_path_within_jail() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/output.txt\"));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn reject_parent_traversal() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"../../../etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn reject_embedded_parent() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/../../etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn reject_absolute_path() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"/etc/passwd\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn accept_nested_valid_path() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"data/subdir/file.txt\"));\n        assert!(result.is_ok());\n        let full = result.unwrap();\n        assert!(full.starts_with(\"/sandbox/tool1\"));\n    }\n\n    #[test]\n    fn reject_single_dot_dot() {\n        let jail = FsJail::new(\"/sandbox/tool1\");\n        let result = jail.validate_path(Path::new(\"..\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":32,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":36,"address":[],"length":0,"stats":{"Line":2161727821137838072}},{"line":37,"address":[],"length":0,"stats":{"Line":9007199254740992005}},{"line":38,"address":[],"length":0,"stats":{"Line":9007199254740992005}},{"line":43,"address":[],"length":0,"stats":{"Line":12610078956637388790}},{"line":44,"address":[],"length":0,"stats":{"Line":17942340915444056068}},{"line":45,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":46,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":52,"address":[],"length":0,"stats":{"Line":15564440312192434185}},{"line":56,"address":[],"length":0,"stats":{"Line":5188146770730811395}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":5188146770730811390}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":25},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","lib.rs"],"content":"//! # kami-sandbox\n//!\n//! Isolation and security enforcement for WASM tool execution.\n//! Implements capability-based security with deny-all defaults.\n//!\n//! Produces a `WasiCtx` that enforces network allow-lists,\n//! filesystem jailing, and resource limits.\n\npub mod capability;\npub mod error;\npub mod filesystem;\npub mod network;\npub mod wasi;\n\npub use capability::{validate_security_config, CapabilityChecker, DefaultCapabilityChecker};\npub use error::SandboxError;\npub use filesystem::FsJail;\npub use wasi::{build_wasi_ctx, WasiConfig};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","network.rs"],"content":"//! Network allow-list enforcement.\n//!\n//! Supports hostname patterns AND explicit IP addresses.\n//! Direct IP connections are blocked by default unless the IP is explicitly\n//! listed — this prevents bypassing hostname-based allow-lists.\n\nuse std::net::IpAddr;\nuse std::net::SocketAddr;\n\n/// Checks if a socket address is permitted by the allow list.\n///\n/// The allow list supports:\n/// - Exact hostnames: `\"api.github.com\"`\n/// - Wildcard hostnames: `\"*.example.com\"`\n/// - Explicit IPv4/IPv6 addresses: `\"93.184.216.34\"`\n///\n/// **Security:** Raw IP connections only succeed if the IP is explicitly\n/// listed. Hostnames are checked separately by `is_host_allowed`.\n/// This prevents bypassing hostname allow-lists via direct IP connections.\npub fn is_addr_allowed(addr: \u0026SocketAddr, allow_list: \u0026[String]) -\u003e bool {\n    let ip = addr.ip();\n    let ip_str = ip.to_string();\n\n    allow_list.iter().any(|pattern| {\n        // Explicit IP match (e.g. \"93.184.216.34\" or \"::1\")\n        if let Ok(allowed_ip) = pattern.parse::\u003cIpAddr\u003e() {\n            return ip == allowed_ip;\n        }\n        // Hostname pattern — IP strings never match hostname patterns\n        // (prevents \"*.example.com\" from matching \"93.184.216.34\")\n        is_ip_str_matching_hostname_pattern(\u0026ip_str, pattern)\n    })\n}\n\n/// Checks if a hostname string matches any pattern in the allow list.\n///\n/// Supports:\n/// - Exact matches: `\"api.github.com\"`\n/// - Wildcard subdomain: `\"*.example.com\"` (matches `sub.example.com`)\npub fn is_host_allowed(host: \u0026str, allow_list: \u0026[String]) -\u003e bool {\n    allow_list.iter().any(|pattern| {\n        if let Some(suffix) = pattern.strip_prefix(\"*.\") {\n            host == suffix || host.ends_with(\u0026format!(\".{suffix}\"))\n        } else {\n            host == pattern\n        }\n    })\n}\n\n/// Returns false for IP strings against hostname patterns.\n///\n/// An IP address string (e.g. `\"93.184.216.34\"`) can never match a hostname\n/// pattern (e.g. `\"*.example.com\"` or `\"api.github.com\"`). This function\n/// enforces that separation to prevent IP-based bypasses.\nfn is_ip_str_matching_hostname_pattern(ip_str: \u0026str, pattern: \u0026str) -\u003e bool {\n    // Only allow if the pattern IS a literal IP that matches exactly\n    // (already handled above via IpAddr parse). For hostname patterns,\n    // an IP string should never match.\n    ip_str == pattern\n}\n\n/// Validates that all entries in a network allow list are well-formed.\n///\n/// # Errors\n///\n/// Returns an error string if any pattern is empty or a malformed wildcard.\npub fn validate_allow_list(patterns: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    for pattern in patterns {\n        if pattern.is_empty() {\n            return Err(\"empty pattern in network allow list\".to_string());\n        }\n        if pattern.starts_with(\"*.\") \u0026\u0026 pattern.len() \u003c= 2 {\n            return Err(format!(\"invalid wildcard pattern: {pattern}\"));\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":21,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":22,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":24,"address":[],"length":0,"stats":{"Line":1080863910568919041}},{"line":26,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":31,"address":[],"length":0,"stats":{"Line":648518346341351430}},{"line":40,"address":[],"length":0,"stats":{"Line":432345564227567618}},{"line":41,"address":[],"length":0,"stats":{"Line":1152921504606846981}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423481}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855874}},{"line":55,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135235}},{"line":68,"address":[],"length":0,"stats":{"Line":1152921504606846979}},{"line":69,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":792633534417207296}}],"covered":21,"coverable":21},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-sandbox","src","wasi.rs"],"content":"//! WASI context builder for sandboxed execution.\n//!\n//! Builds a `WasiCtx` from a `SecurityConfig`, enforcing deny-all defaults\n//! and granular permissions for network and filesystem access.\n\nuse std::sync::Arc;\n\nuse kami_types::{FsAccess, SecurityConfig};\nuse wasmtime_wasi::{DirPerms, FilePerms, WasiCtx, WasiCtxBuilder};\n\nuse crate::error::SandboxError;\nuse crate::network::is_addr_allowed;\n\n/// Options controlling WASI context construction.\n#[derive(Debug, Clone, Default)]\npub struct WasiConfig {\n    /// Whether to inherit stdout (useful for CLI tools).\n    pub inherit_stdout: bool,\n    /// Whether to inherit stderr (useful for debugging).\n    pub inherit_stderr: bool,\n    /// Extra environment variables to expose.\n    pub env_vars: Vec\u003c(String, String)\u003e,\n}\n\n/// Builds a `WasiCtx` from a `SecurityConfig` and optional overrides.\n///\n/// Enforces:\n/// - Network: deny-all unless hosts match `net_allow_list` patterns\n/// - Filesystem: deny-all / read-only / sandbox based on `fs_access`\n/// - Env vars: only explicit vars from `wasi_config`\n/// - DNS: disabled unless network is allowed\npub fn build_wasi_ctx(\n    security: \u0026SecurityConfig,\n    wasi_config: \u0026WasiConfig,\n    sandbox_dir: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cWasiCtx, SandboxError\u003e {\n    let mut builder = WasiCtxBuilder::new();\n\n    // -- stdio --\n    if wasi_config.inherit_stdout {\n        builder.inherit_stdout();\n    }\n    if wasi_config.inherit_stderr {\n        builder.inherit_stderr();\n    }\n\n    // -- environment variables (filtered by env_allow_list) --\n    // If env_allow_list is non-empty, only listed vars are exposed.\n    // If env_allow_list is empty, all explicitly provided vars are allowed.\n    for (key, value) in \u0026wasi_config.env_vars {\n        if !security.env_allow_list.is_empty() \u0026\u0026 !security.env_allow_list.contains(key) {\n            tracing::warn!(\n                key = %key,\n                \"env var blocked by allow-list\"\n            );\n            continue;\n        }\n        builder.env(key, value);\n    }\n\n    // -- filesystem --\n    configure_filesystem(\u0026mut builder, security, sandbox_dir)?;\n\n    // -- network --\n    configure_network(\u0026mut builder, security);\n\n    Ok(builder.build())\n}\n\n/// Configures filesystem access based on security policy.\nfn configure_filesystem(\n    builder: \u0026mut WasiCtxBuilder,\n    security: \u0026SecurityConfig,\n    sandbox_dir: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c(), SandboxError\u003e {\n    match security.fs_access {\n        FsAccess::None =\u003e {\n            // No filesystem access - nothing to configure\n        }\n        FsAccess::ReadOnly =\u003e {\n            if let Some(dir) = sandbox_dir {\n                builder\n                    .preopened_dir(dir, \".\", DirPerms::READ, FilePerms::READ)\n                    .map_err(|e| SandboxError::WasiBuild {\n                        reason: format!(\"failed to preopen read-only dir: {e}\"),\n                    })?;\n            }\n        }\n        FsAccess::Sandbox =\u003e {\n            if let Some(dir) = sandbox_dir {\n                builder\n                    .preopened_dir(dir, \".\", DirPerms::all(), FilePerms::all())\n                    .map_err(|e| SandboxError::WasiBuild {\n                        reason: format!(\"failed to preopen sandbox dir: {e}\"),\n                    })?;\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Configures network access using `socket_addr_check` for granular control.\nfn configure_network(builder: \u0026mut WasiCtxBuilder, security: \u0026SecurityConfig) {\n    let allow_list = security.net_allow_list.clone();\n    let has_network = !allow_list.is_empty();\n\n    if has_network {\n        let patterns = Arc::new(allow_list);\n        builder.socket_addr_check(move |addr, _addr_use| {\n            let patterns = Arc::clone(\u0026patterns);\n            Box::pin(async move {\n                // Use is_addr_allowed: direct IP connections require explicit\n                // IP in the allow list — hostname patterns do not match IPs.\n                is_addr_allowed(\u0026addr, \u0026patterns)\n            })\n        });\n        builder.allow_ip_name_lookup(true);\n    }\n    // If no allow_list: network is deny-all by default (no inherit_network)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_types::SecurityConfig;\n\n    #[test]\n    fn default_security_produces_ctx() {\n        let security = SecurityConfig::default();\n        let wasi_config = WasiConfig::default();\n        let ctx = build_wasi_ctx(\u0026security, \u0026wasi_config, None);\n        assert!(ctx.is_ok());\n    }\n\n    #[test]\n    fn ctx_with_stdout_and_env() {\n        let security = SecurityConfig::default();\n        let wasi_config = WasiConfig {\n            inherit_stdout: true,\n            inherit_stderr: true,\n            env_vars: vec![(\"LANG\".to_string(), \"en_US\".to_string())],\n        };\n        let ctx = build_wasi_ctx(\u0026security, \u0026wasi_config, None);\n        assert!(ctx.is_ok());\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":37,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":40,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":41,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":50,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":62,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":65,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":67,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":71,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":76,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":77,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":104,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":105,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":107,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}}],"covered":20,"coverable":38},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","lib.rs"],"content":"//! # kami-store-sqlite\n//!\n//! SQLite adapter for the KAMI tool registry.\n//! Implements `ToolRepository` with full CRUD operations.\n\npub mod migrations;\nmod query_builder;\npub mod repository;\nmod repository_impl;\nmod row_mapping;\n\npub use repository::SqliteToolRepository;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","migrations.rs"],"content":"//! Database schema migrations for the tool registry.\n\nuse kami_registry::RepositoryError;\nuse rusqlite::Connection;\n\n/// Current schema version.\nconst SCHEMA_VERSION: u32 = 3;\n\n/// Runs all pending migrations on the database.\npub fn run_migrations(conn: \u0026Connection) -\u003e Result\u003c(), RepositoryError\u003e {\n    let current = get_schema_version(conn)?;\n\n    if current \u003c 1 {\n        migrate_v1(conn)?;\n    }\n    if current \u003c 2 {\n        migrate_v2(conn)?;\n    }\n    if current \u003c 3 {\n        migrate_v3(conn)?;\n    }\n\n    set_schema_version(conn, SCHEMA_VERSION)?;\n    Ok(())\n}\n\n/// Adds the `wasm_sha256` column for WASM integrity verification (v2).\nfn migrate_v2(conn: \u0026Connection) -\u003e Result\u003c(), RepositoryError\u003e {\n    conn.execute_batch(\"ALTER TABLE tools ADD COLUMN wasm_sha256 TEXT;\")\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"migration v2 failed: {e}\"),\n        })\n}\n\n/// Adds versioning columns for update \u0026 pin support (v3).\nfn migrate_v3(conn: \u0026Connection) -\u003e Result\u003c(), RepositoryError\u003e {\n    conn.execute_batch(\n        \"ALTER TABLE tools ADD COLUMN pinned_version TEXT;\n         ALTER TABLE tools ADD COLUMN updated_at TEXT;\",\n    )\n    .map_err(|e| RepositoryError::Storage {\n        message: format!(\"migration v3 failed: {e}\"),\n    })\n}\n\n/// Creates the initial schema (v1).\nfn migrate_v1(conn: \u0026Connection) -\u003e Result\u003c(), RepositoryError\u003e {\n    conn.execute_batch(\n        \"CREATE TABLE IF NOT EXISTS tools (\n            id          TEXT PRIMARY KEY NOT NULL,\n            name        TEXT NOT NULL,\n            version     TEXT NOT NULL,\n            description TEXT NOT NULL DEFAULT '',\n            wasm_path   TEXT NOT NULL,\n            install_path TEXT NOT NULL,\n            enabled     INTEGER NOT NULL DEFAULT 1,\n            security    TEXT NOT NULL DEFAULT '{}',\n            arguments   TEXT NOT NULL DEFAULT '[]',\n            installed_at TEXT NOT NULL DEFAULT (datetime('now'))\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_tools_name ON tools(name);\n        CREATE INDEX IF NOT EXISTS idx_tools_enabled ON tools(enabled);\",\n    )\n    .map_err(|e| RepositoryError::Storage {\n        message: format!(\"migration v1 failed: {e}\"),\n    })\n}\n\n/// Reads the current schema version from PRAGMA user_version.\nfn get_schema_version(conn: \u0026Connection) -\u003e Result\u003cu32, RepositoryError\u003e {\n    conn.query_row(\"PRAGMA user_version\", [], |row| row.get(0))\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"failed to read schema version: {e}\"),\n        })\n}\n\n/// Sets the schema version via PRAGMA user_version.\nfn set_schema_version(conn: \u0026Connection, version: u32) -\u003e Result\u003c(), RepositoryError\u003e {\n    conn.pragma_update(None, \"user_version\", version)\n        .map_err(|e| RepositoryError::Storage {\n            message: format!(\"failed to set schema version: {e}\"),\n        })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn migrations_run_on_fresh_db() {\n        let conn = Connection::open_in_memory().expect(\"in-memory db\");\n        run_migrations(\u0026conn).expect(\"migrations should succeed\");\n\n        let version = get_schema_version(\u0026conn).expect(\"version\");\n        assert_eq!(version, SCHEMA_VERSION);\n    }\n\n    #[test]\n    fn migrations_are_idempotent() {\n        let conn = Connection::open_in_memory().expect(\"in-memory db\");\n        run_migrations(\u0026conn).expect(\"first run\");\n        run_migrations(\u0026conn).expect(\"second run should also succeed\");\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":11,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":13,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":14,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":16,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":17,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":19,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":20,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":23,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":24,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":28,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":29,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":30,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":37,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":41,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":48,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":65,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":72,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":73,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":80,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":81,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":25,"coverable":30},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","query_builder.rs"],"content":"//! SQL query builder for `find_all` operations.\r\n\r\nuse kami_registry::ToolQuery;\r\n\r\nuse crate::repository_impl::COLS;\r\n\r\n/// Builds the SQL and parameters for `find_all`.\r\npub(crate) fn build_find_all_query(\r\n    query: \u0026ToolQuery,\r\n) -\u003e (String, Vec\u003cBox\u003cdyn rusqlite::types::ToSql\u003e\u003e) {\r\n    let mut sql = format!(\"SELECT {COLS} FROM tools WHERE 1=1\");\r\n    let mut params: Vec\u003cBox\u003cdyn rusqlite::types::ToSql\u003e\u003e = Vec::new();\r\n    if query.enabled_only {\r\n        sql.push_str(\" AND enabled = 1\");\r\n    }\r\n    if let Some(ref name) = query.name_filter {\r\n        sql.push_str(\" AND name LIKE ?\");\r\n        params.push(Box::new(format!(\"%{name}%\")));\r\n    }\r\n    sql.push_str(\" ORDER BY name ASC\");\r\n    if let Some(limit) = query.limit {\r\n        sql.push_str(\" LIMIT ?\");\r\n        params.push(Box::new(limit as i64));\r\n    }\r\n    if let Some(offset) = query.offset {\r\n        sql.push_str(\" OFFSET ?\");\r\n        params.push(Box::new(offset as i64));\r\n    }\r\n    (sql, params)\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":11,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":11,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","repository.rs"],"content":"//! SQLite implementation of `ToolRepository` — struct and constructors.\n\nuse std::sync::Mutex;\n\nuse kami_registry::RepositoryError;\nuse rusqlite::Connection;\n\nuse crate::migrations::run_migrations;\n\n/// SQLite-backed tool repository.\npub struct SqliteToolRepository {\n    pub(crate) conn: Mutex\u003cConnection\u003e,\n}\n\nimpl SqliteToolRepository {\n    /// Opens or creates a SQLite database at the given path and runs\n    /// migrations.\n    pub fn open(path: \u0026str) -\u003e Result\u003cSelf, RepositoryError\u003e {\n        let conn = Connection::open(path).map_err(|e| RepositoryError::Storage {\n            message: e.to_string(),\n        })?;\n        run_migrations(\u0026conn)?;\n        Ok(Self {\n            conn: Mutex::new(conn),\n        })\n    }\n\n    /// Opens an in-memory database (for testing).\n    pub fn open_in_memory() -\u003e Result\u003cSelf, RepositoryError\u003e {\n        let conn = Connection::open_in_memory().map_err(|e| RepositoryError::Storage {\n            message: e.to_string(),\n        })?;\n        run_migrations(\u0026conn)?;\n        Ok(Self {\n            conn: Mutex::new(conn),\n        })\n    }\n\n    /// Acquires the connection lock.\n    pub(crate) fn lock_conn(\n        \u0026self,\n    ) -\u003e Result\u003cstd::sync::MutexGuard\u003c'_, Connection\u003e, RepositoryError\u003e {\n        self.conn.lock().map_err(|e| RepositoryError::Storage {\n            message: format!(\"lock poisoned: {e}\"),\n        })\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":30,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":34,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":35,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":40,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":43,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":44,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","repository_impl.rs"],"content":"//! `ToolRepository` trait implementation for `SqliteToolRepository`.\n\nuse async_trait::async_trait;\nuse kami_registry::{RepositoryError, ToolQuery, ToolRepository};\nuse kami_types::{Tool, ToolId};\nuse rusqlite::params;\n\nuse crate::query_builder::build_find_all_query;\nuse crate::repository::SqliteToolRepository;\nuse crate::row_mapping::{row_to_tool, OptionalExt};\n\n/// Column list shared across all SELECT and UPDATE queries.\npub(crate) const COLS: \u0026str = \"\\\n    id, name, version, description, wasm_path, \\\n    install_path, enabled, security, arguments, wasm_sha256, \\\n    pinned_version, updated_at\";\n\n/// Maps a `rusqlite::Error` to a `RepositoryError::Storage`.\nfn map_sqlite_err(e: rusqlite::Error) -\u003e RepositoryError {\n    RepositoryError::Storage {\n        message: e.to_string(),\n    }\n}\n\n#[async_trait]\nimpl ToolRepository for SqliteToolRepository {\n    async fn find_by_id(\u0026self, id: \u0026ToolId) -\u003e Result\u003cOption\u003cTool\u003e, RepositoryError\u003e {\n        let conn = self.lock_conn()?;\n        let sql = format!(\"SELECT {COLS} FROM tools WHERE id = ?1\");\n        let mut stmt = conn.prepare(\u0026sql).map_err(map_sqlite_err)?;\n        let result = stmt\n            .query_row(params![id.as_str()], row_to_tool)\n            .optional()\n            .map_err(map_sqlite_err)?;\n        Ok(result)\n    }\n\n    async fn find_all(\u0026self, query: ToolQuery) -\u003e Result\u003cVec\u003cTool\u003e, RepositoryError\u003e {\n        let conn = self.lock_conn()?;\n        let (sql, param_values) = build_find_all_query(\u0026query);\n        let mut stmt = conn.prepare(\u0026sql).map_err(map_sqlite_err)?;\n        let params_refs: Vec\u003c\u0026dyn rusqlite::types::ToSql\u003e =\n            param_values.iter().map(|p| p.as_ref()).collect();\n        let tools = stmt\n            .query_map(params_refs.as_slice(), row_to_tool)\n            .map_err(map_sqlite_err)?\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .map_err(map_sqlite_err)?;\n        Ok(tools)\n    }\n\n    async fn insert(\u0026self, tool: \u0026Tool) -\u003e Result\u003c(), RepositoryError\u003e {\n        let conn = self.lock_conn()?;\n        let m = \u0026tool.manifest;\n        let security_json =\n            serde_json::to_string(\u0026m.security).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize security: {e}\"),\n            })?;\n        let args_json =\n            serde_json::to_string(\u0026m.arguments).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize arguments: {e}\"),\n            })?;\n        conn.execute(\n            \"INSERT INTO tools (id, name, version, description, wasm_path, \\\n             install_path, enabled, security, arguments, wasm_sha256) \\\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\",\n            params![\n                m.id.as_str(),\n                m.name,\n                m.version.to_string(),\n                m.description,\n                m.wasm,\n                tool.install_path,\n                tool.enabled as i32,\n                security_json,\n                args_json,\n                m.wasm_sha256,\n            ],\n        )\n        .map_err(|e| {\n            if let rusqlite::Error::SqliteFailure(ref err, _) = e {\n                if err.code == rusqlite::ErrorCode::ConstraintViolation {\n                    return RepositoryError::Conflict {\n                        message: format!(\"tool already exists: {}\", m.id),\n                    };\n                }\n            }\n            RepositoryError::Storage {\n                message: e.to_string(),\n            }\n        })?;\n        Ok(())\n    }\n\n    async fn update(\u0026self, tool: \u0026Tool) -\u003e Result\u003c(), RepositoryError\u003e {\n        let conn = self.lock_conn()?;\n        let m = \u0026tool.manifest;\n        let security_json =\n            serde_json::to_string(\u0026m.security).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize security: {e}\"),\n            })?;\n        let args_json =\n            serde_json::to_string(\u0026m.arguments).map_err(|e| RepositoryError::Storage {\n                message: format!(\"serialize arguments: {e}\"),\n            })?;\n        let affected = conn\n            .execute(\n                \"UPDATE tools SET name=?2, version=?3, description=?4, wasm_path=?5, \\\n                 install_path=?6, enabled=?7, security=?8, arguments=?9, wasm_sha256=?10, \\\n                 pinned_version=?11, updated_at=?12 WHERE id=?1\",\n                params![\n                    m.id.as_str(),\n                    m.name,\n                    m.version.to_string(),\n                    m.description,\n                    m.wasm,\n                    tool.install_path,\n                    tool.enabled as i32,\n                    security_json,\n                    args_json,\n                    m.wasm_sha256,\n                    tool.pinned_version,\n                    tool.updated_at,\n                ],\n            )\n            .map_err(map_sqlite_err)?;\n        if affected == 0 {\n            return Err(RepositoryError::NotFound {\n                id: m.id.to_string(),\n            });\n        }\n        Ok(())\n    }\n\n    async fn delete(\u0026self, id: \u0026ToolId) -\u003e Result\u003cbool, RepositoryError\u003e {\n        let conn = self.lock_conn()?;\n        let affected = conn\n            .execute(\"DELETE FROM tools WHERE id = ?1\", params![id.as_str()])\n            .map_err(map_sqlite_err)?;\n        Ok(affected \u003e 0)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":11,"coverable":19},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-store-sqlite","src","row_mapping.rs"],"content":"//! Row-to-domain mapping for the SQLite tool repository.\n//!\n//! Converts raw SQLite rows into `Tool` domain objects and provides\n//! the `OptionalExt` helper for query results.\n\nuse kami_types::{SecurityConfig, Tool, ToolArgument, ToolId, ToolManifest, ToolVersion};\n\n/// Maps a SQLite row to a `Tool` domain object.\npub(crate) fn row_to_tool(row: \u0026rusqlite::Row\u003c'_\u003e) -\u003e rusqlite::Result\u003cTool\u003e {\n    let id_str: String = row.get(0)?;\n    let name: String = row.get(1)?;\n    let version_str: String = row.get(2)?;\n    let description: String = row.get(3)?;\n    let wasm_path: String = row.get(4)?;\n    let install_path: String = row.get(5)?;\n    let enabled: bool = row.get(6)?;\n    let security_json: String = row.get(7)?;\n    let args_json: String = row.get(8)?;\n    let wasm_sha256: Option\u003cString\u003e = row.get(9)?;\n    let pinned_version: Option\u003cString\u003e = row.get(10)?;\n    let updated_at: Option\u003cString\u003e = row.get(11)?;\n\n    let id = ToolId::new(id_str).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(0, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    let version: ToolVersion = version_str.parse().map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(2, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    // Propagate parse errors rather than silently falling back to defaults.\n    // A corrupt JSON column should surface as a repository error, not a\n    // silent permission downgrade.\n    let security: SecurityConfig = serde_json::from_str(\u0026security_json).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(7, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    let arguments: Vec\u003cToolArgument\u003e = serde_json::from_str(\u0026args_json).map_err(|e| {\n        rusqlite::Error::FromSqlConversionFailure(8, rusqlite::types::Type::Text, Box::new(e))\n    })?;\n\n    Ok(Tool {\n        manifest: ToolManifest {\n            id,\n            name,\n            version,\n            wasm: wasm_path,\n            description,\n            arguments,\n            security,\n            wasm_sha256,\n        },\n        install_path,\n        enabled,\n        pinned_version,\n        updated_at,\n    })\n}\n\n/// Extension trait for optional query results.\npub(crate) trait OptionalExt\u003cT\u003e {\n    /// Converts a \"no rows\" error into `Ok(None)`.\n    fn optional(self) -\u003e Result\u003cOption\u003cT\u003e, rusqlite::Error\u003e;\n}\n\nimpl\u003cT\u003e OptionalExt\u003cT\u003e for Result\u003cT, rusqlite::Error\u003e {\n    fn optional(self) -\u003e Result\u003cOption\u003cT\u003e, rusqlite::Error\u003e {\n        match self {\n            Ok(val) =\u003e Ok(Some(val)),\n            Err(rusqlite::Error::QueryReturnedNoRows) =\u003e Ok(None),\n            Err(e) =\u003e Err(e),\n        }\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":10,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":11,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":12,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":13,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":14,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":15,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":16,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":17,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":18,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":19,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":20,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":21,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":23,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":43,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":44,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":45,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":46,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":47,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":48,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":49,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":50,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":51,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":53,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":54,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":55,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":56,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","auth.rs"],"content":"//! Bearer token authentication for MCP HTTP requests.\n\nuse axum::http::{header, HeaderMap, StatusCode};\n\n/// Validates the `Authorization: Bearer \u003ctoken\u003e` header.\n///\n/// # Errors\n///\n/// Returns `StatusCode::UNAUTHORIZED` if the header is absent or the\n/// token does not match `expected`.\npub(crate) fn validate_bearer(headers: \u0026HeaderMap, expected: \u0026str) -\u003e Result\u003c(), StatusCode\u003e {\n    let provided = headers\n        .get(header::AUTHORIZATION)\n        .and_then(|v| v.to_str().ok())\n        .and_then(|v| v.strip_prefix(\"Bearer \"));\n\n    if provided == Some(expected) {\n        Ok(())\n    } else {\n        Err(StatusCode::UNAUTHORIZED)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::http::{HeaderMap, HeaderValue};\n\n    #[test]\n    fn valid_bearer_passes() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Bearer secret123\"),\n        );\n        assert!(validate_bearer(\u0026headers, \"secret123\").is_ok());\n    }\n\n    #[test]\n    fn wrong_token_rejected() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Bearer wrong\"),\n        );\n        assert!(validate_bearer(\u0026headers, \"secret123\").is_err());\n    }\n\n    #[test]\n    fn missing_header_rejected() {\n        let headers = HeaderMap::new();\n        assert!(validate_bearer(\u0026headers, \"secret123\").is_err());\n    }\n\n    #[test]\n    fn basic_auth_scheme_rejected() {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Basic secret123\"),\n        );\n        assert!(validate_bearer(\u0026headers, \"secret123\").is_err());\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":12,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":13,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":14,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":15,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":17,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":8,"coverable":8},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","error.rs"],"content":"//! Error types for the HTTP/MCP transport layer.\n\nuse thiserror::Error;\n\n/// Errors that can occur in the HTTP transport.\n#[derive(Debug, Error)]\npub enum HttpTransportError {\n    /// Failed to bind to the TCP address.\n    #[error(\"failed to bind on {addr}: {source}\")]\n    Bind {\n        /// The address string.\n        addr: String,\n        /// The underlying I/O error.\n        #[source]\n        source: std::io::Error,\n    },\n    /// The HTTP server encountered an I/O error while serving.\n    #[error(\"server error: {0}\")]\n    Serve(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn bind_error_displays_address() {\n        let err = HttpTransportError::Bind {\n            addr: \"127.0.0.1:8080\".into(),\n            source: std::io::Error::new(std::io::ErrorKind::AddrInUse, \"in use\"),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"127.0.0.1:8080\"));\n    }\n\n    #[test]\n    fn serve_error_displays_message() {\n        let err = HttpTransportError::Serve(\"connection reset\".into());\n        assert!(err.to_string().contains(\"connection reset\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","lib.rs"],"content":"//! HTTP/JSON-RPC transport adapter for KAMI.\n//! Exposes MCP over `POST /mcp` with optional Bearer token authentication.\n\nmod auth;\nmod error;\nmod router;\npub mod server;\n\npub use error::HttpTransportError;\npub use server::HttpServer;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","router.rs"],"content":"//! Axum router for the MCP HTTP/JSON-RPC transport.\n//! Exposes `POST /mcp` for requests and `GET /health` for liveness checks.\n\nuse std::sync::Arc;\n\nuse axum::{\n    extract::State,\n    http::{header, HeaderMap, StatusCode},\n    response::IntoResponse,\n    routing::{get, post},\n    Json, Router,\n};\nuse serde_json::{json, Value};\n\nuse kami_protocol::{error_codes, JsonRpcNotification, JsonRpcRequest};\nuse kami_transport_stdio::McpHandler;\n\nuse crate::auth;\n\n/// Shared state threaded through all axum handlers.\n#[derive(Clone)]\npub(crate) struct AppState {\n    /// The MCP request dispatcher.\n    pub handler: Arc\u003cMcpHandler\u003e,\n    /// Optional Bearer token (None = no authentication required).\n    pub token: Option\u003cString\u003e,\n}\n\n/// Builds the axum `Router` with all MCP routes.\npub(crate) fn build_router(state: AppState) -\u003e Router {\n    Router::new()\n        .route(\"/mcp\", post(handle_mcp))\n        .route(\"/health\", get(handle_health))\n        .with_state(state)\n}\n\nasync fn handle_health() -\u003e impl IntoResponse {\n    Json(json!({\"status\": \"ok\", \"service\": \"kami\"}))\n}\n\nasync fn handle_mcp(\n    State(state): State\u003cAppState\u003e,\n    headers: HeaderMap,\n    body: String,\n) -\u003e impl IntoResponse {\n    if let Some(ref token) = state.token {\n        if auth::validate_bearer(\u0026headers, token).is_err() {\n            return (\n                StatusCode::UNAUTHORIZED,\n                Json(json!({\"error\": \"unauthorized\"})),\n            )\n                .into_response();\n        }\n    }\n\n    let json_val: Value = match serde_json::from_str(\u0026body) {\n        Ok(v) =\u003e v,\n        Err(_) =\u003e return json_rpc_error(StatusCode::OK, error_codes::PARSE_ERROR, \"Parse error\"),\n    };\n\n    let has_id = json_val.get(\"id\").is_some_and(|v| !v.is_null());\n    if !has_id {\n        if let Ok(notif) = serde_json::from_value::\u003cJsonRpcNotification\u003e(json_val) {\n            state.handler.handle_notification(\u0026notif);\n        }\n        return StatusCode::NO_CONTENT.into_response();\n    }\n\n    let request: JsonRpcRequest = match serde_json::from_value(json_val) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            return json_rpc_error(\n                StatusCode::OK,\n                error_codes::INVALID_REQUEST,\n                \u0026format!(\"Invalid request: {e}\"),\n            )\n        }\n    };\n\n    let output = state.handler.dispatch(\u0026request).await;\n    match output.to_json() {\n        Ok(json_str) =\u003e (\n            StatusCode::OK,\n            [(header::CONTENT_TYPE, \"application/json\")],\n            json_str,\n        )\n            .into_response(),\n        Err(e) =\u003e json_rpc_error(\n            StatusCode::INTERNAL_SERVER_ERROR,\n            error_codes::INTERNAL_ERROR,\n            \u0026e.to_string(),\n        ),\n    }\n}\n\n/// Produces a JSON-RPC error response without a request ID (id: null).\nfn json_rpc_error(status: StatusCode, code: i32, message: \u0026str) -\u003e axum::response::Response {\n    let body = json!({\n        \"jsonrpc\": \"2.0\",\n        \"id\": null,\n        \"error\": { \"code\": code, \"message\": message }\n    });\n    (status, Json(body)).into_response()\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-http","src","server.rs"],"content":"//! HTTP server that binds an axum Router to a TCP socket.\n\nuse std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse tokio::net::TcpListener;\n\nuse kami_transport_stdio::McpHandler;\n\nuse crate::error::HttpTransportError;\nuse crate::router::{build_router, AppState};\n\n/// Axum-based HTTP server for the MCP JSON-RPC transport.\npub struct HttpServer {\n    pub(crate) addr: SocketAddr,\n    pub(crate) state: AppState,\n}\n\nimpl HttpServer {\n    /// Creates a new HTTP server.\n    ///\n    /// # Arguments\n    ///\n    /// * `handler` — shared MCP dispatcher\n    /// * `port` — TCP port to listen on\n    /// * `token` — optional Bearer token for authentication\n    pub fn new(handler: Arc\u003cMcpHandler\u003e, port: u16, token: Option\u003cString\u003e) -\u003e Self {\n        Self {\n            addr: SocketAddr::from(([0, 0, 0, 0], port)),\n            state: AppState { handler, token },\n        }\n    }\n\n    /// Starts the server and blocks until it exits.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the TCP bind fails or the server crashes.\n    pub async fn run(self) -\u003e Result\u003c(), HttpTransportError\u003e {\n        let listener =\n            TcpListener::bind(self.addr)\n                .await\n                .map_err(|e| HttpTransportError::Bind {\n                    addr: self.addr.to_string(),\n                    source: e,\n                })?;\n\n        tracing::info!(addr = %self.addr, \"KAMI MCP HTTP server ready\");\n\n        let router = build_router(self.state);\n        axum::serve(listener, router)\n            .await\n            .map_err(|e| HttpTransportError::Serve(e.to_string()))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_runtime::{KamiRuntime, RuntimeConfig};\n    use kami_store_sqlite::SqliteToolRepository;\n    use kami_transport_stdio::McpHandler;\n\n    fn make_handler() -\u003e Arc\u003cMcpHandler\u003e {\n        let repo = Arc::new(SqliteToolRepository::open_in_memory().expect(\"in-memory db\"));\n        let config = RuntimeConfig {\n            cache_size: 4,\n            max_concurrent: 2,\n            epoch_interruption: false,\n        };\n        let runtime = Arc::new(KamiRuntime::new(config, repo.clone()).expect(\"runtime\"));\n        Arc::new(McpHandler::new(runtime, repo))\n    }\n\n    #[test]\n    fn new_sets_correct_port() {\n        let server = HttpServer::new(make_handler(), 3000, None);\n        assert_eq!(server.addr.port(), 3000);\n    }\n\n    #[test]\n    fn new_stores_bearer_token() {\n        let server = HttpServer::new(make_handler(), 8080, Some(\"s3cret\".to_string()));\n        assert_eq!(server.state.token.as_deref(), Some(\"s3cret\"));\n    }\n\n    #[test]\n    fn new_with_no_token() {\n        let server = HttpServer::new(make_handler(), 9000, None);\n        assert!(server.state.token.is_none());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":29,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":30,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","initialize.rs"],"content":"//! Handles the `initialize` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::initialize::{\n    InitializeParams, InitializeResult, ServerCapabilities, ServerInfo, ToolCapability,\n    PROTOCOL_VERSION,\n};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `initialize` request and returns the server capabilities.\npub(crate) fn handle_initialize(id: RequestId, params: \u0026Option\u003cValue\u003e) -\u003e JsonRpcOutput {\n    if let Some(p) = params {\n        if let Err(e) = serde_json::from_value::\u003cInitializeParams\u003e(p.clone()) {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                format!(\"invalid initialize params: {e}\"),\n            ));\n        }\n    }\n\n    let result = InitializeResult {\n        protocol_version: PROTOCOL_VERSION.to_string(),\n        capabilities: ServerCapabilities {\n            tools: Some(ToolCapability {}),\n        },\n        server_info: ServerInfo {\n            name: \"kami\".to_string(),\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        },\n    };\n\n    match serde_json::to_value(result) {\n        Ok(v) =\u003e JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) =\u003e JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":16,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":16},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","mod.rs"],"content":"//! MCP method dispatch functions.\n//!\n//! Each sub-module handles one family of MCP methods as free functions,\n//! keeping `McpHandler` itself thin (struct + routing only).\n\npub(crate) mod initialize;\npub(crate) mod tools_call;\npub(crate) mod tools_list;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","tools_call.rs"],"content":"//! Handles the `tools/call` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::tools::{ToolContent, ToolsCallParams, ToolsCallResult};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\nuse kami_runtime::KamiRuntime;\nuse kami_types::ToolId;\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `tools/call` request.\npub(crate) async fn handle_tools_call(\n    id: RequestId,\n    params: \u0026Option\u003cValue\u003e,\n    runtime: \u0026KamiRuntime,\n) -\u003e JsonRpcOutput {\n    // 1. Parse params\n    let call_params = match params {\n        Some(p) =\u003e match serde_json::from_value::\u003cToolsCallParams\u003e(p.clone()) {\n            Ok(cp) =\u003e cp,\n            Err(e) =\u003e {\n                return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                    id,\n                    error_codes::INVALID_PARAMS,\n                    format!(\"invalid tools/call params: {e}\"),\n                ));\n            }\n        },\n        None =\u003e {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                \"tools/call requires params\",\n            ));\n        }\n    };\n\n    // 2. Parse tool ID\n    let tool_id = match ToolId::new(\u0026call_params.name) {\n        Ok(tid) =\u003e tid,\n        Err(e) =\u003e {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INVALID_PARAMS,\n                format!(\"invalid tool name: {e}\"),\n            ));\n        }\n    };\n\n    // 3. Execute via runtime\n    let input = call_params.arguments.to_string();\n    tracing::debug!(%tool_id, \"executing tool via MCP\");\n\n    let (content, is_error) = match runtime.execute(\u0026tool_id, \u0026input).await {\n        Ok(result) =\u003e (result.content, !result.success),\n        Err(e) =\u003e (e.to_string(), true),\n    };\n\n    let call_result = ToolsCallResult {\n        content: vec![ToolContent::Text { text: content }],\n        is_error,\n    };\n\n    match serde_json::to_value(call_result) {\n        Ok(v) =\u003e JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) =\u003e JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","dispatch","tools_list.rs"],"content":"//! Handles the `tools/list` MCP method.\n\nuse serde_json::Value;\n\nuse kami_protocol::mcp::tools::{McpToolDefinition, ToolsListResult};\nuse kami_protocol::{error_codes, JsonRpcErrorResponse, JsonRpcResponse, RequestId};\nuse kami_registry::{ToolQuery, ToolRepository};\nuse kami_types::ToolArgument;\n\nuse crate::handler::JsonRpcOutput;\n\n/// Handles the `tools/list` request.\npub(crate) async fn handle_tools_list(\n    id: RequestId,\n    repository: \u0026dyn ToolRepository,\n) -\u003e JsonRpcOutput {\n    let tools = match repository.find_all(ToolQuery::all()).await {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e {\n            return JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                id,\n                error_codes::INTERNAL_ERROR,\n                format!(\"registry error: {e}\"),\n            ));\n        }\n    };\n\n    let definitions: Vec\u003cMcpToolDefinition\u003e = tools\n        .iter()\n        .filter(|t| t.enabled)\n        .map(|t| {\n            let m = \u0026t.manifest;\n            McpToolDefinition {\n                name: m.id.to_string(),\n                description: Some(m.description.clone()),\n                input_schema: build_input_schema(\u0026m.arguments),\n            }\n        })\n        .collect();\n\n    let result = ToolsListResult {\n        tools: definitions,\n        next_cursor: None,\n    };\n\n    match serde_json::to_value(result) {\n        Ok(v) =\u003e JsonRpcOutput::Success(JsonRpcResponse::success(id, v)),\n        Err(e) =\u003e JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n            id,\n            error_codes::INTERNAL_ERROR,\n            e.to_string(),\n        )),\n    }\n}\n\n/// Builds a JSON Schema `inputSchema` from tool arguments.\npub(crate) fn build_input_schema(arguments: \u0026[ToolArgument]) -\u003e Value {\n    let mut properties = serde_json::Map::new();\n    let mut required = Vec::new();\n\n    for arg in arguments {\n        let mut prop = serde_json::Map::new();\n        prop.insert(\"type\".to_string(), Value::String(arg.arg_type.clone()));\n        prop.insert(\n            \"description\".to_string(),\n            Value::String(arg.description.clone()),\n        );\n        properties.insert(arg.name.clone(), Value::Object(prop));\n        if arg.required {\n            required.push(Value::String(arg.name.clone()));\n        }\n    }\n\n    let mut schema = serde_json::Map::new();\n    schema.insert(\"type\".to_string(), Value::String(\"object\".to_string()));\n    schema.insert(\"properties\".to_string(), Value::Object(properties));\n    if !required.is_empty() {\n        schema.insert(\"required\".to_string(), Value::Array(required));\n    }\n\n    Value::Object(schema)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use kami_types::ToolArgument;\n\n    #[test]\n    fn build_input_schema_empty_args() {\n        let schema = build_input_schema(\u0026[]);\n        assert_eq!(schema[\"type\"], \"object\");\n        assert!(schema[\"properties\"].as_object().expect(\"obj\").is_empty());\n        assert!(schema.get(\"required\").is_none());\n    }\n\n    #[test]\n    fn build_input_schema_with_args() {\n        let args = vec![\n            ToolArgument {\n                name: \"url\".to_string(),\n                arg_type: \"string\".to_string(),\n                description: \"The URL\".to_string(),\n                required: true,\n                default: None,\n            },\n            ToolArgument {\n                name: \"timeout\".to_string(),\n                arg_type: \"number\".to_string(),\n                description: \"Timeout in ms\".to_string(),\n                required: false,\n                default: Some(\"5000\".to_string()),\n            },\n        ];\n        let schema = build_input_schema(\u0026args);\n        assert_eq!(schema[\"type\"], \"object\");\n        assert_eq!(schema[\"properties\"][\"url\"][\"type\"], \"string\");\n        assert_eq!(schema[\"properties\"][\"timeout\"][\"type\"], \"number\");\n        let req = schema[\"required\"].as_array().expect(\"arr\");\n        assert_eq!(req.len(), 1);\n        assert_eq!(req[0], \"url\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":59,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":63,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":76,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":78,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":31,"coverable":40},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","error.rs"],"content":"//! Transport-layer error types.\n\nuse kami_types::{ErrorKind, KamiError};\nuse thiserror::Error;\n\n/// Errors from the stdio transport layer.\n#[derive(Debug, Error)]\npub enum TransportError {\n    /// Failed to read from stdin.\n    #[error(\"read error: {0}\")]\n    Read(String),\n    /// Failed to write to stdout.\n    #[error(\"write error: {0}\")]\n    Write(String),\n    /// Failed to parse incoming JSON message.\n    #[error(\"parse error: {0}\")]\n    Parse(String),\n    /// The connection was closed (EOF on stdin).\n    #[error(\"connection closed\")]\n    ConnectionClosed,\n    /// Handler returned an error during dispatch.\n    #[error(\"dispatch error: {0}\")]\n    Dispatch(String),\n}\n\nimpl From\u003cTransportError\u003e for KamiError {\n    fn from(e: TransportError) -\u003e Self {\n        let kind = match \u0026e {\n            TransportError::Parse(_) =\u003e ErrorKind::InvalidInput,\n            TransportError::ConnectionClosed =\u003e ErrorKind::Internal,\n            _ =\u003e ErrorKind::Internal,\n        };\n        KamiError::new(kind, e.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_error_converts_to_invalid_input() {\n        let err: KamiError = TransportError::Parse(\"bad json\".into()).into();\n        assert_eq!(err.kind, ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn connection_closed_converts_to_internal() {\n        let err: KamiError = TransportError::ConnectionClosed.into();\n        assert_eq!(err.kind, ErrorKind::Internal);\n    }\n\n    #[test]\n    fn dispatch_error_converts_to_internal() {\n        let err: KamiError = TransportError::Dispatch(\"fail\".into()).into();\n        assert_eq!(err.kind, ErrorKind::Internal);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":6,"coverable":6},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","handler.rs"],"content":"//! MCP method dispatch handler.\n//!\n//! `McpHandler` routes incoming JSON-RPC requests to the method-specific\n//! handlers in the `dispatch` sub-modules and returns a typed response.\n\nuse std::sync::Arc;\n\nuse tracing::debug;\n\nuse kami_protocol::mcp::methods;\nuse kami_protocol::{\n    error_codes, JsonRpcErrorResponse, JsonRpcNotification, JsonRpcRequest, JsonRpcResponse,\n};\nuse kami_registry::ToolRepository;\nuse kami_runtime::KamiRuntime;\n\nuse crate::dispatch;\nuse crate::error::TransportError;\n\n/// Handles MCP method dispatch over JSON-RPC.\n///\n/// Combines a `KamiRuntime` (for tool execution) and a\n/// `ToolRepository` (for tool listing) to serve MCP requests.\npub struct McpHandler {\n    runtime: Arc\u003cKamiRuntime\u003e,\n    repository: Arc\u003cdyn ToolRepository\u003e,\n}\n\n/// Enum representing either a success or error JSON-RPC response.\n#[derive(Debug)]\npub enum JsonRpcOutput {\n    /// Success response.\n    Success(JsonRpcResponse),\n    /// Error response.\n    Error(JsonRpcErrorResponse),\n}\n\nimpl JsonRpcOutput {\n    /// Serializes the output to a JSON string.\n    pub fn to_json(\u0026self) -\u003e Result\u003cString, TransportError\u003e {\n        match self {\n            Self::Success(r) =\u003e serde_json::to_string(r),\n            Self::Error(r) =\u003e serde_json::to_string(r),\n        }\n        .map_err(|e| TransportError::Write(e.to_string()))\n    }\n}\n\nimpl McpHandler {\n    /// Creates a new handler with the given runtime and repository.\n    pub fn new(runtime: Arc\u003cKamiRuntime\u003e, repository: Arc\u003cdyn ToolRepository\u003e) -\u003e Self {\n        Self {\n            runtime,\n            repository,\n        }\n    }\n\n    /// Dispatches a JSON-RPC request to the appropriate method handler.\n    #[tracing::instrument(skip(self, request), fields(method = %request.method))]\n    pub async fn dispatch(\u0026self, request: \u0026JsonRpcRequest) -\u003e JsonRpcOutput {\n        debug!(method = %request.method, \"dispatching MCP request\");\n\n        match request.method.as_str() {\n            methods::INITIALIZE =\u003e {\n                dispatch::initialize::handle_initialize(request.id.clone(), \u0026request.params)\n            }\n            methods::TOOLS_LIST =\u003e {\n                dispatch::tools_list::handle_tools_list(\n                    request.id.clone(),\n                    self.repository.as_ref(),\n                )\n                .await\n            }\n            methods::TOOLS_CALL =\u003e {\n                dispatch::tools_call::handle_tools_call(\n                    request.id.clone(),\n                    \u0026request.params,\n                    \u0026self.runtime,\n                )\n                .await\n            }\n            other =\u003e {\n                tracing::warn!(method = other, \"unknown MCP method\");\n                JsonRpcOutput::Error(JsonRpcErrorResponse::error(\n                    request.id.clone(),\n                    error_codes::METHOD_NOT_FOUND,\n                    format!(\"unknown method: {other}\"),\n                ))\n            }\n        }\n    }\n\n    /// Handles a JSON-RPC notification silently (no response is sent).\n    ///\n    /// Per the MCP spec, `notifications/initialized` must be accepted\n    /// without generating a response.\n    pub fn handle_notification(\u0026self, notification: \u0026JsonRpcNotification) {\n        match notification.method.as_str() {\n            methods::NOTIFICATIONS_INITIALIZED =\u003e {\n                debug!(\"MCP session initialized by client\");\n            }\n            other =\u003e {\n                debug!(method = other, \"notification ignored\");\n            }\n        }\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":41,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":42,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":45,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":60,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":13},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","lib.rs"],"content":"//! # kami-transport-stdio\n//!\n//! Stdio transport adapter for MCP JSON-RPC communication.\n//!\n//! Provides line-delimited JSON transport over stdin/stdout,\n//! MCP method dispatch, and a server loop that ties them together.\n\nmod dispatch;\npub mod error;\npub mod handler;\npub mod server;\npub mod transport;\n\npub use error::TransportError;\npub use handler::McpHandler;\npub use server::McpServer;\npub use transport::StdioTransport;\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","server.rs"],"content":"//! MCP server loop over stdio transport.\n//!\n//! Reads JSON-RPC requests line by line, dispatches them via\n//! `McpHandler`, and writes responses back. JSON-RPC notifications\n//! (which have no `id` field) are handled silently without a response.\n\nuse tracing::{debug, error, info, warn};\n\nuse kami_protocol::{\n    error_codes, JsonRpcErrorResponse, JsonRpcNotification, JsonRpcRequest, RequestId,\n};\n\nuse crate::error::TransportError;\nuse crate::handler::{JsonRpcOutput, McpHandler};\nuse crate::transport::StdioTransport;\n\n/// MCP server that reads from a transport and dispatches to a handler.\npub struct McpServer\u003cR, W\u003e {\n    transport: StdioTransport\u003cR, W\u003e,\n    handler: McpHandler,\n}\n\nimpl\u003cR, W\u003e McpServer\u003cR, W\u003e\nwhere\n    R: tokio::io::AsyncRead + Unpin,\n    W: tokio::io::AsyncWrite + Unpin,\n{\n    /// Creates a new server with the given transport and handler.\n    pub fn new(transport: StdioTransport\u003cR, W\u003e, handler: McpHandler) -\u003e Self {\n        Self { transport, handler }\n    }\n\n    /// Runs the server loop until the transport is closed.\n    ///\n    /// Each incoming line is parsed as either a JSON-RPC request\n    /// (response required) or a notification (silently handled).\n    pub async fn run(\u0026mut self) -\u003e Result\u003c(), TransportError\u003e {\n        info!(\"MCP server starting on stdio\");\n\n        loop {\n            // 1. Read next line\n            let line = match self.transport.read_line().await? {\n                Some(line) if line.is_empty() =\u003e continue,\n                Some(line) =\u003e line,\n                None =\u003e {\n                    info!(\"stdin closed, shutting down\");\n                    return Ok(());\n                }\n            };\n\n            // 2. Try parsing as a JSON-RPC request (has an `id`)\n            match serde_json::from_str::\u003cJsonRpcRequest\u003e(\u0026line) {\n                Ok(request) =\u003e {\n                    debug!(\n                        method = %request.method,\n                        id = ?request.id,\n                        \"received request\"\n                    );\n                    let output = self.handler.dispatch(\u0026request).await;\n                    self.write_output(\u0026output).await?;\n                }\n                Err(_) =\u003e {\n                    // 3. Fall back: try as notification (no `id` field)\n                    match serde_json::from_str::\u003cJsonRpcNotification\u003e(\u0026line) {\n                        Ok(notif) =\u003e {\n                            debug!(\n                                method = %notif.method,\n                                \"received notification\"\n                            );\n                            self.handler.handle_notification(\u0026notif);\n                            // Notifications must not receive a response.\n                        }\n                        Err(e) =\u003e {\n                            warn!(\n                                error = %e,\n                                \"failed to parse JSON-RPC message\"\n                            );\n                            let err = JsonRpcErrorResponse::error(\n                                RequestId::Number(0),\n                                error_codes::PARSE_ERROR,\n                                format!(\"parse error: {e}\"),\n                            );\n                            self.write_output(\u0026JsonRpcOutput::Error(err)).await?;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// Serializes and writes a JSON-RPC output to the transport.\n    async fn write_output(\u0026mut self, output: \u0026JsonRpcOutput) -\u003e Result\u003c(), TransportError\u003e {\n        match output.to_json() {\n            Ok(json) =\u003e self.transport.write_line(\u0026json).await,\n            Err(e) =\u003e {\n                error!(error = %e, \"failed to serialize response\");\n                Err(e)\n            }\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-transport-stdio","src","transport.rs"],"content":"//! Line-delimited JSON transport over stdin/stdout.\n//!\n//! Each JSON-RPC message is a single line terminated by `\\n`.\n//! This follows the MCP stdio transport specification.\n\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tracing::trace;\n\nuse crate::error::TransportError;\n\n/// Reads JSON-RPC messages from stdin, writes responses to stdout.\n///\n/// Uses line-delimited JSON: one complete JSON object per line.\n/// This struct is generic over reader/writer for testability.\npub struct StdioTransport\u003cR, W\u003e {\n    reader: BufReader\u003cR\u003e,\n    writer: W,\n}\n\nimpl\u003cR, W\u003e StdioTransport\u003cR, W\u003e\nwhere\n    R: tokio::io::AsyncRead + Unpin,\n    W: tokio::io::AsyncWrite + Unpin,\n{\n    /// Creates a new transport with the given reader and writer.\n    pub fn new(reader: R, writer: W) -\u003e Self {\n        Self {\n            reader: BufReader::new(reader),\n            writer,\n        }\n    }\n\n    /// Reads the next line from the input stream.\n    ///\n    /// Returns `None` on EOF (connection closed).\n    pub async fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cString\u003e, TransportError\u003e {\n        let mut line = String::new();\n        let bytes_read = self\n            .reader\n            .read_line(\u0026mut line)\n            .await\n            .map_err(|e| TransportError::Read(e.to_string()))?;\n\n        if bytes_read == 0 {\n            return Ok(None);\n        }\n\n        let trimmed = line.trim().to_string();\n        if trimmed.is_empty() {\n            return Ok(Some(String::new()));\n        }\n\n        trace!(len = trimmed.len(), \"read message\");\n        Ok(Some(trimmed))\n    }\n\n    /// Writes a JSON-RPC response line to the output stream.\n    pub async fn write_line(\u0026mut self, message: \u0026str) -\u003e Result\u003c(), TransportError\u003e {\n        trace!(len = message.len(), \"writing message\");\n\n        self.writer\n            .write_all(message.as_bytes())\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        self.writer\n            .write_all(b\"\\n\")\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        self.writer\n            .flush()\n            .await\n            .map_err(|e| TransportError::Write(e.to_string()))?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[tokio::test]\n    async fn read_single_line() {\n        let input = b\"{\\\"jsonrpc\\\":\\\"2.0\\\"}\\n\";\n        let reader = Cursor::new(input.to_vec());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let line = transport.read_line().await.expect(\"read\");\n        assert_eq!(line, Some(\"{\\\"jsonrpc\\\":\\\"2.0\\\"}\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn read_eof_returns_none() {\n        let reader = Cursor::new(Vec::\u003cu8\u003e::new());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let line = transport.read_line().await.expect(\"read\");\n        assert_eq!(line, None);\n    }\n\n    #[tokio::test]\n    async fn write_appends_newline() {\n        let reader = Cursor::new(Vec::\u003cu8\u003e::new());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        transport.write_line(\"{\\\"ok\\\":true}\").await.expect(\"write\");\n\n        let output = String::from_utf8(transport.writer.clone()).expect(\"utf8\");\n        assert_eq!(output, \"{\\\"ok\\\":true}\\n\");\n    }\n\n    #[tokio::test]\n    async fn read_multiple_lines() {\n        let input = b\"line1\\nline2\\nline3\\n\";\n        let reader = Cursor::new(input.to_vec());\n        let writer = Vec::new();\n        let mut transport = StdioTransport::new(reader, writer);\n\n        let l1 = transport.read_line().await.expect(\"r1\");\n        let l2 = transport.read_line().await.expect(\"r2\");\n        let l3 = transport.read_line().await.expect(\"r3\");\n        let l4 = transport.read_line().await.expect(\"r4\");\n\n        assert_eq!(l1, Some(\"line1\".to_string()));\n        assert_eq!(l2, Some(\"line2\".to_string()));\n        assert_eq!(l3, Some(\"line3\".to_string()));\n        assert_eq!(l4, None);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":36,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":38,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":49,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":28,"coverable":29},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","capability.rs"],"content":"//! Capability-based security types.\n\nuse serde::{Deserialize, Serialize};\n\n/// Filesystem access level.\n#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\npub enum FsAccess {\n    /// No filesystem access.\n    #[default]\n    None,\n    /// Read-only access within sandbox.\n    ReadOnly,\n    /// Read-write within sandbox directory.\n    Sandbox,\n}\n\n/// Resource limits for a WASM instance.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceLimits {\n    /// Maximum memory in megabytes.\n    #[serde(default = \"default_max_memory_mb\")]\n    pub max_memory_mb: u32,\n    /// Maximum execution time in milliseconds.\n    #[serde(default = \"default_max_execution_ms\")]\n    pub max_execution_ms: u64,\n    /// Maximum fuel (instruction budget).\n    #[serde(default = \"default_max_fuel\")]\n    pub max_fuel: u64,\n}\n\nfn default_max_memory_mb() -\u003e u32 {\n    64\n}\nfn default_max_execution_ms() -\u003e u64 {\n    5000\n}\nfn default_max_fuel() -\u003e u64 {\n    1_000_000\n}\n\nimpl Default for ResourceLimits {\n    fn default() -\u003e Self {\n        Self {\n            max_memory_mb: default_max_memory_mb(),\n            max_execution_ms: default_max_execution_ms(),\n            max_fuel: default_max_fuel(),\n        }\n    }\n}\n\n/// Security configuration for a tool.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SecurityConfig {\n    /// Allowed network destinations (glob patterns).\n    #[serde(default)]\n    pub net_allow_list: Vec\u003cString\u003e,\n    /// Filesystem access level.\n    #[serde(default)]\n    pub fs_access: FsAccess,\n    /// Allowed environment variable names (exact match, deny-all by default).\n    #[serde(default)]\n    pub env_allow_list: Vec\u003cString\u003e,\n    /// Resource limits.\n    #[serde(flatten)]\n    pub limits: ResourceLimits,\n}\n\nimpl Default for SecurityConfig {\n    fn default() -\u003e Self {\n        Self {\n            net_allow_list: Vec::new(),\n            fs_access: FsAccess::None,\n            env_allow_list: Vec::new(),\n            limits: ResourceLimits::default(),\n        }\n    }\n}\n\n/// A single capability granted to a tool instance.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum Capability {\n    /// Network access to a specific pattern.\n    Network(String),\n    /// Filesystem read access to a path.\n    FsRead(String),\n    /// Filesystem write access to a path.\n    FsWrite(String),\n    /// Environment variable access.\n    EnvVar(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn default_security_is_deny_all() {\n        let config = SecurityConfig::default();\n        assert!(config.net_allow_list.is_empty());\n        assert!(config.env_allow_list.is_empty());\n        assert_eq!(config.fs_access, FsAccess::None);\n    }\n\n    #[test]\n    fn resource_limits_defaults() {\n        let limits = ResourceLimits::default();\n        assert_eq!(limits.max_memory_mb, 64);\n        assert_eq!(limits.max_execution_ms, 5000);\n        assert_eq!(limits.max_fuel, 1_000_000);\n    }\n\n    #[test]\n    fn fs_access_serialization() {\n        let access = FsAccess::ReadOnly;\n        let json = serde_json::to_string(\u0026access).unwrap();\n        assert_eq!(json, \"\\\"read-only\\\"\");\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":33,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":35,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":36,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":38,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":39,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":43,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":45,"address":[],"length":0,"stats":{"Line":8358680908399640578}},{"line":46,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":47,"address":[],"length":0,"stats":{"Line":4179340454199820289}},{"line":70,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":72,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":74,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":75,"address":[],"length":0,"stats":{"Line":3602879701896396800}}],"covered":14,"coverable":14},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","error.rs"],"content":"//! Unified error types for the KAMI domain layer.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Classification of domain errors.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ErrorKind {\n    /// Resource not found.\n    NotFound,\n    /// Permission denied by capability checker.\n    PermissionDenied,\n    /// Invalid input data.\n    InvalidInput,\n    /// Operation timed out.\n    Timeout,\n    /// Resource limit exceeded (memory, fuel, etc.).\n    ResourceExhausted,\n    /// Internal error.\n    Internal,\n}\n\n/// Domain-level error with structured context.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KamiError {\n    /// The kind of error.\n    pub kind: ErrorKind,\n    /// Human-readable error message.\n    pub message: String,\n    /// Optional additional context.\n    pub context: Option\u003cString\u003e,\n}\n\nimpl KamiError {\n    /// Creates a new `KamiError`.\n    pub fn new(kind: ErrorKind, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            kind,\n            message: message.into(),\n            context: None,\n        }\n    }\n\n    /// Adds context to the error.\n    pub fn with_context(mut self, context: impl Into\u003cString\u003e) -\u003e Self {\n        self.context = Some(context.into());\n        self\n    }\n\n    /// Creates a not-found error.\n    pub fn not_found(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::NotFound, message)\n    }\n\n    /// Creates a permission-denied error.\n    pub fn permission_denied(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::PermissionDenied, message)\n    }\n\n    /// Creates an invalid-input error.\n    pub fn invalid_input(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(ErrorKind::InvalidInput, message)\n    }\n}\n\nimpl fmt::Display for KamiError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{:?}] {}\", self.kind, self.message)?;\n        if let Some(ctx) = \u0026self.context {\n            write!(f, \" ({})\", ctx)?;\n        }\n        Ok(())\n    }\n}\n\nimpl std::error::Error for KamiError {}\n\n/// Transforms technical errors into user-actionable diagnostics.\n///\n/// Implementors provide optional `hint` (cause explanation) and `fix`\n/// (concrete remediation step) for each error variant.\npub trait DiagnosticError {\n    /// A human-readable explanation of the likely cause.\n    fn hint(\u0026self) -\u003e Option\u003cString\u003e {\n        None\n    }\n    /// A concrete fix the user can apply (e.g. a config change).\n    fn fix(\u0026self) -\u003e Option\u003cString\u003e {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn error_display_without_context() {\n        let err = KamiError::new(ErrorKind::NotFound, \"tool not found\");\n        assert_eq!(err.to_string(), \"[NotFound] tool not found\");\n    }\n\n    #[test]\n    fn error_display_with_context() {\n        let err = KamiError::not_found(\"tool not found\").with_context(\"id: dev.example.fetch\");\n        assert!(err.to_string().contains(\"dev.example.fetch\"));\n    }\n\n    #[test]\n    fn error_serialization_roundtrip() {\n        let err = KamiError::new(ErrorKind::PermissionDenied, \"access denied\");\n        let json = serde_json::to_string(\u0026err).expect(\"serialize\");\n        let back: KamiError = serde_json::from_str(\u0026json).expect(\"deserialize\");\n        assert_eq!(back.kind, ErrorKind::PermissionDenied);\n        assert_eq!(back.message, \"access denied\");\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":40,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":63,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":70,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":20},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","event.rs"],"content":"//! Domain events for observability.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::SystemTime;\n\nuse crate::tool::ToolId;\n\n/// Domain events emitted during tool lifecycle.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum DomainEvent {\n    /// A tool has been installed.\n    ToolInstalled {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n    /// A tool execution has started.\n    ExecutionStarted {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n    /// A tool execution has completed.\n    ExecutionCompleted {\n        tool_id: ToolId,\n        duration_ms: u64,\n        success: bool,\n        timestamp: SystemTime,\n    },\n    /// A tool has been removed.\n    ToolRemoved {\n        tool_id: ToolId,\n        timestamp: SystemTime,\n    },\n}\n\nimpl DomainEvent {\n    /// Creates a tool-installed event.\n    pub fn tool_installed(tool_id: ToolId) -\u003e Self {\n        Self::ToolInstalled {\n            tool_id,\n            timestamp: SystemTime::now(),\n        }\n    }\n\n    /// Creates an execution-started event.\n    pub fn execution_started(tool_id: ToolId) -\u003e Self {\n        Self::ExecutionStarted {\n            tool_id,\n            timestamp: SystemTime::now(),\n        }\n    }\n\n    /// Creates an execution-completed event.\n    pub fn execution_completed(tool_id: ToolId, duration_ms: u64, success: bool) -\u003e Self {\n        Self::ExecutionCompleted {\n            tool_id,\n            duration_ms,\n            success,\n            timestamp: SystemTime::now(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn event_creation() {\n        let id = ToolId::new(\"dev.test.tool\").unwrap();\n        let event = DomainEvent::tool_installed(id);\n        match \u0026event {\n            DomainEvent::ToolInstalled { tool_id, .. } =\u003e {\n                assert_eq!(tool_id.as_str(), \"dev.test.tool\");\n            }\n            _ =\u003e panic!(\"unexpected event variant\"),\n        }\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":6},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","lib.rs"],"content":"//! # kami-types\n//!\n//! Domain types for the KAMI orchestrator.\n//! Zero external dependencies except `serde` for serialization.\n//! No filesystem I/O — `tool.toml` parsing is in `kami-config`.\n\npub mod capability;\npub mod error;\npub mod event;\npub mod manifest;\npub mod tool;\npub mod version;\n\n// Re-exports for convenience.\npub use capability::{Capability, FsAccess, ResourceLimits, SecurityConfig};\npub use error::{DiagnosticError, ErrorKind, KamiError};\npub use event::DomainEvent;\npub use tool::{Tool, ToolArgument, ToolId, ToolManifest, ToolVersion};\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","manifest.rs"],"content":"//! Tool manifest format documentation.\n//!\n//! Parsing of `tool.toml` lives in `kami-config::manifest_loader`\n//! to keep filesystem I/O and the `toml` crate out of the domain layer.\n//! Domain types (`ToolManifest`, `ToolArgument`, etc.) are in `tool.rs`.\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","tool.rs"],"content":"//! Tool identity and manifest types.\n//!\n//! `ToolVersion` display and parsing live in `version.rs`.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\nuse std::str::FromStr;\n\nuse crate::capability::SecurityConfig;\nuse crate::error::KamiError;\n\n/// Unique identifier for a tool (reverse-domain notation).\n/// Example: `dev.example.fetch-url`\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ToolId(String);\n\nimpl ToolId {\n    /// Creates a new `ToolId`, validating the format.\n    pub fn new(id: impl Into\u003cString\u003e) -\u003e Result\u003cSelf, KamiError\u003e {\n        let id = id.into();\n        if id.is_empty() {\n            return Err(KamiError::invalid_input(\"tool id cannot be empty\"));\n        }\n        if !id.contains('.') {\n            return Err(KamiError::invalid_input(\n                \"tool id must use reverse-domain notation (e.g. dev.example.tool)\",\n            ));\n        }\n        Ok(Self(id))\n    }\n\n    /// Returns the tool id as a string slice.\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl fmt::Display for ToolId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.write_str(\u0026self.0)\n    }\n}\n\nimpl FromStr for ToolId {\n    type Err = KamiError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Self::new(s)\n    }\n}\n\n/// Semantic version for a tool.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct ToolVersion {\n    pub major: u32,\n    pub minor: u32,\n    pub patch: u32,\n}\n\nimpl ToolVersion {\n    /// Creates a new version.\n    pub fn new(major: u32, minor: u32, patch: u32) -\u003e Self {\n        Self {\n            major,\n            minor,\n            patch,\n        }\n    }\n}\n\n/// MCP argument definition for a tool.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolArgument {\n    /// Argument name.\n    pub name: String,\n    /// JSON Schema type (string, number, boolean, etc.).\n    #[serde(rename = \"type\")]\n    pub arg_type: String,\n    /// Human-readable description.\n    pub description: String,\n    /// Whether this argument is required.\n    #[serde(default)]\n    pub required: bool,\n    /// Default value if not required.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub default: Option\u003cString\u003e,\n}\n\n/// Complete tool manifest (parsed from tool.toml).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolManifest {\n    /// Tool identity.\n    pub id: ToolId,\n    /// Human-readable name.\n    pub name: String,\n    /// Tool version.\n    pub version: ToolVersion,\n    /// Path to the WASM component file.\n    pub wasm: String,\n    /// MCP description.\n    pub description: String,\n    /// Tool arguments.\n    #[serde(default)]\n    pub arguments: Vec\u003cToolArgument\u003e,\n    /// Security configuration.\n    pub security: SecurityConfig,\n    /// SHA-256 hex digest of the WASM file (computed at install time).\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub wasm_sha256: Option\u003cString\u003e,\n}\n\n/// Installed tool with metadata.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Tool {\n    /// The tool manifest.\n    pub manifest: ToolManifest,\n    /// Installation path on disk.\n    pub install_path: String,\n    /// Whether the tool is enabled.\n    pub enabled: bool,\n    /// Pinned version — prevents updates beyond this version.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub pinned_version: Option\u003cString\u003e,\n    /// ISO 8601 timestamp of the last update.\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub updated_at: Option\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid_tool_id() {\n        let id = ToolId::new(\"dev.example.fetch-url\");\n        assert!(id.is_ok());\n        assert_eq!(id.unwrap().as_str(), \"dev.example.fetch-url\");\n    }\n\n    #[test]\n    fn empty_tool_id_rejected() {\n        assert!(ToolId::new(\"\").is_err());\n    }\n\n    #[test]\n    fn tool_id_without_dot_rejected() {\n        assert!(ToolId::new(\"no-dot\").is_err());\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":20,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":21,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":24,"address":[],"length":0,"stats":{"Line":2449958197289549820}},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855868}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855868}},{"line":29,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":33,"address":[],"length":0,"stats":{"Line":4179340454199820291}},{"line":34,"address":[],"length":0,"stats":{"Line":4179340454199820291}},{"line":39,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":40,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":13,"coverable":15},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","crates","kami-types","src","version.rs"],"content":"//! `ToolVersion` parsing and display.\n\nuse std::fmt;\nuse std::str::FromStr;\n\nuse crate::error::KamiError;\nuse crate::tool::ToolVersion;\n\nimpl fmt::Display for ToolVersion {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch)\n    }\n}\n\nimpl FromStr for ToolVersion {\n    type Err = KamiError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = s.split('.').collect();\n        if parts.len() != 3 {\n            return Err(KamiError::invalid_input(\n                \"version must be in semver format: MAJOR.MINOR.PATCH\",\n            ));\n        }\n        let parse = |p: \u0026str| -\u003e Result\u003cu32, KamiError\u003e {\n            p.parse::\u003cu32\u003e()\n                .map_err(|_| KamiError::invalid_input(format!(\"invalid version component: {p}\")))\n        };\n        Ok(Self {\n            major: parse(parts[0])?,\n            minor: parse(parts[1])?,\n            patch: parse(parts[2])?,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn version_parse() {\n        let v: ToolVersion = \"1.2.3\".parse().unwrap();\n        assert_eq!(v, ToolVersion::new(1, 2, 3));\n    }\n\n    #[test]\n    fn version_display() {\n        let v = ToolVersion::new(0, 1, 0);\n        assert_eq!(v.to_string(), \"0.1.0\");\n    }\n\n    #[test]\n    fn invalid_version_rejected() {\n        assert!(\"1.2\".parse::\u003cToolVersion\u003e().is_err());\n        assert!(\"a.b.c\".parse::\u003cToolVersion\u003e().is_err());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":11,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":18,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":19,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":20,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":25,"address":[],"length":0,"stats":{"Line":4179340454199820287}},{"line":26,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":27,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":30,"address":[],"length":0,"stats":{"Line":2233785415175766014}},{"line":31,"address":[],"length":0,"stats":{"Line":2017612633061982206}},{"line":32,"address":[],"length":0,"stats":{"Line":2017612633061982206}}],"covered":13,"coverable":13},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","echo","src","lib.rs"],"content":"//! Echo KAMI tool — returns the input unchanged.\r\n//!\r\n//! Demonstrates the simplest possible tool: pass input through verbatim.\r\n\r\nuse kami_guest::kami_tool;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.echo\",\r\n    version: \"0.1.0\",\r\n    description: \"Echoes back the JSON input unchanged\",\r\n    handler: handle,\r\n}\r\n\r\nfn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\r\n    // Validate that the input is valid JSON, then return it unmodified.\r\n    let _: serde_json::Value = serde_json::from_str(input)\r\n        .map_err(|e| format!(\"invalid JSON input: {e}\"))?;\r\n    Ok(input.to_string())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn echoes_object() {\r\n        let input = r#\"{\"key\":\"value\"}\"#;\r\n        let result = handle(input).unwrap();\r\n        assert_eq!(result, input);\r\n    }\r\n\r\n    #[test]\r\n    fn echoes_array() {\r\n        let input = r#\"[1,2,3]\"#;\r\n        let result = handle(input).unwrap();\r\n        assert_eq!(result, input);\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_invalid_json() {\r\n        let result = handle(\"not json\");\r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","hello-world","src","lib.rs"],"content":"//! Hello-world KAMI tool — minimal example.\r\n//!\r\n//! Takes a JSON `{ \"name\": \"...\" }` input and returns a greeting.\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.hello-world\",\r\n    version: \"0.1.0\",\r\n    description: \"Returns a greeting for the given name\",\r\n    handler: handle,\r\n}\r\n\r\n/// Input schema for the hello-world tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    name: String,\r\n}\r\n\r\nfn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    let greeting = format!(\"Hello, {}! Welcome to KAMI.\", args.name);\r\n    kami_guest::text_result(\u0026greeting)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn greets_with_name() {\r\n        let result = handle(r#\"{\"name\":\"Alice\"}\"#).unwrap();\r\n        assert!(result.contains(\"Hello, Alice!\"));\r\n    }\r\n\r\n    #[test]\r\n    fn missing_name_returns_error() {\r\n        let result = handle(r#\"{}\"#);\r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","http-fetch","src","lib.rs"],"content":"//! HTTP fetch KAMI tool — demonstrates network access.\r\n//!\r\n//! Takes a URL and returns the HTTP response body.\r\n//! Requires `net_allow_list` in `tool.toml` to permit outbound connections.\r\n//!\r\n//! **Note:** This example shows the tool *logic* for URL validation and\r\n//! response formatting. Actual HTTP is performed by the WASI HTTP outgoing\r\n//! handler at runtime — the tool receives the response body from the host.\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.http-fetch\",\r\n    version: \"0.1.0\",\r\n    description: \"Fetches content from a URL via HTTP GET\",\r\n    handler: handle,\r\n}\r\n\r\n/// Maximum response size (64 KiB) to avoid unbounded memory usage.\r\nconst DEFAULT_MAX_BYTES: u64 = 65_536;\r\n\r\n/// Input schema for the http-fetch tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    /// URL to fetch (must start with `http://` or `https://`).\r\n    url: String,\r\n    /// Optional maximum response body size in bytes.\r\n    max_bytes: Option\u003cu64\u003e,\r\n}\r\n\r\n/// Validates that the URL has an acceptable scheme.\r\nfn validate_url(url: \u0026str) -\u003e Result\u003c(), String\u003e {\r\n    if !url.starts_with(\"http://\") \u0026\u0026 !url.starts_with(\"https://\") {\r\n        return Err(format!(\r\n            \"unsupported URL scheme: expected http:// or https://, got '{url}'\"\r\n        ));\r\n    }\r\n    if url.len() \u003e 2048 {\r\n        return Err(\"URL exceeds maximum length (2048 bytes)\".to_string());\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    validate_url(\u0026args.url)?;\r\n\r\n    let max = args.max_bytes.unwrap_or(DEFAULT_MAX_BYTES);\r\n\r\n    // In a real WASI HTTP tool, this would call wasi:http/outgoing-handler.\r\n    // Here we return a structured placeholder showing what would be fetched.\r\n    let response = serde_json::json!({\r\n        \"url\": args.url,\r\n        \"max_bytes\": max,\r\n        \"status\": \"ready\",\r\n        \"note\": \"Actual HTTP fetch requires wasi:http/outgoing-handler\"\r\n    });\r\n\r\n    kami_guest::text_result(\u0026response.to_string())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn valid_https_url() {\r\n        let result = handle(r#\"{\"url\":\"https://example.com\"}\"#);\r\n        assert!(result.is_ok());\r\n        let body = result.unwrap();\r\n        assert!(body.contains(\"example.com\"));\r\n    }\r\n\r\n    #[test]\r\n    fn valid_http_url() {\r\n        let result = handle(r#\"{\"url\":\"http://api.local/data\"}\"#);\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_unsupported_scheme() {\r\n        let result = handle(r#\"{\"url\":\"ftp://evil.com/file\"}\"#);\r\n        assert!(result.is_err());\r\n        let err = result.unwrap_err();\r\n        assert!(err.contains(\"unsupported URL scheme\"));\r\n    }\r\n\r\n    #[test]\r\n    fn rejects_missing_url() {\r\n        let result = handle(r#\"{}\"#);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn custom_max_bytes() {\r\n        let result = handle(r#\"{\"url\":\"https://example.com\",\"max_bytes\":1024}\"#);\r\n        assert!(result.is_ok());\r\n        let body = result.unwrap();\r\n        assert!(body.contains(\"1024\"));\r\n    }\r\n\r\n    #[test]\r\n    fn validate_url_rejects_too_long() {\r\n        let long = format!(\"https://example.com/{}\", \"a\".repeat(2040));\r\n        assert!(validate_url(\u0026long).is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["F:","\\","APP","VSCODE","PROJET","KAMI","examples","json-transform","src","lib.rs"],"content":"//! JSON-transform KAMI tool — manipulate JSON objects.\r\n//!\r\n//! Supports three actions:\r\n//! - **pick**: Extract specific keys from an object\r\n//! - **flatten**: Flatten nested objects (dot-notation keys)\r\n//! - **count**: Count top-level keys in an object\r\n\r\nuse kami_guest::kami_tool;\r\nuse serde::Deserialize;\r\nuse serde_json::{Map, Value};\r\n\r\nkami_tool! {\r\n    name: \"dev.kami.json-transform\",\r\n    version: \"0.1.0\",\r\n    description: \"Transforms JSON data — pick, flatten, or count\",\r\n    handler: handle,\r\n}\r\n\r\n/// Input schema for the json-transform tool.\r\n#[derive(Deserialize)]\r\nstruct Input {\r\n    action: String,\r\n    data: Value,\r\n    #[serde(default)]\r\n    keys: Vec\u003cString\u003e,\r\n}\r\n\r\nfn handle(input: \u0026str) -\u003e Result\u003cString, String\u003e {\r\n    let args: Input = kami_guest::parse_input(input)?;\r\n    match args.action.as_str() {\r\n        \"pick\" =\u003e pick(\u0026args.data, \u0026args.keys),\r\n        \"flatten\" =\u003e flatten(\u0026args.data),\r\n        \"count\" =\u003e count(\u0026args.data),\r\n        other =\u003e Err(format!(\"unknown action: {other}\")),\r\n    }\r\n}\r\n\r\n/// Extracts only the specified keys from an object.\r\nfn pick(data: \u0026Value, keys: \u0026[String]) -\u003e Result\u003cString, String\u003e {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    let picked: Map\u003cString, Value\u003e = keys\r\n        .iter()\r\n        .filter_map(|k| obj.get(k).map(|v| (k.clone(), v.clone())))\r\n        .collect();\r\n    kami_guest::to_output(\u0026picked)\r\n}\r\n\r\n/// Flattens a nested object into dot-notation keys.\r\nfn flatten(data: \u0026Value) -\u003e Result\u003cString, String\u003e {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    let mut result = Map::new();\r\n    flatten_recursive(obj, String::new(), \u0026mut result);\r\n    kami_guest::to_output(\u0026result)\r\n}\r\n\r\n/// Recursively flattens nested objects using dot-separated keys.\r\nfn flatten_recursive(obj: \u0026Map\u003cString, Value\u003e, prefix: String, out: \u0026mut Map\u003cString, Value\u003e) {\r\n    for (key, value) in obj {\r\n        let full_key = if prefix.is_empty() {\r\n            key.clone()\r\n        } else {\r\n            format!(\"{prefix}.{key}\")\r\n        };\r\n        match value {\r\n            Value::Object(nested) =\u003e flatten_recursive(nested, full_key, out),\r\n            _ =\u003e {\r\n                out.insert(full_key, value.clone());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Counts the top-level keys in an object.\r\nfn count(data: \u0026Value) -\u003e Result\u003cString, String\u003e {\r\n    let obj = data.as_object().ok_or(\"data must be an object\")?;\r\n    kami_guest::text_result(\u0026format!(\"{}\", obj.len()))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn pick_extracts_keys() {\r\n        let input = r#\"{\"action\":\"pick\",\"data\":{\"a\":1,\"b\":2,\"c\":3},\"keys\":[\"a\",\"c\"]}\"#;\r\n        let result = handle(input).expect(\"pick\");\r\n        let parsed: Value = serde_json::from_str(\u0026result).expect(\"json\");\r\n        assert_eq!(parsed[\"a\"], 1);\r\n        assert_eq!(parsed[\"c\"], 3);\r\n        assert!(parsed.get(\"b\").is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn flatten_nested_objects() {\r\n        let input = r#\"{\"action\":\"flatten\",\"data\":{\"a\":{\"b\":1},\"c\":2}}\"#;\r\n        let result = handle(input).expect(\"flatten\");\r\n        let parsed: Value = serde_json::from_str(\u0026result).expect(\"json\");\r\n        assert_eq!(parsed[\"a.b\"], 1);\r\n        assert_eq!(parsed[\"c\"], 2);\r\n    }\r\n\r\n    #[test]\r\n    fn count_keys() {\r\n        let input = r#\"{\"action\":\"count\",\"data\":{\"x\":1,\"y\":2,\"z\":3}}\"#;\r\n        let result = handle(input).expect(\"count\");\r\n        assert!(result.contains(\"3\"));\r\n    }\r\n\r\n    #[test]\r\n    fn unknown_action_returns_error() {\r\n        let input = r#\"{\"action\":\"nope\",\"data\":{}}\"#;\r\n        assert!(handle(input).is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn pick_with_non_object_returns_error() {\r\n        let input = r#\"{\"action\":\"pick\",\"data\":\"not-an-object\",\"keys\":[\"a\"]}\"#;\r\n        assert!(handle(input).is_err());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>